---
title: cmake构建c/c++项目
date: 2020-05-20 17:54:08
categories:
- 基础知识
tags: [c/c++, cmake]
---

初学者可以参考文章中cmake简历教程比较清晰易懂。

## cmake简介

一般来说。GNU 开源软件的 Build 系统，软件的安装过程都是：
解压源代码包

```
./configure
make
make install
```

这个过程中， 需要有一个 configure 脚本，同时也需要一个 Makefile 文件。

最早的时候，程序员完成源代码开发以后，发布代码包时，一般会附带相应的 Makefile 文件。然后就可以 make && make install 来编译工程。当时并不需要这个运行 configure 的步骤。

但是如果一个程序被广泛使用以后 (特别是成功的开源软件)，可能需要被安装到不同的平台上使用。这个时候，在不同的平台做 build 的时，一方面可能需要对 Makefile 文件进行调整 (最常见的例子就是：编译器的名字在不同的平台可能不同)。另外一方面，可能需要用一个替代函数来替换当前平台所不支持的函数 (例如：有的平台上不支持strdup这个调用)，需要在程序里面给每个平台写#define。

为了避免手工做这些调整，人们开始写 configure 脚本来自动做这些调整工作 (现在在 make 之前先运行 configure 是 GNU Code Style 标准所规定的)。configure 脚本一般会先检查目前的环境，然后生成一个config.h 文件 (里面带了各种各样的#define) ，同时会生成一个 针对当前平台的 Makefile 文件，之后，make 命令就会使用到这个 Makefile文件。另外，GNU的 build 系统还有一些"乱七八糟"的功能，用户在使用 configure 这个脚本的时候，可能会使用到这些功能 (最常见的就是用 --prefix 来指定安装路径，用configure --help来查看说明等等)。

C++是分别编译的，如果一个工程源文件太多，一个一个编译时就会特别麻烦，于是人们想到，为什么不设计一种类似批处理的程序，来批处理编译源文件呢，于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是Makefile。

对于一个大工程，编写Makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成Makefile呢，于是就出现了cmake、autotools等工具，它能够输出各种各样的Makefile或者project文件，从而帮助程序员减轻负担。但是随之而来也就是编写对应的CMakeLists.txt文件，它是cmake所依据的规则。所以在编程的世界里没有捷径可走，还是要脚踏实地的。

原文件－－CMakeLists.txt ---cmake ---Makefile ---make ---生成可执行文件
CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）。因此CMake的编译基本就两个步骤：

```
cmake
make
```

cmake  指向CMakeLists.txt所在的目录，例如cmake .. 表示CMakeLists.txt在当前目录的上一级目录。cmake后会生成很多编译的中间文件以及makefile文件，所以一般建议新建一个新的目录，专门用来编译，例如：

```
mkdir build
cd build
cmake ..
make
```

## 示例

1）项目结构：

```
.
├── build
├── CMakeLists.txt
├── include
│   └── b.h
└── src
    ├── b.c
    └── main.c
```

2）代码：
![](https://img-blog.csdnimg.cn/20190827214653629.png)
3）CMakeLists.txt：

```
1 #1.cmake verson，指定cmake版本 
 2 cmake_minimum_required(VERSION 3.2)
 3 
 4 #2.project name，指定项目的名称，一般和项目的文件夹名称对应
 5 PROJECT(test_sqrt)
 6 
 7 #3.head file path，头文件目录
 8 INCLUDE_DIRECTORIES(
 9 include
10 )
11 
12 #4.source directory，源文件目录
13 AUX_SOURCE_DIRECTORY(src DIR_SRCS)
14 
15 #5.set environment variable，设置环境变量，编译用到的源文件全部都要放到这里，否则编译能够通过，但是执行的时候会出现各种问题，比如"symbol lookup error xxxxx , undefined symbol"
16 SET(TEST_MATH
17 ${DIR_SRCS}
18 )
19 
20 #6.add executable file，添加要编译的可执行文件
21 ADD_EXECUTABLE(${PROJECT_NAME} ${TEST_MATH})
22 
23 #7.add link library，添加可执行文件所需要的库，比如我们用到了libm.so（命名规则：lib+name+.so），就添加该库的名称
24 TARGET_LINK_LIBRARIES(${PROJECT_NAME} m)
```

4）编译：

```
mkdir build
cd build
cmake ..
make
```

## 参考文章

[c++构建之cmake](https://blog.csdn.net/liuxiao723846/article/details/100109034)
[cmake实例](https://www.cnblogs.com/cv-pr/p/6206921.html)
[cmake简明教程](https://blog.csdn.net/whahu1989/article/details/82078563)
