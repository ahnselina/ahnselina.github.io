---
layout: post
title: Redis源码阅读--压缩列表
categories: Redis
tags: [Redis, Key-Value存储系统,  源码阅读]

---
压缩列表（ziplist）
* Redis中的压缩列表实现及特点
* Redis中的压缩列表源码难点分析
* Redis中的压缩列表源码部分节选

---
### 一、Redis中的压缩列表实现及特点

压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。

一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。如下图（摘自《Redis设计与实现》）：

![](http://redisbook.com/_images/graphviz-fe42f343a3f32f477efb5e895da547d476a7c97d.png)

其中字段含义如下：
* zlbytes：占4个字节，记录整个压缩列表占用的内存字节数
* zltail_offset：占4个字节，记录压缩列表尾节点entryN距离压缩列表的起始地址的字节数
* zllength：占2个字节，记录了压缩列表的节点数量
* entry[1-N]：长度不定，保存数据
* zlend：占1个字节，保存一个常数255(0xFF)，标记压缩列表的末端。

#### 1. 创建一个空的压缩列表
```c
/* Create a new empty ziplist. */
unsigned char *ziplistNew(void) {   //创建并返回一个新的且空的压缩列表
    //ZIPLIST_HEADER_SIZE是压缩列表的表头大小，1字节是末端的end大小
    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;

    unsigned char *zl = zmalloc(bytes); //为表头和表尾end成员分配空间
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes); //将bytes成员初始化为bytes=11字节
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);  //空列表的tail_offset成员为表头大小为10
    ZIPLIST_LENGTH(zl) = 0;     //节点数量为0
    zl[bytes-1] = ZIP_END;      //将表尾end成员设置成默认的0xFF
    return zl;
}
```

相关的宏定义
```c
#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
```

一个空的压缩列表：
![](https://img-blog.csdn.net/20170414230708914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWVuX3dlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 2. 压缩列表节点结构

![](http://redisbook.com/_images/graphviz-cc6b40e182bfc142c12ac0518819a2d949eafa4a.png)

**压缩列表节点中的previous_entry_length**

previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。

previous_entry_length 属性的长度可以是 1 字节或者 5 字节：
* 如果前一节点的长度***小于254字节***， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面
* 如果前一节点的长度***大于等于254字节***， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。

因此可以看到这段获取前一个节点长度的宏定义：
```c
/* Decode the length of the previous element, from the perspective of the entry
 * pointed to by 'ptr'. */
#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
    if ((prevlensize) == 1) {                                                  \
        (prevlen) = (ptr)[0];                                                  \
    } else if ((prevlensize) == 5) {                                           \
        assert(sizeof((prevlensize)) == 4);                                    \
        memcpy(&(prevlen), ((char*)(ptr)) + 1, 4);                             \
        memrev32ifbe(&prevlen);                                                \
    }                                                                          \
} while(0);
```

>因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。


### 二、Redis中的压缩列表源码难点分析

#### 1. 压缩列表节点中的encoding

压缩列表节点的 encoding属性记录了节点的 content 属性所保存数据的类型以及长度：
* 一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；
* 一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；

表格中的下划线 _ 表示留空， 而 b 、 x 等变量则代表实际的二进制数据， 为了方便阅读， 多个字节之间用空格隔开。

字节数组编码：

| 编码  | 编码长度 | content保存的值长度 |
| ------------- |:-------------:| -----:|
| 00bbbbbb | 1 字节 |长度小于等于 2^6 −1 字节 |
| 01bbbbbb xxxxxxxx | 2 字节 | 长度小于等于 2^14 −1 字节 |
| 10______ aaaaaaaa bbbbbbbb cccccccc dddddddd | 5 字节 | 长度小于等于2^32 −1字节 |

整数编码：

| 编码  | 编码长度 | content保存的值 |
| ------------- |:-------------:| -----:|
| 1100 0000 | 1 字节 |16位有符号整数（int16_t 类型的整数） |
| 1101 0000 | 1 字节 | int32_t 类型的整数 |
| 1110 0000| 1 字节 | int64_t 类型的整数表示的范围 |
| 1111 0000| 1 字节 | 24位有符号整数表示的范围 |
| 1111 1110（0xfe）| 1 字节 | 8位有符号整数表示的范围 |
| 1111 xxxx| 1 字节 | 	4位立即数介于0-12之间，无对应value，保存在encoding |

关于1111 xxxx编码：1111 xxxx 首先最小值应该是1111 0001（1111 0000已经被占用），最大值应该是1111 1101（1111 1110与1111 1111均已经被占用），因此可用的编码值只能是 1 至 13，由于还需要减1，所以实际只能编码[0,12]

Redis提供的有关字节数组和整数编码的宏定义：
```c
/* Different encoding/length possibilities */
#define ZIP_STR_MASK 0xc0               //1100 0000    字节数组的掩码
#define ZIP_STR_06B (0 << 6)            //0000 0000
#define ZIP_STR_14B (1 << 6)            //0100 0000
#define ZIP_STR_32B (2 << 6)            //1000 0000

#define ZIP_INT_MASK 0x30               //0011 0000     整数的掩码
#define ZIP_INT_16B (0xc0 | 0<<4)       //1100 0000
#define ZIP_INT_32B (0xc0 | 1<<4)       //1101 0000
#define ZIP_INT_64B (0xc0 | 2<<4)       //1110 0000
#define ZIP_INT_24B (0xc0 | 3<<4)       //1111 0000
#define ZIP_INT_8B 0xfe                 //1111 1110

//掩码个功能就是区分一个encoding是字节数组编码还是整数编码
//如果这个宏返回 1 就代表该enc是字节数组，如果是 0 就代表是整数的编码
#define ZIP_IS_STR(enc) (((enc) & ZIP_STR_MASK) < ZIP_STR_MASK)
```


下面这段代码主要是为了获取一个压缩列表节点所占用的长度。
```c
/* Extract the encoding from the byte pointed by 'ptr' and set it into
 * 'encoding'. */
#define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
    (encoding) = (ptr[0]); \
    if ((encoding) < ZIP_STR_MASK) (encoding) &= ZIP_STR_MASK; \
} while(0)


/* Decode the length encoded in 'ptr'. The 'encoding' variable will hold the
 * entries encoding, the 'lensize' variable will hold the number of bytes
 * required to encode the entries length, and the 'len' variable will hold the
 * entries length. */
#define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
    if ((encoding) < ZIP_STR_MASK) {                                           \
        if ((encoding) == ZIP_STR_06B) {                                       \
            (lensize) = 1;                                                     \
            (len) = (ptr)[0] & 0x3f;                                           \
        } else if ((encoding) == ZIP_STR_14B) {                                \
            (lensize) = 2;                                                     \
            (len) = (((ptr)[0] & 0x3f) << 8) | (ptr)[1];                       \
        } else if (encoding == ZIP_STR_32B) {                                  \
            (lensize) = 5;                                                     \
            (len) = ((ptr)[1] << 24) |                                         \
                    ((ptr)[2] << 16) |                                         \
                    ((ptr)[3] <<  8) |                                         \
                    ((ptr)[4]);                                                \
        } else {                                                               \
            assert(NULL);                                                      \
        }                                                                      \
    } else {                                                                   \
        (lensize) = 1;                                                         \
        (len) = zipIntSize(encoding);                                          \
    }                                                                          \
} while(0);


/* Decode the number of bytes required to store the length of the previous
 * element, from the perspective of the entry pointed to by 'ptr'. */
#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    if ((ptr)[0] < ZIP_BIGLEN) {                                               \
        (prevlensize) = 1;                                                     \
    } else {                                                                   \
        (prevlensize) = 5;                                                     \
    }                                                                          \
} while(0);


/* Return the total number of bytes used by the entry pointed to by 'p'. */
static unsigned int zipRawEntryLength(unsigned char *p) {
    unsigned int prevlensize, encoding, lensize, len;
    ZIP_DECODE_PREVLENSIZE(p, prevlensize);
    ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
    return prevlensize + lensize + len;
}
```

ZIP_ENTRY_ENCODING中ZIP_STR_MASK为0xc0对应（1100 0000），小于0xc0的就表示编码为字节数组，大于0xc0的就表示编码为整数数组。需要注意的是，当encoding长度为5个字节时，表示的字节数组的长度由低32位表示，所以其长度为(len) = ((ptr)[1] << 24) |  ((ptr)[2] << 16) | ((ptr)[3] <<  8) | (ptr)[4])


---
### 参考资料
[Redis设计与实现](http://redisbook.com/preview/skiplist/content.html)  
[Redis源码3.0.6](https://github.com/antirez/redis/releases/tag/3.0.6)  
[Redis源码剖析和注释（六）--- 压缩列表(ziplist)](https://blog.csdn.net/men_wen/article/details/70176753) 
