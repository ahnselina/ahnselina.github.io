<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Github</title>
    <url>/2016/11/27/hello-github/</url>
    <content><![CDATA[<p> Hello, github<br> 开启一段新的旅程<br> 终于开启新的博客之旅<br> 在这里记录一个初级程序员的成长之路</p>
<ul>
<li>感谢<a href="http://myself659.github.io/">创智玩家</a>的技术支持</li>
</ul>
]]></content>
      <categories>
        <category>闲言乱语</category>
      </categories>
      <tags>
        <tag>交流分享</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式常见用法</title>
    <url>/2016/11/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要介绍正则表达式的常见用法</p>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:center">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td style="text-align:center">匹配字符串的开头</td>
</tr>
<tr>
<td>$</td>
<td style="text-align:center">匹配字符串的末尾</td>
</tr>
<tr>
<td>.</td>
<td style="text-align:center">匹配任意字符，除了换行符</td>
</tr>
<tr>
<td>[…]</td>
<td style="text-align:center">或，如[amk] 匹配 ‘a’，’m’或’k’</td>
</tr>
<tr>
<td>[^…]</td>
<td style="text-align:center">不在[]中的字符：[^abc] 表示非abc</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:center">重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td style="text-align:center">重复一次或更多次</td>
</tr>
<tr>
<td>？</td>
<td style="text-align:center">重复零次或一次；非贪婪方式</td>
</tr>
<tr>
<td>{n}</td>
<td style="text-align:center">重复n次</td>
</tr>
<tr>
<td>{n,m}</td>
<td style="text-align:center">重复n到m次</td>
</tr>
<tr>
<td>a\</td>
<td style="text-align:center">b</td>
<td>匹配a或b</td>
</tr>
<tr>
<td>\d</td>
<td style="text-align:center">匹配任意数字，等价于 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td style="text-align:center">匹配任意非数字的字符</td>
</tr>
<tr>
<td>\w</td>
<td style="text-align:center">匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\W</td>
<td style="text-align:center">匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\s</td>
<td style="text-align:center">匹配任意空白字符，等价于 [\t\n\r\f]</td>
</tr>
<tr>
<td>\S</td>
<td style="text-align:center">匹配任意非空字符</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:center">匹配一个单词边界，也就是指单词和空格间的位置</td>
</tr>
<tr>
<td>\B</td>
<td style="text-align:center">匹配非单词边界</td>
</tr>
</tbody>
</table>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><h4 id="非贪婪方式"><a href="#非贪婪方式" class="headerlink" title="非贪婪方式"></a>非贪婪方式</h4><ul>
<li>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</li>
<li>以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。</li>
<li>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。</li>
<li>这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</li>
<li>现在看看懒惰版的例子吧：</li>
<li>a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）</li>
</ul>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><ul>
<li>待补充</li>
</ul>
<h3 id="如何熟练掌握正则表达式"><a href="#如何熟练掌握正则表达式" class="headerlink" title="如何熟练掌握正则表达式"></a>如何熟练掌握正则表达式</h3><ul>
<li>使用使用再使用</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></li>
<li><a href="http://www.runoob.com/python/python-reg-expressions.html">Python正则表达式</a></li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习之如何学习编程（元学习课总结 二）</title>
    <url>/2016/12/12/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B2/</url>
    <content><![CDATA[<p>本系列文章主要是总结李笑来新生大学的元学习课内容，并补充自己的感想。</p>
<hr>
<h3 id="新手入门阶段的错误认知"><a href="#新手入门阶段的错误认知" class="headerlink" title="新手入门阶段的错误认知"></a>新手入门阶段的错误认知</h3><ol>
<li>必须要有天赋</li>
<li>必须[看]每一步，理解每个细节</li>
<li>必须从基础原理学起</li>
<li>禁止使用捷径，比如不能copy paste</li>
</ol>
<p>其实这4点要求，除了第一点，对于已经入门的人来说是对的，适用的；但是这几点对于新手来说并不适用。</p>
<h3 id="新手入门真正实用的方法"><a href="#新手入门真正实用的方法" class="headerlink" title="新手入门真正实用的方法"></a>新手入门真正实用的方法</h3><p>摆脱拖延症其实只需要你马上行动，初学者不要在乎脸面，不要因为别人觉得你的办法笨就不好意思实践，也不需要完美，更不需要<br>一上来就对所有的细节就了若指掌。</p>
<p>找一本<strong>实战型</strong>的入门指南，直接从项目入手，分三步搞定：</p>
<ol>
<li>直接把代码拷贝粘贴，然后把代码运行起来 – 这个过程需要只需要知道，我粘了哪些代码就能实现哪些功能，即搞清有什么输入有什么输出</li>
<li>再试着把代码一字一行的手动敲一遍 – 反复练习是必须的</li>
<li>再试图理清细节 – 基础原理也是重要的</li>
</ol>
<p>要先把小套路练好，理解之后，再用小套路去组成中套路，再由中套路去组成自己想要的大套路。<br>之所以这样玩，是因为<strong>新手学习技能时，一定要保证自己的初速度要够快</strong>，要能快速的收获成就感，快速形成一个良好的循环。<br>要不然真的很容易就变成从入门到放弃，正所谓</p>
<blockquote>
<p>一鼓作气，再而衰，三而竭</p>
</blockquote>
<p>所以一定要尽快形成良性循环</p>
<blockquote>
<p>小窍门：在学习的过程中要把犯错的地方以及如何做是正确的地方记下来，发表到自己的博客中，就像以前学习的错题本一样</p>
</blockquote>
<h3 id="关于大脑思考的五个结论"><a href="#关于大脑思考的五个结论" class="headerlink" title="关于大脑思考的五个结论"></a>关于大脑思考的五个结论</h3><ol>
<li>大脑不善于思考</li>
<li>大部分人的决策或者说所谓的思考，其实是记忆所组成的结果，并不是真正思考的结果</li>
<li>人类思考时总是用已知的事物理解新的事物，找以往相似的记忆，所以人们所说的理解，其实是记忆</li>
<li>人类在学习新东西时所谓的学习，其实是把新东西存在短期记忆中</li>
<li>没有大量练习是几乎不可能习得新技能的，所以题海战术有时是必要的</li>
</ol>
<h3 id="关于自学"><a href="#关于自学" class="headerlink" title="关于自学"></a>关于自学</h3><ul>
<li>阅读能力是自学能力的基础，大多数连只字不差的阅读这一点都做不到</li>
<li>要有能从字里行间得到关键信息的能力</li>
<li>要读一大堆书，迅速读完，有效选取合适的好的书籍，不要求一遍都要读懂，读不懂也要读完，还读不懂就多读几遍，然而大多数人是一读不懂就直接放弃了</li>
<li>学习就是满足好奇心</li>
<li>不管做得好不好都要去做，有机会做就要谢天谢地了</li>
<li>大多数人一生都败在这里，那就是只学习自己马上用得到的东西（比如领导力阶梯那本书群里认真看完的人比例很少）</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>闲谈杂聊</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习之如何学习编程（元学习课总结 一）</title>
    <url>/2016/12/06/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>本系列文章主要是总结李笑来新生大学的元学习课内容，并补充自己的感想。</p>
<hr>
<h3 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h3><blockquote>
<p>学习学习再学习</p>
</blockquote>
<p>这里引用李笑来的话，意思就是说先学会如何学习之后再来学习。顺便补充下，如何学习的至少，笑来称之为元知识，挺有意思的一个概念。</p>
<p>学习过程（主要针对类似编程这类技能）的三个要点：</p>
<ol>
<li>拼图理论</li>
<li>成就感</li>
<li>重复训练</li>
</ol>
<p><strong>拼图理论</strong>是指我们需要把学习的过程，比如学习编程当成拼图，而不是登山，如果像登山那样可能大部分人都只能做到从入门到放弃了。<br>学习过程应该像拼图一样，先拼好边界，然后慢慢一点点把图画拼起来，同时把学习当成拼图，从心理上来说，我们肯定觉得没有登山累吧；<br>拼好一个作品后，自然就该到下一个环节了，对，就是要收获<strong>成就感</strong>。</p>
<p><strong>成就感</strong> 如何获得成就感呢？想想我们一般完成一件我们自己觉得不得了的事情（或者自己没有想到过自己能做到事情，这种情况其实完成我们就会有成就感了）会怎么做吧。<br>告诉好朋友，然后好朋友再一番赞赏，这成就感杠杠滴，动力瞬间就有了，有木有。学习最好的情况就是要形成这样一种良性循环。</p>
<p><strong>重复训练</strong>为啥要重复训练呢，其实大家可能都知道一万小时定律吧，就是说一个人要想成为某个领域的专家，都是需要一万个小时积累的。<br>其中就包含大量的重复训练。当然这个理论我觉得大多数场景都是适用。</p>
<blockquote>
<p>一万小时定律:作家格拉德威尔在《异类》一书中指出：人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。1万小时的锤炼是任何人从平凡变成超凡的必要条件。<br>他将此称为“一万小时定律”。要成为某个领域的专家，需要10000小时，按比例计算就是：如果每天工作八个小时，一周工作五天，那么成为一个领域的专家至少需要五年。</p>
</blockquote>
<p>另外值得一提的这个重复训练，我个人认为是<strong>刻意训练，而不简单的机械性的重复训练。</strong><br>这里举个栗子，泰格伍兹打高尔夫球这么厉害，他的秘诀在哪呢？有人观察发现，他挥杆的动作都是刻意训练的。<br>什么意思呢？就是说他每一次挥杆都是刻意的，不是自动完全的，因此他完全可以做到在挥杆的过程中停下。<br>这样说可能大家觉得很容易，其实那些熟练的高尔夫球运动员，他们练熟练之后，挥杆是自动的，不刻意的，整个过程一气呵成，根本停不下来！<br>我想这样说大家应该明白其中的差别了。其实我们很多事情做熟练了之后也会进入那种状态，就是感觉不用动脑的状态。这种状态好不好呢，当然要看做什么，<br>如果是某项技能达到这种状态，我们不刻意练习，估计进步的可能性就很小了。</p>
<hr>
<h3 id="如何学习编程"><a href="#如何学习编程" class="headerlink" title="如何学习编程"></a>如何学习编程</h3><p>对于0基础的初学者来说，可以记住一个简单公式</p>
<ol>
<li>搞清楚输入是什么</li>
<li>搞清楚输出是什么</li>
<li>想办法让这个事情可以重复，过程中自然会想到要是遇到A，会怎么怎么做；遇到B，要怎么怎么做</li>
</ol>
<p><strong>联系前面说的如何学习，那么学习编程刚开始其实就需要我们快速把一个小作品像拼图一样拼出来，然后去收获成就感;<br>然后不断去重复上面所说的三个过程，形成良性循环</strong></p>
<hr>
<h3 id="个人教训"><a href="#个人教训" class="headerlink" title="个人教训"></a>个人教训</h3><p>之所以参加元知识课程，我主要就是想学习学习再学习。然后呢关于编程，其实我还是走了很多弯路，现在依然是个初级程序猿。<br>其实当时我也看了很多教材或者教程，但是有个问题，我很懒，以为看懂了就懂了，然后代码也不去敲。<br>就用这样子的方法去学了好几门编程语言，然而到现在才发现自己能比较熟练掌握的就一门自己经常用的。<br>原因何在？其实就是我没有去实践，看懂了就认为自己懂了，这其实离会编程还有非常远的距离，只有你亲自去敲了，遇到错误了，<br>然后把这些错误解决了，你才会知道哪些地方容易出错，哪里有坑。<br>所以，结合上面元课程中提到的方法，我再补充两点或者是换种说法:</p>
<ul>
<li><strong>一定要多实践，就像网上有人说的，看百遍千遍，不如自己手敲一遍</strong></li>
<li><strong>学到的东西尽量用到具体的项目中，哪怕是个很小的项目，要不然真的很快就忘了</strong></li>
</ul>
<p>真的是<strong>知易行难</strong>啊！</p>
<hr>
<h3 id="关于拖延症"><a href="#关于拖延症" class="headerlink" title="关于拖延症"></a>关于拖延症</h3><p>我也是一个拖延症重症患者啊，据说拖延症大多要么是因为害怕失败，或者是过于追求完美。其实我自己，就是想太多，总是想把一切都计划好，等计划好之后，<br>执行力没上去，然后没按计划执行，很打击信心，所以形成恶性循环，然后就变成重度拖延症患者了。<br>其实最关键的是要开始去做，on the way的状态就好。不要成天空想，不要想着天天玩着，突然醒来一天，自己就变成行业大牛了；但同时呢，自己行动的每一步也<br>别给自己太大压力，就当是玩玩啦。编程其实还是很酷很好玩哒，不信，不信试试啊O(∩_∩)O~</p>
<hr>
]]></content>
      <categories>
        <category>闲谈杂聊</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>初识分布式存储</title>
    <url>/2016/12/27/%E5%88%9D%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>分布式领域的知识理论非常庞大，涉及的知识面也非常广博，比如涉及到计算、存储、网络，甚至数据库理论、大数据处理等知识理论。由于笔者的浅陋，以目前水平确实无法做到面面俱到，所以本文选取了笔者相对熟悉的存储领域进行简要介绍。主要内容有：</p>
<ol>
<li>分布式存储产生的背景</li>
<li>分布式存储概念</li>
<li>分布式存储面临的问题或挑战</li>
<li>常见概念理论介绍</li>
<li>个人参与项目的感受</li>
</ol>
<hr>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当今社会是信息时代，互联网时代，同时也是信息数据大爆炸的时代，每天都会产生大量的数据，真的可谓是<strong>海量数据</strong>。那么这么多数据如何存储呢，很显然，原来的单机存储肯定已经无法存储需求了。举个栗子，比如我们上学那会，相信很多人都有过下载高清电影的经历吧，有的一部高清电影可能就上百G，当时我们大部分的电脑硬盘一般可能就500G，根本存不了几部高清电影。还有就是传统的网络存储采用集中的存储服务器来存放所有的数据，存储服务器本身很容易成为整个系统性能的瓶颈，也是可靠性和安全性的焦点，所以也越来越不能满足当今的大型应用的数据存储需求了。正因如此，分布式存储可谓应运而生。</p>
<h3 id="分布式存储概念"><a href="#分布式存储概念" class="headerlink" title="分布式存储概念"></a>分布式存储概念</h3><p>分布式存储系统，是将数据分散存储到多台独立的设备上，将大量的这些设备通过网络互联，对外作为一个整体提供存储服务，更多的时候，我们可以把分布式存储看作一种服务，一种面向各种不同数据存储需求的服务。<br>分布式存储面临的数据需求多种多样，大致可以分为三类：</p>
<ul>
<li>非结构化数据：包括所有形式的办公文档、文本、图片、图像、音频和视频信息等</li>
<li>结构化数据：一般存储在关系数据库中</li>
<li>半结构化数据：介于非结构化数据与结构化数据之间，如HTML文档就属于半结构化的数据</li>
</ul>
<h3 id="分布式存储面临的问题或挑战"><a href="#分布式存储面临的问题或挑战" class="headerlink" title="分布式存储面临的问题或挑战"></a>分布式存储面临的问题或挑战</h3><p>关于存储系统，我们一般关注如下几个方面：</p>
<ul>
<li>数据分布或负载均衡</li>
<li>数据存储的可靠性与一致性</li>
<li>数据访问的性能</li>
<li>系统容错能力</li>
<li>系统扩展性能</li>
</ul>
<p>分布式存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，这样不但提高了系统的可靠性可用性，还易于扩展。当然，随之带来了一些问题涉及数据分布、数据复制、一致性、容错等。<br>分布式存储中面临的第一个问题就是数据分布，即将数据均匀地分布到多个存储节点。另外，为了保证可靠性和可用性，通常需要将数据复制多个副本，这就带来了多个副本之间的数据一致性问题。<br>此外，分布式存储系统中的服务器故障率很高，要求系统能够在软件层面实现自动容错。比如当存储节点出现故障时，系统能够自动检测出来，并将原有的数据和服务迁移到集群中其他正常工作的节点。</p>
<h3 id="常见概念理论介绍"><a href="#常见概念理论介绍" class="headerlink" title="常见概念理论介绍"></a>常见概念理论介绍</h3><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>这一点应该很好理解，这里不深入讨论Amazon AWS、微软Azure、阿里云、华为存储等宣称的可靠性达到几个9是如何计算出来的（比如，宣称可靠性达到99.999%）。想必大家都写过毕业论文，假如你只在自己的笔记本电脑里面存一份这个论文，要是你运气不好，笔记本被偷了或者硬盘坏了，那么你的毕业论文也就丢了。所以我们通常都知道重要的东西只存一份是不安全的，不可靠的。当年笔者都是电脑里面存一份，U盘存一份，XX云上再存一份，这样是不是安全可靠多了 \^_^</p>
<h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>副本（replica/copy）是指分布式系统中为数据或服务提供冗余的服务。如果把我上面的论文分三份存三个地方看作一个整体的服务的话，那么我们可以简单的把这种形式看作是三副本。这样好处是，比如U盘丢了，其他两个地方还有论文，其实对整个服务而言，影响不大。在分布式存储系统也是如此，通常比较常见的是三副本，当三份数据中丢了一份，如果需要读数据还可以从其他两份那读。如果是作为服务的节点，三个节点，一个节点坏了，还有两个节点可以继续提供服务。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>三副本确实让数据更安全可靠，不过与此同时会带来一致性问题。比如三份论文内容均有不一致的地方需要如何处理。分布式系统为了提高可靠性，经常会采用多副本机制，从而引发副本一致性问题。根据具体的业务需求，分布式系统总是会提供某一种一致性模型，并基于此模型提供具体服务。（本文只对一致性概念做介绍，不深入讨论。）比如，我们要解决上面“三份论文一致性”的好办法是，当我们改了一处的论文，必须保证更新其他两处的论文，也就是在修改完一个地方的论文的时候，都要保证其他两处的论文得到同样的更新，保证三份论文一样。</p>
<h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p>
<p><strong>简单阐述CAP理论，就是一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</strong></p>
<p><strong>Consistency 一致性</strong></p>
<p>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p>
<p><strong>Availability 可用性</strong></p>
<p>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</p>
<p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。</p>
<p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。</p>
<p><strong>Partition Tolerance分区容错性</strong></p>
<p>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p>
<p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔为独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p>
<h4 id="Quorum机制"><a href="#Quorum机制" class="headerlink" title="Quorum机制"></a>Quorum机制</h4><p>从小学的<strong>抽屉原理</strong>说起，为什么从抽屉原理说起？一来大家对这个比较熟悉，二来它与Quorum机制有异曲同工的地方。回顾抽屉原理，2个抽屉每个抽屉最多容纳2个苹果，现在有3个苹果无论怎么放，其中的一个抽屉里面会有2个苹果。那么我们把抽屉原理变变型，2个抽屉一个放了2个红苹果，另一个放了2个青苹果，我们取出3个苹果，无论怎么取至少有1个是红苹果，这个理解起来也很简单。我们把红苹果看成更新了的有效数据，青苹果看成未更新的无效数据。便可以看出来，不需要更新全部数据（并非全部是红苹果）我们就可以得到有效数据，当然我们需要读取多个副本完成（取出多个苹果）。这其实就是Quorum机制的一种特殊情况，其实质是将Write All 的负载均衡到 Read Only 上。上面的解决“三份论文一致性”的方法，其实就是Read Only Write All，就是更新的时候全部更新，读的时候就只用读一份数据了。由于本文属于简介性质，所以关于QUORUM机制本文也不做过多介绍，有兴趣的可以去查相关资料。</p>
<h4 id="EC模式"><a href="#EC模式" class="headerlink" title="EC模式"></a>EC模式</h4><p>三副本确实很不错，能解决很多问题，但是大家有没有发现这样有个什么问题？那就是什么东西都要存三份，这存储效率不高呀，空间利用率不高，这对于使用存储设备的厂商来说存储的成本会变得很高，简单的说，1T的数据，你需要3个1T的移动硬盘来存储。那有没有什么好的其他方案呢？答案是有的，很多存储厂商，为了提高自身产品的竞争力，除了提供三副本的方式外，还提供了EC的方式。EC，全称Erasure Code.<br>为了阐述简单，本文只举4+2这种模式的EC算法进行示意说明，并不阐述具体的算法或其变种算法。感兴趣的可以看下这篇文章的介绍<br><a href="http://blog.csdn.net/u011026968/article/details/52295666">分布式系统下的纠删码技术</a>。<br><img src="http://ww4.sinaimg.cn/mw690/71c65545jw1fb6z22ykkaj20tq0c4dg7.jpg" alt="EC 4+ 2"><br>简单来说，4+2这种模式的EC算法就是原始数据切分成4块,图中D1、D2、D3、D4，然后利用EC算法，计算出2块校验数据P1、P2，总共6块数据。至于怎么算出来的咱不管，就当做解方程组。通过这种方法能够保证你在丢失至多2块（6块数据丢2块）数据的情况下，都是能够恢复出来的（可以看作能够通过解方程的形式解出来\^_\^)。当然要是丢了2块以上的数据就没办法恢复了。比如D3和D4丢了，可以通过剩下的4块数据将D3和D4算出来。</p>
<p>可以看到4+2的模式，比三副本的模式的存储效率提高了，能够降低存储成本，同时也能保证一定的可靠性和容错性。当然，也可以把EC算法看成是以CPU计算来换取存储效率的提高，因为采用EC模式，在丢了原始数据的情况下是需要CPU进行计算来恢复出原始数据的。</p>
<h3 id="个人参与项目的感受"><a href="#个人参与项目的感受" class="headerlink" title="个人参与项目的感受"></a>个人参与项目的感受</h3><p><strong>团队沟通协作</strong></p>
<p>一个项目往往都是团队协作共同努力完成的，所以沟通能力很重要，需要不断加强。</p>
<p><strong>代码编写感受</strong></p>
<p>产品正常逻辑的代码可能只占项目代码的1/3，大部分代码都是异常处理。只考虑正常情况情况的话，代码写起来是简单，然而写出来的代码很可能不可用，而且分布式系统中本来就会遇到千奇百怪的异常情况。所以写代码一定要注意考虑清楚异常情况。</p>
<hr>
<p>最后以一个段子结束本文\^_^<br><img src="http://ww1.sinaimg.cn/mw690/71c65545jw1fb6zed0v7zj20zk0k0abd.jpg" alt=""></p>
<hr>
<h3 id="可供参考阅读的资料"><a href="#可供参考阅读的资料" class="headerlink" title="可供参考阅读的资料"></a>可供参考阅读的资料</h3><p><a href="http://blog.jobbole.com/84575/">分布式系统阅读清单</a></p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构概念及算法优劣评价</title>
    <url>/2017/11/01/%E9%87%8D%E6%B8%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/</url>
    <content><![CDATA[<p>本篇文章是重温数据结构系列的第一篇，也是对自己复习的记录，简单介绍下数据结构、算法等概念及如何判断算法的优劣，并用最大子列和问题作为例子，展示了各种不同时间复杂度的实例。</p>
<hr>
<h3 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h3><p>查阅资料会发现，关于数据结构的描述很多，比如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。</span><br><span class="line">                                            ----Sartaj Sahni，《数据结构、算法与应用》</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据结构是ADT（抽象数据类型Abstract Data Type）的物理实现。</span><br><span class="line">                                        ----Clifford A.Shaffer，《数据结构与算法分析》</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据结构（data structure）是计算机存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最有效率的算法。</span><br><span class="line">                                         -----中文维基百科</span><br></pre></td></tr></table></figure>
<p>通过多种描述，可以发现：</p>
<ul>
<li>数据结构没有官方统一的定义</li>
<li>数据结构和算法联系密切</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决问题方法的效率，跟数据的组织方式有关</span><br><span class="line">解决问题方法的效率，跟空间的利用效率有关</span><br><span class="line">解决问题方法的效率，跟算法的巧妙程度有关</span><br></pre></td></tr></table></figure>
<h3 id="到底什么是数据结构？？"><a href="#到底什么是数据结构？？" class="headerlink" title="到底什么是数据结构？？"></a>到底什么是数据结构？？</h3><ul>
<li><p>数据对象在计算机中的组织方式</p>
<p>□ 逻辑结构</p>
<p>□ 物理存储结构</p>
</li>
<li><p>数据对象必定与一系列加在其上的操作相关联</p>
</li>
<li>完成这些操作所用的方法就是算法</li>
</ul>
<h3 id="抽象数据类型（Abstract-Data-Type）"><a href="#抽象数据类型（Abstract-Data-Type）" class="headerlink" title="抽象数据类型（Abstract Data Type）"></a>抽象数据类型（Abstract Data Type）</h3><ul>
<li><p>数据类型</p>
<p>□ 数据对象集</p>
<p>□ 数据集合相关联的操作集</p>
</li>
<li><p>抽象：描述数据类型的方法不依赖与具体实现</p>
<p>□ 与存放数据的机器无关</p>
<p>□ 与数据存储的物理结构无关</p>
<p>□ 与实现操作的算法和编程语言均无关</p>
<p>只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题</p>
</li>
</ul>
<h3 id="算法（Algorithm）的描述"><a href="#算法（Algorithm）的描述" class="headerlink" title="算法（Algorithm）的描述"></a>算法（Algorithm）的描述</h3><ul>
<li>一个有限指令集</li>
<li>接受一些输入（有些情况下不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤之后终止</li>
<li><p>每一条指令必须</p>
<pre><code>（1） 有充分明确的目标，不可以有歧义

（2） 计算机能处理的范围之内

（3） 描述应不依赖于任何一种计算机语言以及具体的实现手段
</code></pre></li>
</ul>
<h3 id="如何判断算法的优劣"><a href="#如何判断算法的优劣" class="headerlink" title="如何判断算法的优劣"></a>如何判断算法的优劣</h3><ul>
<li><p>空间复杂度S(n) —— 根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的<br>规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</p>
</li>
<li><p>时间复杂度T(n) —— 根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规<br>模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。</p>
</li>
</ul>
<p>在分析一般算法的效率时，我们经常关注下面两种复杂度</p>
<ul>
<li>最坏情况复杂度<br>Tworst( n )</li>
<li>平均复杂度<br>Tavg( n )</li>
</ul>
<p>例如，在一个长度为 n 的列表中顺序搜索指定的值，则</p>
<p>最坏情况：n 次比较</p>
<p>平均情况：n/2 次比较</p>
<p>最佳情况：1 次比较</p>
<p>而实际中，我们一般仅考量算法在最坏情况下的运行情况，也就是对于规模为 n 的任何输入，算法的最长运行时间。这样做的理由是：</p>
<p>（１）一个算法的最坏情况运行时间是在任何输入下运行时间的一个上界（Upper Bound）。</p>
<p>（２）对于某些算法，最坏情况出现的较为频繁。</p>
<p>（３）大体上看，平均情况通常与最坏情况一样差。</p>
<p>算法分析要保持大局观（Big Idea），其基本思路：</p>
<ul>
<li>忽略掉那些依赖于机器的常量</li>
<li>关注运行时间的增长趋势</li>
</ul>
<h5 id="常见的算法时间复杂度由小到大依次为：Ο-1-＜Ο-log2n-＜Ο-n-＜Ο-nlog2n-＜Ο-n2-＜Ο-n3-＜…＜Ο-2-n-＜Ο-n"><a href="#常见的算法时间复杂度由小到大依次为：Ο-1-＜Ο-log2n-＜Ο-n-＜Ο-nlog2n-＜Ο-n2-＜Ο-n3-＜…＜Ο-2-n-＜Ο-n" class="headerlink" title="常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n )＜Ο(n!)"></a>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n )＜Ο(n!)</h5><h3 id="具体实例（最大子列和问题）"><a href="#具体实例（最大子列和问题）" class="headerlink" title="具体实例（最大子列和问题）"></a>具体实例（最大子列和问题）</h3><p>给定K个整数组成的序列{ N1, N2, …, NK }，“连续子列”被定义为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p>
<ul>
<li>算法一（最直接的暴力办法）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_subsequence_sum</span><span class="params">(<span class="type">int</span> <span class="built_in">list</span>[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter a num\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = max_subsequence_sum(<span class="built_in">array</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_subsequence_sum</span><span class="params">(<span class="type">int</span> <span class="built_in">list</span>[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> this_sum, max_sum, i, j, k;</span><br><span class="line">    max_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            this_sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(k = i; k&lt;= j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                this_sum += <span class="built_in">list</span>[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(this_sum &gt; max_sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_sum = this_sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显该方法的时间复杂度为O(n^3)，在数据量稍大的时候这其实是非常耗时的算法，在我们开发设计的过程中最好不要设计出这样时间复杂度的算法。</p>
<ul>
<li>算法二</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_subsequence_sum</span><span class="params">(<span class="type">int</span> <span class="built_in">list</span>[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter a num\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = max_subsequence_sum(<span class="built_in">array</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_subsequence_sum</span><span class="params">(<span class="type">int</span> <span class="built_in">list</span>[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> this_sum, max_sum, i, j, k;</span><br><span class="line">    max_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            this_sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(k = i; k&lt;= j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                this_sum += <span class="built_in">list</span>[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(this_sum &gt; max_sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_sum = this_sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的时间复杂度为O( n^2 ) ,已经比上一个有进步了，还有没有更好的方法了，通常遇到n^2 的算法需要多想想优化方案，看能不能优化为O( nlog^n )的算法。</p>
<hr>
<ul>
<li>算法三（分而治之）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_subsequence_sum</span><span class="params">(<span class="type">int</span> <span class="built_in">list</span>[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//printf(&quot;please enter a num:\n&quot;);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = max_subsequence_sum(<span class="built_in">array</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">max3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    max = a&gt;b?a:b;</span><br><span class="line">    max = max&gt;c?max:c;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">max_sub_sum</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max_left_sum, max_right_sum;</span><br><span class="line">    <span class="type">int</span> max_left_border_sum, max_right_border_sum;</span><br><span class="line">    <span class="type">int</span> left_border_sum, right_border_sum;</span><br><span class="line">    <span class="type">int</span> center, i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left == right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[left] &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> A[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    center = (left + right) / <span class="number">2</span>;</span><br><span class="line">    max_left_sum = max_sub_sum(A, left, center);</span><br><span class="line">    max_right_sum = max_sub_sum(A, center+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    max_left_border_sum = <span class="number">0</span>;</span><br><span class="line">    left_border_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = center; i &gt;=  left; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        left_border_sum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(left_border_sum &gt; max_left_border_sum)</span><br><span class="line">        &#123;</span><br><span class="line">            max_left_border_sum = left_border_sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max_right_border_sum = <span class="number">0</span>;</span><br><span class="line">    right_border_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = center + <span class="number">1</span>; i &lt;= right; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        right_border_sum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(right_border_sum &gt; max_right_border_sum)</span><br><span class="line">        &#123;</span><br><span class="line">            max_right_border_sum = right_border_sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max3(max_left_sum, max_right_sum, max_left_border_sum + max_right_border_sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_subsequence_sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> max_sub_sum(A, <span class="number">0</span>, N<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该算法的时间复杂度为O( nlog^n ),其实已经很棒了，那么还有没有比该算法还更优的算法呢，如果没有比该比该算法更优的算法的话，该算法就会是提现递归威力的极好的范例了。然而，还真有更优的算法，见算法四</p>
<ul>
<li>算法四（在线处理算法）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_subsequence_sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//printf(&quot;please enter a num:\n&quot;);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = max_subsequence_sum(<span class="built_in">array</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_subsequence_sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, this_sum, max_sum;</span><br><span class="line">    max_sum = <span class="number">0</span>;</span><br><span class="line">    this_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        this_sum += A[i];</span><br><span class="line">        <span class="keyword">if</span>(this_sum &gt; max_sum)</span><br><span class="line">        &#123;</span><br><span class="line">            max_sum = this_sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(this_sum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            this_sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该算法对每个输入的数据只处理一遍，时间复杂度为O(n),真是棒极了！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[浙江大学数据结构公开课]</p>
<p>《数据结构与算法分析–C语言描述》</p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Maximum Subsequence Sum</title>
    <url>/2017/11/02/Maximum%20Subsequence%20Sum/</url>
    <content><![CDATA[<p>本题为上一篇文章中最大子列和的改进版题目，要求在输出最大子列和的同时输出最大子列的第一个元素和最后一个元素，具体要求见题目。</p>
<hr>
<h3 id="Maximum-Subsequence-Sum"><a href="#Maximum-Subsequence-Sum" class="headerlink" title="Maximum Subsequence Sum"></a>Maximum Subsequence Sum</h3><p>Given a sequence of K integers { N​1, N​2, …, N​K}. A continuous subsequence is defined to be { N​i, Ni+1, …, N​j} where 1≤i≤j≤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.<br>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<h4 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h4><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (≤10000). The second line contains K numbers, separated by a space.</p>
<h4 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h4><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h4><p>10<br>-10 1 2 3 4 -5 -23 3 7 -21</p>
<h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h4><p>10 1 4</p>
<p>时间限制: 200ms<br>内存限制: 64MB<br>代码长度限制: 16KB</p>
<h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><p>题目要求大致就是求出给出数列的最大子列和，同时给出所求子列的第一项和最后一项。对于全为负数的数列，最大子列和为0，并且输出整个数列的第一项和最后一项。需要注意的时候是，最大子列和有多个的时候，输出序号最小的第一个元素和最后一个元素。如题目输出的是10 1 4，而非10 3 7。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">max_subsquence_sum</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    max_subsquence_sum(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">max_subsquence_sum</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, this_sum, max_sum, flag, start1, start, end;</span><br><span class="line">    flag = start1= start= end = <span class="number">0</span>;</span><br><span class="line">    this_sum = max_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a[N];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;<span class="comment">//标记，如果有非负数，flag就置为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        this_sum += a[i];</span><br><span class="line">        <span class="keyword">if</span>(this_sum &gt; max_sum)</span><br><span class="line">        &#123;</span><br><span class="line">            start = start1;</span><br><span class="line">            max_sum = this_sum;</span><br><span class="line">            end = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(this_sum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            this_sum = <span class="number">0</span>;</span><br><span class="line">            start1 = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == max_sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, max_sum, a[<span class="number">0</span>], a[N - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0 0 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, max_sum, a[start], a[end]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, flag = <span class="number">0</span>, max_sum = <span class="number">-1</span>, this_sum = <span class="number">0</span>, first = <span class="number">0</span>, last = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[n];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">array</span>[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        this_sum += <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">if</span>(this_sum &gt; max_sum)</span><br><span class="line">        &#123;</span><br><span class="line">            max_sum = this_sum;</span><br><span class="line">            first = index;</span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(this_sum &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            this_sum = <span class="number">0</span>;</span><br><span class="line">            index = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0 %d %d\n&quot;</span>, <span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, max_sum, <span class="built_in">array</span>[first], <span class="built_in">array</span>[last]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如果该题目不要求输出最小的最大子列和的第一个元素和最后一个元素，反而要求输出最大的最大子列和的第一个元素和最后一个元素呢？</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[浙江大学PTA]</p>
]]></content>
      <categories>
        <category>练习题</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表及其实现</title>
    <url>/2017/11/03/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>本篇回顾数据结构中最常见的数据结构之一 <strong><em>线性表</em></strong>。<br>主要包含如下内容:</p>
<ul>
<li>线性表的描述和特点</li>
<li>线性表的抽象数据类型描述</li>
<li>线性表的顺序存储实现</li>
<li>线性表的链式存储实现</li>
</ul>
<hr>
<h3 id="什么是线性表"><a href="#什么是线性表" class="headerlink" title="什么是线性表"></a>什么是线性表</h3><p><strong>线性表的描述和特点</strong></p>
<p>一种逻辑结构，相同数据类型的n个数据元素的有限序列，除第一个元素外，每个元素有且仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继。</p>
<p>线性表的特点：</p>
<p>（1）元素个数有限    （2）逻辑上元素有先后次序</p>
<p>（3）数据类型相同    （4）仅讨论元素间的逻辑关系</p>
<p><strong><em>注：线性表是逻辑结构，顺序表和链表是存储结构。</em></strong></p>
<p>“线性表(Linear List)”：由同类型 <em>数据元素</em> 构成有序序列的线性结构</p>
<p> 表中元素个数称为线性表的长度</p>
<p> 线性表没有元素时，称为空表</p>
<p> 表起始位置称表头，表结束位置称表尾</p>
<h3 id="线性表的抽象数据类型描述"><a href="#线性表的抽象数据类型描述" class="headerlink" title="线性表的抽象数据类型描述"></a>线性表的抽象数据类型描述</h3><p>类型名称：线性表（List）</p>
<p>数据对象集：线性表是 n (≥0)个元素构成的有序序列( a1, a2, …,an )</p>
<p>操作集：线性表L ∈ List，整数i表示位置，元素X ∈ ElementType，<br>线性表基本操作主要有：</p>
<ol>
<li>List MakeEmpty()：初始化一个空线性表L；</li>
<li>ElementType FindKth( int K, List L )：根据位序K，返回相应元素 ；</li>
<li>int Find( ElementType X, List L )：在线性表L中查找X的第一次出现位置；</li>
<li>void Insert( ElementType X, int i, List L)：在位序i前插入一个新元素X；</li>
<li>void Delete( int i, List L )：删除指定位序i的元素；</li>
<li>int Length( List L )：返回线性表L的长度n。</li>
</ol>
<h3 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h3><p>利用数组的 <strong><em>连续存储空间顺序存放</em></strong> 线性表的各元素 —- 顺序表</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1509735246262&amp;di=90b320d72772378f53c925039f14a1d3&amp;imgtype=0&amp;src=http%3A%2F%2Fimg2.shangxueba.com%2Fimg%2F2cto_kfImg%2F20140605%2F16%2FB50C87A9670554093DAC13D0C0DDF055.png" alt="顺序表"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> Last;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span></span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure>
<p>访问下标为 i 的元素：L.Data[i] 或 PtrL-&gt;Data[i]<br>线性表的长度：L.Last+1 或 PtrL-&gt;Last+1</p>
<h4 id="主要操作的实现"><a href="#主要操作的实现" class="headerlink" title="主要操作的实现"></a>主要操作的实现</h4><ul>
<li>初始化（建立空的顺序表）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">List <span class="title function_">MakeEmpty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List PtrL;</span><br><span class="line">    PtrL = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode))</span><br><span class="line">    PtrL-&gt;Last = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PtrL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(ElementType X, List PtrL)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i] != X)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt; PtrL-&gt;Last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果没有找到，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">//找到后返回存储的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入（第 i (1≤i≤n+1)个位置上插入一个值为X的新元素)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">( ElementType X, <span class="type">int</span> i, List PtrL)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> ( PtrL-&gt;Last == MAXSIZE<span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(＂表满＂);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(＂位置不合法＂);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(j = PtrL-&gt;Last; j &gt; i<span class="number">-1</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将 ai～ an倒序向后移动</span></span><br><span class="line">        PtrL-&gt;Data[j+<span class="number">1</span>] = PtrL-&gt;Data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    PtrL-&gt;Data[i<span class="number">-1</span>] = X; <span class="comment">//新元素插入</span></span><br><span class="line">    PtrL-&gt;Last++; <span class="comment">//Last仍指向最后元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除（删除表的第 i (1≤i≤n)个位置上的元素)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">( <span class="type">int</span> i, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">1</span> )</span><br><span class="line">    &#123; <span class="comment">/*检查空表及删除位置的合法性*/</span></span><br><span class="line">        <span class="built_in">printf</span> (“不存在第%d个元素”, i );</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( j = i; j &lt;= PtrL-&gt;Last; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        PtrL-&gt;Data[j<span class="number">-1</span>] = PtrL-&gt;Data[j]; <span class="comment">/*将 ai+1～ an顺序向前移动*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    PtrL-&gt;Last--; <span class="comment">/*Last仍指向最后元素*/</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线性表的链式存储实现"><a href="#线性表的链式存储实现" class="headerlink" title="线性表的链式存储实现"></a>线性表的链式存储实现</h3><p><strong><em>不要求逻辑上相邻的两个元素物理上也相邻；</em></strong> 通过“链”建立起数据元素之间的逻辑关系。</p>
<p>• 插入、删除不需要移动数据元素，只需要修改“链”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> <span class="title">L</span>;</span></span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure>
<h4 id="主要操作的实现-1"><a href="#主要操作的实现-1" class="headerlink" title="主要操作的实现"></a>主要操作的实现</h4><ul>
<li><p>求表长</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span> <span class="params">( List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">    List p = PtrL;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( p )</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找<br>按序号查找: FindKth;</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">List <span class="title function_">FindKth</span><span class="params">( <span class="type">int</span> K, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">    List p = PtrL;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p !=<span class="literal">NULL</span> &amp;&amp; i &lt; K )</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( i == K ) </span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       <span class="comment">/* 否则返回空 */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>按值查找: Find<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">List <span class="title function_">Find</span><span class="params">( ElementType X, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">    List p = PtrL;</span><br><span class="line">    <span class="keyword">while</span> ( p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;Data != X )</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>插入（在第 i-1(1≤i≤n+1)个结点后插入一个值为X的新结点)</p>
<p>（1）先构造一个新结点，用s指向；</p>
<p>（2）再找到链表的第 i-1个结点，用p指向；</p>
<p>（3）然后修改指针，插入结点 ( p之后插入新结点是 s)</p>
</li>
</ul>
<ul>
<li>插入操作实现<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">List <span class="title function_">Insert</span><span class="params">( ElementType X, <span class="type">int</span> i, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">    List p, s;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">1</span> )</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">/* 新结点插入在表头 */</span></span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">/*申请、填装结点*/</span></span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = PtrL;</span><br><span class="line">        <span class="keyword">return</span> s; <span class="comment">/*返回新表头指针*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth( i<span class="number">-1</span>, PtrL ); <span class="comment">/* 查找第i-1个结点 */</span></span><br><span class="line">    <span class="keyword">if</span> ( p == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 第i-1个不存在，不能插入 */</span></span><br><span class="line">        <span class="built_in">printf</span>(＂参数i错＂);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode)); <span class="comment">/*申请、填装结点*/</span></span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next; <span class="comment">/*新结点插入在第i-1个结点的后面*/</span></span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除（删除链表的第 i (1≤i≤n)个位置上的结点)</p>
<p>（1）先找到链表的第 i-1个结点，用p指向；</p>
<p>（2）再用指针s指向要被删除的结点（p的下一个结点）;</p>
<p>（3）然后修改指针，删除s所指结点;</p>
<p>（4）最后释放s所指结点的空间。</p>
</li>
<li><p>删除操作实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">List <span class="title function_">Delete</span><span class="params">( <span class="type">int</span> i, List PtrL )</span></span><br><span class="line">&#123;</span><br><span class="line">    List p, s;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 若要删除的是表的第一个结点 */</span></span><br><span class="line">        s = PtrL; <span class="comment">/*s指向第1个结点*/</span></span><br><span class="line">        <span class="keyword">if</span> (PtrL!=<span class="literal">NULL</span>)</span><br><span class="line">            PtrL = PtrL-&gt;Next; <span class="comment">/*从链表中删除*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(s); <span class="comment">/*释放被删除结点 */</span></span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth( i<span class="number">-1</span>, PtrL ); <span class="comment">/*查找第i-1个结点*/</span></span><br><span class="line">    <span class="keyword">if</span> ( p == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“第%d个结点不存在”, i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( p-&gt;Next == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“第%d个结点不存在”, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = p-&gt;Next; <span class="comment">/*s指向第i个结点*/</span></span><br><span class="line">        p-&gt;Next = s-&gt;Next; <span class="comment">/*从链表中删除*/</span></span><br><span class="line">        <span class="built_in">free</span>(s); <span class="comment">/*释放被删除结点 */</span></span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[浙江大学PTA]</p>
<p>[浙江大学数据结构公开课]</p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的缩进错误:unindent does not match any outer indentation level</title>
    <url>/2016/12/13/IndentationError%20unindent%20does%20not%20match%20any%20outer%20indentation%20level/</url>
    <content><![CDATA[<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>Python程序运行出现语法错误：IndentationError: unindent does not match any outer indentation level</p>
<p>运行环境是win7 x64 sublime text2，</p>
<p>这个错误最开始以为是缩进问题，看了很久，最后发现其实是由于有的地方使用了4个空格，有的地方使用了tab键。</p>
<p>代码区直接全选就会看到<strong>有的地方是四个点有个地方是一个横线</strong>，改一致了就好了</p>
<p>因此，以后在<strong>使用tab键和空格键的时候需要注意统一</strong></p>
<hr>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2017/11/04/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>前一篇文章<a href="https://ahnselina.github.io/%E7%BA%BF%E6%80%A7%E8%A1%A8/">《线性表及其实现》</a>介绍了线性表的顺序存储实现和链式存储实现。本文继续介绍线性表，主要介绍线性表的链式存储结构之一的单链表。<br>主要包含如下内容:</p>
<ul>
<li>单链表</li>
<li>单链表的C语言实现</li>
<li>练习题：两个有序链表序列的合并</li>
</ul>
<hr>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>前一篇文章<a href="https://ahnselina.github.io/%E7%BA%BF%E6%80%A7%E8%A1%A8/">《线性表及其实现》</a>里面介绍的线性表的链式存储实现，采用的其实不带头结点的单链表。需要注意带头结点的链表和不带头结点的单链表之间的一些区别。<br>可以通过本文的练习题目来体会二者区别。<br>（提示：该题目中的链表是带头结点的）</p>
<hr>
<h3 id="单链表的C语言实现"><a href="#单链表的C语言实现" class="headerlink" title="单链表的C语言实现"></a>单链表的C语言实现</h3><p>不带头结点的单链表实现参考<a href="https://ahnselina.github.io/%E7%BA%BF%E6%80%A7%E8%A1%A8/">《线性表及其实现》</a></p>
<p>带头结点的具体实现<a href="https://github.com/ahnselina/data-structure/blob/master/list_with_head_node.c">github</a>：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NodeList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NodeList</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化带头结点的单链表 </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(Node **pNode)</span></span><br><span class="line">&#123;</span><br><span class="line">    *pNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == *pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s executed, malloc failed, failed to init List.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*pNode)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s executed succesfully, init List finished.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateList</span><span class="params">(Node *pNode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Node *p = (Node *)malloc(sizeof(Node));//notice if malloc is success</span></span><br><span class="line">    <span class="comment">//p-&gt;next = NULL;</span></span><br><span class="line">    Node *tmp = pNode;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">            newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(newNode-&gt;element));</span><br><span class="line">            tmp-&gt;next = newNode;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node *pNode)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = pNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;element);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n Function %s executed, print list successfully.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(Node *pNode)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = pNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        pNode-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = pNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function %s executed, clear list successfully.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SizeList</span><span class="params">(Node *pNode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    Node *p = pNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function %s executed, list size is %d.\n&quot;</span>, __FUNCTION__, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回单链表中第pos个结点中的元素，若返回-1，表示没有找到</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindElement</span><span class="params">(Node *pNode, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Node *p = pNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Funtion %s executed，the value in pos=%d is %d\n&quot;</span>, __FUNCTION__, pos, p-&gt;element);</span><br><span class="line">            <span class="keyword">return</span> p-&gt;element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Funtion %s executed，the value in pos=%d is not found.\n&quot;</span>, __FUNCTION__, pos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">ModifyElem</span><span class="params">(Node *pNode, <span class="type">int</span> pos, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Node *p = pNode-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == i)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;element = x;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Function %s executed, now the value pos=%d is %d.\n&quot;</span>, __FUNCTION__, pos, x);</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function %s executed failed, maybe the list is NULL or the pos is invalid.\n&quot;</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表头插入一个节点</span></span><br><span class="line">Node *<span class="title function_">InsertHead</span><span class="params">(Node *pNode, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;element = x;</span><br><span class="line">    p-&gt;next = pNode-&gt;next;</span><br><span class="line">    pNode-&gt;next = p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function %s executed, insert %d in head successfully.\n&quot;</span>, __FUNCTION__, x);</span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表尾插入一个节点</span></span><br><span class="line">Node *<span class="title function_">InsertTail</span><span class="params">(Node *pNode, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p = pNode-&gt;next;</span><br><span class="line">    Node *pInsert = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    pInsert-&gt;element = x;</span><br><span class="line">    pInsert-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) <span class="comment">//思考这里为啥不是p != NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;next = pInsert;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function %s executed, insert %d in tail successfully.\n&quot;</span>, __FUNCTION__, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *pList;</span><br><span class="line">    InitList(&amp;pList);</span><br><span class="line"></span><br><span class="line">    CreateList(pList);</span><br><span class="line"></span><br><span class="line">    PrintList(pList);</span><br><span class="line"></span><br><span class="line">    SizeList(pList);</span><br><span class="line"></span><br><span class="line">    FindElement(pList, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ModifyElem(pList, <span class="number">2</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    PrintList(pList);</span><br><span class="line"></span><br><span class="line">    InsertHead(pList, <span class="number">2333</span>);</span><br><span class="line">    PrintList(pList);</span><br><span class="line">    SizeList(pList);</span><br><span class="line"></span><br><span class="line">    InsertTail(pList, <span class="number">8888</span>);</span><br><span class="line">    PrintList(pList);</span><br><span class="line">    SizeList(pList);</span><br><span class="line"></span><br><span class="line">    ClearList(pList);</span><br><span class="line">    PrintList(pList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="两个有序链表序列的合并"><a href="#两个有序链表序列的合并" class="headerlink" title="两个有序链表序列的合并"></a>两个有序链表序列的合并</h3><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。<br>函数接口定义：</p>
<p>List Merge( List L1, List L2 );</p>
<p>其中List结构定义如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 存储结点数据 */</span></span><br><span class="line">    PtrToNode   Next; <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>typedef PtrToNode List; /<em> 定义单链表类型 </em>/</p>
<p><strong><em>L1和L2是给定的带头结点的单链表</em></strong>，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的链表头指针。</p>
<h4 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line">List <span class="title function_">Read</span><span class="params">()</span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">( List L )</span>; <span class="comment">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class="line"></span><br><span class="line">List <span class="title function_">Merge</span><span class="params">( List L1, List L2 )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = Read();</span><br><span class="line">    L2 = Read();</span><br><span class="line">    L = Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><p>3<br>1 3 5<br>5<br>2 4 6 8 10</p>
<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><p>1 2 3 4 5 6 8 10<br>NULL<br>NULL</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line">List <span class="title function_">Read</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(List)</span>;</span><br><span class="line"></span><br><span class="line">List <span class="title function_">Merge</span><span class="params">(List L1, List L2)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = Read();</span><br><span class="line">    L2 = Read();</span><br><span class="line">    L = Merge(L1, L2);</span><br><span class="line">    Print(L);</span><br><span class="line">    Print(L1);</span><br><span class="line">    Print(L2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List <span class="title function_">Read</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    List p = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List tmp = p;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List new_node = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">            new_node-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;(new_node-&gt;Data));</span><br><span class="line">            tmp-&gt;Next = new_node;</span><br><span class="line">            tmp = tmp-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(List L)</span></span><br><span class="line">&#123;</span><br><span class="line">    List p = L-&gt;Next;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;Data);</span><br><span class="line">            p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List <span class="title function_">Merge</span><span class="params">(List L1, List L2)</span></span><br><span class="line">&#123;</span><br><span class="line">    List p1 = L1-&gt;Next;</span><br><span class="line">    List p2 = L2-&gt;Next;</span><br><span class="line">    List p = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List tmp = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1 &amp;&amp; p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;Data &lt; p2-&gt;Data)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;Next = p1;</span><br><span class="line">            tmp = tmp-&gt;Next;</span><br><span class="line">            p1 = p1-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;Next = p2;</span><br><span class="line">            tmp = tmp-&gt;Next;</span><br><span class="line">            p2 = p2-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p1)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;Next = p1;</span><br><span class="line">        tmp = tmp-&gt;Next;</span><br><span class="line">        p1 = p1-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p2)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;Next = p2;</span><br><span class="line">        tmp = tmp-&gt;Next;</span><br><span class="line">        p2 = p2-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L2-&gt;Next =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[浙江大学PTA]</p>
<p>[浙江大学数据结构公开课]</p>
<p><a href="http://blog.csdn.net/chenyufeng1991/article/details/50770891">C语言实现单链表（带头结点）的基本操作</a></p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表之堆栈</title>
    <url>/2017/11/05/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p>本文重温一种常见的线性表—-堆栈。<br>主要包含如下内容:</p>
<ul>
<li>问题引入</li>
<li>堆栈的抽象数据类型描述</li>
<li>堆栈的顺序存储实现</li>
<li>堆栈的链式存储实现</li>
<li>堆栈的应用</li>
</ul>
<blockquote>
<p><strong>注意:虽然我们堆栈堆栈的叫，但是要注意不要混淆堆和栈，从其英文名字Stack可以看出这里的堆栈其实是栈，本文中的堆栈均指的是栈。</strong></p>
</blockquote>
<hr>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p><strong>计算机如何进行表达式求值？</strong><br>例如：算术表达式5+6/2-3 * 4 。<br>正确理解：<br>5+6/2-3*4 = 5+3-3 * 4 = 8-3*4 = 8-12 = -4<br>  由两类对象构成的：<br>  运算数，如2、3、4<br>  运算符号，如+、-、*、/<br>  不同运算符号优先级不一样</p>
<p><strong>中缀表达式</strong> : 运算符号位于两个运算数之间。如 如  ，a + b <em> c - d / e<br><strong>后缀表达式</strong> : 运算符号位于两个运算数之后。如， a b c </em> + d e / -</p>
<p><strong>后缀表达式求值策略</strong>：从左向右“扫描”，逐个处理运算数和运算符号  </p>
<ol>
<li>遇到运算数怎么办？如何“记住”目前还不未参与运算的数？</li>
<li>遇到运算符号怎么办？对应的运算数是什么？</li>
</ol>
<blockquote>
<p><strong>启示</strong>： 要是有种数据结构，能顺序存储运算数，<br>并在需要时“倒序”输出就好了，还真有，那就是堆栈！</p>
</blockquote>
<hr>
<h3 id="堆栈的抽象数据类型描述"><a href="#堆栈的抽象数据类型描述" class="headerlink" title="堆栈的抽象数据类型描述"></a>堆栈的抽象数据类型描述</h3><blockquote>
<p><strong>堆栈(Stack)</strong> ： 具有一定操作约束的线性表<br>  只在一端（栈顶，Top）做<strong>插入、删除</strong>操作  </p>
</blockquote>
<p>  插入数据 ： 入栈（Push ）<br>  删除 数据 ： 出栈（Pop ）<br>  后入先出： ：Last In First Out （LIFO）</p>
<p>类型名称:  堆栈（Stack ）<br>数据对象集： 一个有0 个或多个元素的有穷线性表。<br>操作集： 长度为MaxSize 的堆栈S ∈ Stack ，堆栈元素item ∈ ElementType<br>1 、Stack CreateStack( int MaxSize ) ：  生成空堆栈，其最大长度为MaxSize ；<br>2 、int IsFull( Stack S, int MaxSize ) ：判断堆栈S 是否已满；<br>3 、void Push( Stack S, ElementType item ) ：将元素item 压入堆栈；<br>4 、int IsEmpty ( Stack S ) ：判断堆栈S 是否为空；<br>5 、ElementType Pop( Stack S ) ：删除并返回栈顶元素；  </p>
<p>Push  和 Pop  可以穿插 交替 进行；<br>按照操作系列<br>(1)Push(S,A), Push(S,B),Push((S,C),Pop(S),Pop(S),Pop(S)<br>堆栈输出是？<br>(2)  而Push(S,A), Pop(S),Push(S,B),Push((S,C),Pop(S),Pop(S)<br>堆栈输出是?</p>
<p>答案：（1）CBA （2）ACB</p>
<p><strong>思考</strong>：如果三个字符按ABC顺序压入堆栈<br>• ABC 的所有排列都可能是出栈的序列 吗？<br>• 可以产生CAB这样的序列吗？</p>
<hr>
<h3 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h3><p>栈的顺序存储结构通常由一个<strong>一维数组</strong>和一个记录<strong>栈顶</strong>元素位置的变量组成。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt; 储存数据元素的最大个数&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="type">int</span> Top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>入栈</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack PtrS, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Ptrs-&gt;Top == MaxSize<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is full!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top)] = item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>出栈</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElementType <span class="title function_">Pop</span><span class="params">( Stack PtrS )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( PtrS-&gt;Top == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“ 堆栈空”);</span><br><span class="line">        <span class="keyword">return</span> ERROR; <span class="comment">/* ERROR 是ElementType 的特殊值，标志错误*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (PtrS-&gt;Data[(PtrS-&gt;Top)--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>[练习]</strong><br>请用一个数组实现两个堆栈，要求最大地利用数组空间，使<br>数组只要有空间入栈操作就可以成功。</p>
</blockquote>
<p>【分析】  一种比较聪明的方法是使这两个栈分别从数组的<strong>两头开始向中间生长</strong>；当两个栈的<strong>栈顶指针相遇</strong>时，表示两个栈都满了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt; 存储数据元素的最大个数&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="type">int</span> Top1; <span class="comment">/*  堆栈１的栈顶指针 */</span></span><br><span class="line">    <span class="type">int</span> Top2; <span class="comment">/*  堆栈２的栈顶指针 */</span></span><br><span class="line">&#125; S;</span><br><span class="line">S.Top1 = <span class="number">-1</span>;</span><br><span class="line">S.Top2 = MaxSize;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">( <span class="keyword">struct</span> DStack *PtrS, ElementType item, <span class="type">int</span> Tag )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Tag作为区分两个堆栈的标志，取值为1和2 */</span></span><br><span class="line">    <span class="keyword">if</span> ( PtrS-&gt;Top2 – PtrS-&gt;Top1 == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">/*堆栈满*/</span></span><br><span class="line">        <span class="built_in">printf</span>(“ 堆栈满”); <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( Tag == <span class="number">1</span> ) <span class="comment">/* 对第一个堆栈操作 */</span></span><br><span class="line">        PtrS-&gt;Data[++(PtrS-&gt;Top1)] = item;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 对第二个堆栈操作 */</span></span><br><span class="line">        PtrS-&gt;Data[--(PtrS-&gt;Top2)] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">Pop</span><span class="params">( <span class="keyword">struct</span> DStack *PtrS, <span class="type">int</span> Tag )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Tag作为区分两个堆栈的标志，取值为1和2 */</span></span><br><span class="line">    <span class="keyword">if</span> ( Tag == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 对第一个堆栈操作 */</span></span><br><span class="line">        <span class="keyword">if</span> ( PtrS-&gt;Top1 == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*堆栈1空 */</span></span><br><span class="line">            <span class="built_in">printf</span>(“ 堆栈<span class="number">1</span> 空”); <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top1)--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">/* 对第二个堆栈操作 */</span></span><br><span class="line">        <span class="keyword">if</span> ( PtrS-&gt;Top2 == MaxSize )</span><br><span class="line">        &#123; <span class="comment">/*堆栈2空 */</span></span><br><span class="line">            <span class="built_in">printf</span>(“ 堆栈<span class="number">2</span> 空”);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> PtrS-&gt;Data[(PtrS-&gt;Top2)++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆栈的链式存储实现"><a href="#堆栈的链式存储实现" class="headerlink" title="堆栈的链式存储实现"></a>堆栈的链式存储实现</h3><p>栈的链式存储结构 实际上就是一个<strong>单链表</strong>，叫做<strong>链栈</strong> 。插入和删<br>除操作只能在链栈的栈顶进行。 那栈顶指针Top应该在链表的哪一头呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Stack <span class="title function_">CreateStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  构建一个堆栈的头结点，返回指针 */</span></span><br><span class="line">    Stack S;</span><br><span class="line">    S =(Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 判断堆栈S 是否为空 ， 若为空函数返回整数1 ， 否则返回0 */</span></span><br><span class="line">    <span class="keyword">return</span> ( S-&gt;Next == <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">( ElementType item, Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  将元素item 压入堆栈S */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">TmpCell</span>;</span></span><br><span class="line">    TmpCell= (<span class="keyword">struct</span> SNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> SNode));</span><br><span class="line">    TmpCell-&gt;Element = item;</span><br><span class="line">    TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ElementType <span class="title function_">Pop</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  删除并返回堆栈S 的栈顶元素 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">FirstCell</span>;</span></span><br><span class="line">    ElementType TopElem;</span><br><span class="line">    <span class="keyword">if</span>( IsEmpty( S )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“ 堆栈空”); <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        TopElem = FirstCell -&gt;Element;</span><br><span class="line">        <span class="built_in">free</span>(FirstCell);</span><br><span class="line">        <span class="keyword">return</span> TopElem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆栈的应用"><a href="#堆栈的应用" class="headerlink" title="堆栈的应用"></a>堆栈的应用</h3><h4 id="中缀表达式求值"><a href="#中缀表达式求值" class="headerlink" title="中缀表达式求值"></a>中缀表达式求值</h4><p><strong>基本策略</strong>：将中缀表达式转换为后缀表达式，然后求值<br>如何将中缀表达式转换为后缀？<br><strong>观察一个简单例子： 2+9/3-5 -&gt; 2 9 3 / + 5 -</strong></p>
<ol>
<li>运算数相对顺序不变</li>
<li>运算符号顺序发生改变<br> 需要存储“等待中”的运算符号<br> 要将当前运算符号与“等待中”的最后一个运算符号比较</li>
</ol>
<p><strong>中缀表达式如何转换为后缀表达式</strong></p>
<p>从头到尾读取<strong><em>中缀表达式的每个对象</em></strong> ，对不同对象按不同的情况处理。<br>①  <strong>运算数</strong>：直接输出；<br>②  <strong>左括号</strong>：压入堆栈；<br>③  <strong>右括号</strong>：将<strong>栈顶的运算符弹出</strong>并<strong>输出，直到遇到左括号</strong>（ 出栈，不输出）；<br>④  <strong>运算符</strong>：<br>• 若<strong>优先级大于栈顶运算符</strong>时，则把它压栈；<br>• 若<strong>优先级小于等于栈顶运算符</strong>时，将<strong>栈顶运算符弹出并输出</strong>；再比<br>较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该<strong>运算符压栈</strong>；<br>⑤ 若各对象<strong>处理完毕</strong>，则把堆栈中存留的<strong>运算符一并输出</strong>。</p>
<h4 id="堆栈的其他应用："><a href="#堆栈的其他应用：" class="headerlink" title="堆栈的其他应用："></a>堆栈的其他应用：</h4><p> 函数调用及递归实现<br> 深度优先搜索<br> 回溯算法<br> <strong>…</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[浙江大学PTA]</p>
<p>[浙江大学数据结构公开课]</p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表之队列</title>
    <url>/2017/11/07/%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>本文重温另一种常见的线性表—-队列。<br>主要包含如下内容:</p>
<ul>
<li>什么是队列</li>
<li>队列的抽象数据类型描述</li>
<li>队列的顺序存储实现</li>
<li>队列的链式存储实现</li>
</ul>
<hr>
<h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p><strong>队列(Queue)</strong>：具有一定操作约束的线性表<br><strong>插入和删除操作</strong>：只能在<strong><em>一端插入</em></strong>，而在<strong><em>另一端删除</em></strong>。</p>
<p>  数据插入 ： <strong>入 队列（ （AddQ ）</strong><br>  数据删除 ： <strong>出 队列（ （DeleteQ ）</strong><br>  <strong>先来先服务</strong><br> <strong>先进先出</strong>：FIFO</p>
<h3 id="队列的抽象数据类型描述"><a href="#队列的抽象数据类型描述" class="headerlink" title="队列的抽象数据类型描述"></a>队列的抽象数据类型描述</h3><p><strong>类型名称</strong> ：队列(Queue)<br><strong>数据对象集</strong>： 一个有0 个或多个元素的有穷线性表。<br><strong>操作集</strong> ：长度为MaxSize 的队列Q ∈ Queue ，队列元素item ∈ ElementType<br>1、<strong>Queue CreatQueue( int MaxSize )</strong> ：生成长度为MaxSize 的空队列；<br>2、<strong>int IsFullQ( Queue Q, int MaxSize )</strong> ：判断队列Q 是否已满；<br>3、<strong>void AddQ( Queue Q, ElementType item )</strong> ：  将数据元素item 插入队列Q 中；<br>4、<strong>int IsEmptyQ( Queue Q )</strong> ：  判断队列Q 是否为空；<br>5、<strong>ElementType DeleteQ( Queue Q )</strong> ：将队头数据元素从队列中删除并返回</p>
<h3 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h3><p>队列的顺序存储结构通常由一个<strong>一维数组</strong>和一个记录队列头元<br>素位置的变量<strong>front</strong>以及一个记录队列尾元素位置的变量<strong>rear</strong>组成。</p>
<p><strong>思考当实现为循环队列时</strong>:<br>（1）堆栈空和满的判别条件是什么？<br>（2）为什么会出现空、满无法区分？根本原因？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize <span class="string">&lt; 储存数据元素的最大个数&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[ MaxSize ];</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>入队</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AddQ</span><span class="params">( Queue PtrQ, ElementType item)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (PtrQ-&gt;rear+<span class="number">1</span>) % MaxSize == PtrQ-&gt;front )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“ 队列满”);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PtrQ-&gt;rear = (PtrQ-&gt;rear+<span class="number">1</span>)% MaxSize;</span><br><span class="line">    PtrQ-&gt;Data[PtrQ-&gt;rear] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>出队</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteQ</span> <span class="params">( Queue PtrQ )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == PtrQ-&gt;rear )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“ 队列空”);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PtrQ-&gt;front = (PtrQ-&gt;front+<span class="number">1</span>)% MaxSize;</span><br><span class="line">        <span class="keyword">return</span> PtrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h3><p>队列的链式存储结构也可以用一个<strong>单链表</strong>实现。插入和删除操作分别在链表的两头进行； </p>
<p><strong>思考</strong>：队列指针front和rear应该分别指向链表的哪一头？ </p>
<p>不带头结点的链式队列<strong>出队操作</strong>的一个示例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteQ</span> <span class="params">( Queue PtrQ )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span></span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“ 队列空”); <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    FrontCell = PtrQ-&gt;front;</span><br><span class="line">    <span class="keyword">if</span> ( PtrQ-&gt;front == PtrQ-&gt;rear) <span class="comment">/*  若队列只有一个元素 */</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>; <span class="comment">/*  删除后队列置为空 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next;</span><br><span class="line">    FrontElem = FrontCell-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>( FrontCell ); <span class="comment">/*  释放被删除结点空间 */</span></span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>其他操作带补充</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[浙江大学PTA]</p>
<p>[浙江大学数据结构公开课]</p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Reversing Linked List</title>
    <url>/2017/11/08/%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K = 3, then you must output 3→2→1→6→5→4; if K = 4, you must output 4→3→2→1→5→6.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (&lt;= 105) which is the total number of nodes, and a positive K (&lt;=N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then N lines follow, each describes a node in the format:</p>
<p><strong><em>Address Data Next</em></strong></p>
<p>where Address is the position of the node, Data is an integer, and Next is the position of the next node.</p>
<p><strong>Output Specification:</strong></p>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<p><strong>Sample Input:</strong><br>00100 6 4<br>00000 4 99999<br>00100 1 12309<br>68237 6 -1<br>33218 3 00000<br>99999 5 68237<br>12309 2 33218  </p>
<p><strong>Sample Output:</strong><br>00000 4 33218<br>33218 3 12309<br>12309 2 00100<br>00100 1 99999<br>99999 5 68237<br>68237 6 -1  </p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>第一行：00100 表示第一个节点的位置，即节点： 00100 1 12309 然后根据12309找到第二个节点：12309 2 33218，继续找，直到找到最后一个节点 68237 6 -1。<br>形成的单链表是 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6。 第一行第二个数N=6，代表接下来会输入6个节点，K=4，意思是每4个节点逆转，余下2个节点，不足4个，故不反转。输出 4-&gt;3-&gt;2-&gt;1-&gt;5-&gt;6。</p>
<p>需要注意的是：  </p>
<ol>
<li>如果K=1，链表不反转  </li>
<li>K等于链表的节点数，链表整个反转  </li>
<li>如果链表的节点数能被K整除，则每段都要反转。  </li>
<li>还有就是输出的时候节点的Next是和逆转后的节点相关，不是原先节点的Next,如：输入的时候节点 00000 4 99999 输出的时候应为 00000 4 33218,应为反转后节点4的下一个节点为3，而3的Address是33218。</li>
</ol>
<p>要考虑的细节：K=1不反转，K=L 全反转，L%K == 0, 每段都反转，L%k = (K-1),多余的节点不反转。L&lt;N，有多余节点的情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> nextAddr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tagNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">reverseList</span><span class="params">(Node *head, <span class="type">int</span> k)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node *p)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> startAddr;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> next[MAXSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;startAddr, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node a[n+<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">0</span>].nextAddr = startAddr;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tmp);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;data[tmp], &amp;next[tmp]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == a[i<span class="number">-1</span>].nextAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i<span class="number">-1</span>].next = <span class="literal">NULL</span>;</span><br><span class="line">            num = i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i].addr = a[i<span class="number">-1</span>].nextAddr;</span><br><span class="line">        a[i].data = data[a[i].addr];</span><br><span class="line">        a[i].nextAddr = next[a[i].addr];</span><br><span class="line">        a[i<span class="number">-1</span>].next = a+i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *p = a;</span><br><span class="line">    Node *pr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k &lt;= num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;(num/k); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pr = reverseList(p, k);</span><br><span class="line">            p-&gt;next = pr;</span><br><span class="line">            p-&gt;nextAddr = pr-&gt;addr;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintList(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">reverseList</span><span class="params">(Node *head, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *first = head-&gt;next;</span><br><span class="line">    Node *old = first-&gt;next;</span><br><span class="line">    Node *tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &lt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = old-&gt;next;</span><br><span class="line">        old-&gt;next = first;</span><br><span class="line">        old-&gt;nextAddr = first-&gt;addr;</span><br><span class="line">        first = old;</span><br><span class="line">        old = tmp;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next-&gt;next = old;</span><br><span class="line">    <span class="keyword">if</span>(old)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next-&gt;nextAddr = old-&gt;addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next-&gt;nextAddr = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *pr = p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(pr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == pr-&gt;nextAddr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d -1\n&quot;</span>, pr-&gt;addr, pr-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%05d %d %05d\n&quot;</span>, pr-&gt;addr, pr-&gt;data, pr-&gt;nextAddr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pr = pr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[浙江大学PTA]</p>
<p>[浙江大学数据结构公开课]</p>
]]></content>
      <categories>
        <category>重温数据结构 练习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络设置的常用命令</title>
    <url>/2017/11/22/Linux%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文主要总结配置Linux网络时遇到的问题及解决方法，总结常用的一些命令。通过阅读本文可以解决以下问题：  </p>
<ul>
<li>问题一 设备如果有多个网口，到底哪个连线了呢，用哪个网口呢</li>
<li>问题二 如何为设备配置IP</li>
<li>问题三 配置了IP之后，为何无法用ssh登录呢</li>
<li>问题四 配置IP之后，为何出现ssh登录无法输入密码的情况呢</li>
</ul>
<hr>
<h3 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h3><ul>
<li>ifconfig—-查看网络接口  </li>
</ul>
<blockquote>
<p>输入ifconfig命令，回显如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eth1      Link encap:Ethernet  HWaddr 00:0C:29:33:4A:0C  </span><br><span class="line">          inet addr:192.168.4.115  Bcast:192.168.4.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::20c:29ff:fe33:4a0c/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8133 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:5861 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:818322 (799.1 KiB)  TX bytes:835205 (815.6 KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:14 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:14 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:946 (946.0 b)  TX bytes:946 (946.0 b)</span><br></pre></td></tr></table></figure>
<p><strong><em>如果想获取所有的网口信息，用ifconfig -a命令</em></strong></p>
<ul>
<li>route—-查看路由表</li>
</ul>
<blockquote>
<p>输入route命令，回显如下：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">192.168.4.0     *               255.255.255.0   U     1      0        0 eth1</span><br><span class="line">default         localhost       0.0.0.0         UG    0      0        0 eth1</span><br></pre></td></tr></table></figure>
<p><strong><em>如果想看IP和网关，可以用ip route show命令</em></strong><br>命令详细的用法可请看文末的参考资料。</p>
<ul>
<li>ethtool –用于获取以太网卡的配置信息，或者修改这些配置</li>
</ul>
<blockquote>
<p>输入ethtool eth3，回显如下：</p>
</blockquote>
<p><img src="http://www.eefocus.com/include/picture/500/400/data/10-07/1279790415_6c3ec92d.jpg" alt=""></p>
<h3 id="各场景及问题解决"><a href="#各场景及问题解决" class="headerlink" title="各场景及问题解决"></a>各场景及问题解决</h3><ul>
<li><strong>问题一 设备如果有多个网口，到底哪个连线了呢，用哪个网口呢</strong></li>
</ul>
<blockquote>
<p>解决方法一：使用ifconfig -a命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eth1      Link encap:Ethernet  HWaddr 00:0C:29:33:4A:0C  </span><br><span class="line">          inet addr:192.168.4.115  Bcast:192.168.4.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::20c:29ff:fe33:4a0c/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8133 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:5861 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:818322 (799.1 KiB)  TX bytes:835205 (815.6 KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:14 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:14 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:946 (946.0 b)  TX bytes:946 (946.0 b)</span><br></pre></td></tr></table></figure>
<p>其中有一行 “UP BROADCAST RUNNING MULTICAST” 里面<strong>RUNNING</strong>表示该网口在工作！</p>
<blockquote>
<p>解决方法二：使用ethtool命令</p>
</blockquote>
<p>比如第一部分介绍的，用ethtool eth3，可以看到一行<br>“Link detected:<strong>yes</strong>”这也是表示连接状态正常</p>
<ul>
<li><strong>问题二 如何为设备配置IP</strong></li>
</ul>
<blockquote>
<p>解决方法一：临时配置：一般用命令来配置，马上生效，重启无效<br> <strong><em>ifconfig 网络接口名称 ip地址/子网掩码长度</em></strong> ，例如：<br>ifconfig eth1 192.168.40.20 netmask 255.255.255.0</p>
</blockquote>
<blockquote>
<p>解决方法二：固定配置：一般是更改配置文件，需要重启网卡生效<br><strong><em>网卡的配置文件：/etc/sysconfig/network-scripts/ifcfg-ethX。设置ip地址、子网掩码、默认网关等。</em></strong> ，例如： </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth1</span><br><span class="line">DEVICE=eth0 #物理设备名</span><br><span class="line">IPADDR=192.168.1.10 #IP地址</span><br><span class="line">NETMASK=255.255.255.0 #掩码值</span><br><span class="line">NETWORK=192.168.1.0 #网络地址(可不要)</span><br><span class="line">BROADCAST=192.168.1.255 #广播地址（可不要）</span><br><span class="line">GATEWAY=192.168.1.1 #网关地址</span><br><span class="line">ONBOOT=yes # [yes|no]（引导时是否激活设备）</span><br><span class="line">USERCTL=no #[yes|no]（非root用户是否可以控制该设备）</span><br><span class="line">BOOTPROTO=static #[none|static|bootp|dhcp]（引导时不使用协议|静态分配|BOOTP协议|DHCP协议）</span><br></pre></td></tr></table></figure>
<p>然后需要重启网卡</p>
<p>重启所有网卡：service network restart</p>
<p>重启个别网卡：<br>ifconfig eth1 down<br>ifconfig eth1 up</p>
<ul>
<li><strong>问题三 配置了IP之后，为何无法用ssh登录呢</strong></li>
<li><strong>问题四 配置IP之后，为何出现ssh登录无法输入密码的情况呢</strong></li>
</ul>
<blockquote>
<p>这两个问题均和sshd服务有关,一起解决o(<em>￣︶￣</em>)o<br>SSH(Secure Shell)是一种能够提供安全远程登陆会话的协议，假如希望在远程Linux系统中执行命令，就是通过这个协议！<br>为什么要强调SSH协议是安全的呢？因为比如ftp、telnet等服务在网络上不会对口令或数据进行加密，那么骇客们真的非常容易就可以截获这些信息（尤其是同局域网内的用户），因此它们在本质是就是不安全的。<br>sshd服务提供两种安全验证的方法：<br>基于口令的安全验证:经过验证帐号与密码即可登陆到远程主机。<br>基于密钥的安全验证:需要在本地生成”密钥对“后将公钥传送至服务端，进行公共密钥的比较。<br><strong>sshd服务的配置文件解析：</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config        ###sshd服务的配置文件</span><br><span class="line"></span><br><span class="line">Protocol 2  #只支持SSH2协议</span><br><span class="line">Port &lt;端口号&gt;  #修改默认端口号</span><br><span class="line">MaxStartups 5    #同时允许5个尚未登录的SSH联机</span><br><span class="line">MaxAuthTries 3 　 #最大登录尝试次数为3</span><br><span class="line">ServerKeyBits 1024　 #将ServerKey强度改为1024比特</span><br><span class="line"></span><br><span class="line">PermitEmptyPasswords no　 #禁止空密码进行登录</span><br><span class="line">ChallengeResponseAuthentication no #禁用s/key密码</span><br><span class="line">UsePAM no  #不通过PAM验证</span><br><span class="line">PermitRootLogin no #禁止root远程登录</span><br><span class="line">PasswordAuthentication no　 #不允许密码方式的登录</span><br><span class="line">RSAAuthentication no #不允许RSA认证，只针对SSH1</span><br><span class="line">PubkeyAuthentication yes #允许公钥认证</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys #保存公钥的认证文件</span><br><span class="line">UsePrivilegeSeparation yes    #用户权限设置</span><br><span class="line">SyslogFacility AUTH    #记录SSH登录情况</span><br><span class="line">LogLevel INFO    #记录等级为INFO</span><br><span class="line">PrintMotd yes    #登录成功后显示/etc/motd 文件的内容</span><br><span class="line">PrintLastLog no    #不显示上次登录信息</span><br><span class="line">Compression yes  #是否压缩命令</span><br><span class="line">KeepAlive yes    #防止死连接</span><br><span class="line">StrictModes yes    #接受连接请求前对用户主目录和相关的配置文件进行宿主和权限检查</span><br><span class="line">UseDNS no  #不使用DNS反解</span><br><span class="line"></span><br><span class="line">AllowUsers 用户名  #允许通过远程访问的用户，多个用户以空格分隔</span><br><span class="line">AllowGroups 组名  #允许通过远程访问的组，多个组以空格分隔</span><br><span class="line">DenyUsers 用户名  #禁止通过远程访问的用户，多个用户以空格分隔</span><br><span class="line">DenyGroups 组名  #禁止通过远程访问的组，多个组以空格分隔</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果想要以root用户登录，需要把<strong>PermitRootLogin</strong>这项后面的no改为yes<br>如果要用密码登录，需要把<strong>PasswordAuthentication</strong>这项后面的no改为yes<br>修改之后需要重启sshd服务：<br>service sshd restart</p>
</blockquote>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.linuxidc.com/Linux/2016-06/132393.htm">Linux基础网络设置</a><br><a href="http://man.linuxde.net/ethtool">ethtool命令</a><br><a href="https://www.cnblogs.com/peida/archive/2013/03/05/2943698.html">每天一个linux命令（53）：route命令</a><br><a href="https://www.cnblogs.com/snake-hand/p/3143041.html">linux route命令的使用详解</a><br><a href="http://www.linuxprobe.com/chapter-09.html#921_sshd">《Linux就该这么学》</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本直接执行与被调用执行结果不一致问题定位及总结</title>
    <url>/2017/11/20/shell%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%85%B6%E4%BB%96%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>本文主要总结近日在完成工作时遇到的一个shell脚本问题。具体问题是：shell脚本直接执行与被其他程序调用看到的执行结果不一致。<br>如果没时间看全文，就直接看结论：</p>
<ul>
<li>脚本相关的问题，首先考虑是不是用户不对（权限不对）</li>
<li>脚本相关的问题，其次考虑是不是调用的路径不对</li>
<li>定位时最好把错误日志打印到日志文件中(需要用到<strong>2&gt;&amp;1</strong>)，根据出错日志来，问题可能会很快解决</li>
</ul>
<h3 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h3><p>最近完成工作时，需要调用一个脚本，但是脚本中的有一段内容是固定的，因此需要在调用前获取环境的信息来替换脚本之中的内容后再执行该脚本，简单的说，比如需要获取环境中实际的IP来替换掉脚本中写死的IP或一个字符。于是就写了一个脚本来完成这个任务。</p>
<h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>完成脚本之后，在本地进行了调试，为了方便描述，分别将两个脚本简化为task1.sh和task2.sh，并且两个脚本在同一个目录下。</p>
<p>task1.sh内容：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">do</span> some task</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">now get current equipment IP</span></span><br><span class="line">current_IP=`ifconfig | grep &quot;inet&quot; | sed -n &#x27;1p&#x27; | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/$&#123;current_IP&#125;/127.0.0.1&quot; test2.sh</span><br><span class="line"></span><br><span class="line">sh test2.sh</span><br><span class="line"></span><br><span class="line">echo &quot;current IP:$&#123;current_IP&#125;.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>test2.sh内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">do</span> some task</span></span><br><span class="line"></span><br><span class="line">do something:127.0.0.1</span><br></pre></td></tr></table></figure>
<p>在完成好如上内容之后，直接执行sh test1.sh,运行结果也ok，符合预期。</p>
<p>然后将整个流程一起跑，发现运行结果不对，打印到屏幕上的结果也不对。<br>也就是直接调用脚本的结果是ok的，但是别人来调用我的脚本结果却不对。</p>
<p><strong>为什么自己直接登录到环境上执行那个task1.sh脚本是对的，整个流程中，其他程序比如lua或者c程序来调用，结果却不对呢，百思不得其解。</strong></p>
<h3 id="问题分析及解决过程"><a href="#问题分析及解决过程" class="headerlink" title="问题分析及解决过程"></a>问题分析及解决过程</h3><p>为了搞清是哪不对，对上述脚本进行分解。打印那句话很关键，发现打印到屏幕上的是<br><strong><em>current IP:.</em></strong><br>说明current_IP为空，那肯定是后面的整个语句的结果为空。<br>而那语句很长又有grep命令，有两种可能：  </p>
<ol>
<li>ifconfig命令出错，按道理这个命令很常见，出错可能性很小，而且单独直接运行都可以 </li>
<li>后面grep等语句出错</li>
</ol>
<p>为了定位到原因，将task1.sh脚本改为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">do</span> some task</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">now get current equipment IP</span></span><br><span class="line">ifconfig &gt; IP.txt</span><br><span class="line">current_IP=`cat IP.txt | grep &quot;inet&quot; | sed -n &#x27;1p&#x27; | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/$&#123;current_IP&#125;/127.0.0.1&quot; test2.sh</span><br><span class="line"></span><br><span class="line">sh test2.sh</span><br><span class="line"></span><br><span class="line">echo &quot;current IP:$&#123;current_IP&#125;.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要是将ifconfig命令的结果重定向到文件中，然后又分别试了直接执行和由流程调用，仍然发现直接执行OK，流程调用不行。<br>直接执行发现当前目录下生成了IP.txt，流程调用，在脚本的路径下却没有发现IP.txt,使用命令find / -name IP.txt发现该IP.txt在目录/opt/myapp/bin/目录下。一想在这也正常，因为C程序是在当前目录调用task1.sh的，本以为问题解决，是<strong>路径不对</strong>的问题导致，但是打开IP.txt文件一看，里面也没有任何信息。随即一想，是不是用户没有权限，然后脚本改为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">do</span> some task</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">now get current equipment IP</span></span><br><span class="line">basepath=$(cd `dirname $0`; pwd)</span><br><span class="line">user=`whoami`</span><br><span class="line">ifconfig &gt; /opt/myapp/script/IP.txt</span><br><span class="line">current_IP=`cat /opt/myapp/script/IP.txt | grep &quot;inet&quot; | awk &#x27;&#123;print $2&#125;&#x27; | awk -F [&quot;:&quot;] &#x27;&#123;p rint $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/$&#123;current_IP&#125;/127.0.0.1&quot; test2.sh</span><br><span class="line"></span><br><span class="line">sh test2.sh</span><br><span class="line"></span><br><span class="line">echo &quot;current IP:$&#123;current_IP&#125;, current user:$&#123;user&#125;, path:$&#123;basepath&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样修改之后，再用流程调用发现用户也是root，但是为啥不对呢，为啥IP.txt里面没有生成任何信息呢。</p>
<p>最后，将脚本改为：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">do</span> some task</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">now get current equipment IP</span></span><br><span class="line">basepath=$(cd `dirname $0`; pwd)</span><br><span class="line">user=`whoami`</span><br><span class="line">ifconfig &gt; /opt/myapp/script/IP.txt 2&gt;&amp;1</span><br><span class="line">current_IP=`cat /opt/myapp/script/IP.txt | grep &quot;inet&quot; | awk &#x27;&#123;print $2&#125;&#x27; | awk -F [&quot;:&quot;] &#x27;&#123;p rint $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/$&#123;current_IP&#125;/127.0.0.1&quot; test2.sh</span><br><span class="line"></span><br><span class="line">sh test2.sh</span><br><span class="line"></span><br><span class="line">echo &quot;current IP:$&#123;current_IP&#125;, current user:$&#123;user&#125;, path:$&#123;basepath&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>然后继续用流程调用，发现IP.txt里面内容为：<br><strong>ifconfig: command not found</strong></p>
<p>终于知道关键问题在哪了o(<em>￣︶￣</em>)o：  </p>
<p>原因：ifconfig命令所在路径/sbin未包含在系统环境变量PATH中（遇到其他命令出现这种情况可以参考下述解答，举一反三）</p>
<p>解决方法：  </p>
<ol>
<li>直接输入：/sbin/ifconfig  </li>
<li>临时修改环境变量：在shell中输入<br>$export PATH = $PATH:/sbin<br>然后再输入ifconfig命令即可，但是这只是临时更改了shell中的PATH，如果关闭shell，则修改消失，下次还需要重复如上操作  </li>
<li>永久修改PATH变量使之包含/sbin路径：<br>打开/etc/profile文件，在其中输入export PATH=$PATH:/sbin，保存并重开一个Xshell即可，这样一来，PATH路径永久修改成功，以后任何时候只需书序ifconfig命令即可</li>
</ol>
<hr>
<p>我使用方法1解决问题，直接写全路径，<strong>随便把/sbin加入到PATH中，可能会引起一些不必要的问题</strong>：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">do</span> some task</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">now get current equipment IP</span></span><br><span class="line"></span><br><span class="line">current_IP=`/sbin/ifconfig | grep &quot;inet&quot; | awk &#x27;&#123;print $2&#125;&#x27; | awk -F [&quot;:&quot;] &#x27;&#123;p rint $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">sed -i &quot;s/$&#123;current_IP&#125;/127.0.0.1&quot; test2.sh</span><br><span class="line"></span><br><span class="line">sh test2.sh</span><br><span class="line"></span><br><span class="line">echo &quot;current IP:$&#123;current_IP&#125;.&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
</blockquote>
<p><strong>几个基本符号及其含义</strong><br><strong>/dev/null 表示空设备文件</strong><br><strong>0 表示stdin标准输入</strong><br><strong>1 表示stdout标准输出</strong><br><strong>2 表示stderr标准错误</strong><br>2&gt;&amp;1，2就是标准错误，1是标准输出，那么这条命令就相当于把标准错误重定向到标准输出</p>
<ul>
<li>最初没有找到问题的关键，是因为没有将错误日志打印出来（用2&gt;&amp;1就可以了）,然后在进行瞎猜</li>
<li>如果遇到脚本执行不如预期，首先需要考虑是不是用户不对（权限不对）或者路径不对</li>
<li>获取当前用户：whoami</li>
<li>获取当前路径：basepath=$(cd <code>dirname $0</code>; pwd)</li>
</ul>
<p>如果一开始就把错误日志重定向到日志文件中，那么解决这个问题就是分分钟的事情了。<br>此外说明经验也很重要，如果经验丰富，多半能猜到是不是环境变量问题导致那个命令没有被找到，因此没有获取到想要的信息。</p>
<blockquote>
<p><strong><em>注意:ifconfig|grep “inet”|sed -n ‘1p’|awk ‘{print $2}’这个命令要根据环境随机变化</em></strong></p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.csdn.net/ggxiaobai/article/details/53507530">Linux里的2&gt;&amp;1究竟是什么</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Linux</tag>
        <tag>shell脚本</tag>
        <tag>问题定位</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2018/04/04/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本文主要回顾排序算法中的选择排序，主要有如下内容：<br>1.为什么要学习O( n^2 )的排序算法<br>2.一句白话说选择排序<br>3.选择排序的具体实现</p>
<hr>
<h3 id="为什么要学习O-n-2-的排序算法"><a href="#为什么要学习O-n-2-的排序算法" class="headerlink" title="为什么要学习O( n^2 )的排序算法"></a>为什么要学习O( n^2 )的排序算法</h3><p>学习过算法的我们都知道，时间复杂度为O( n^2 )的算法多半不是最佳算法，那为什么我们也要学习并掌握这种类型的算法呢，其实这种类型算法一般都具有如下特点：</p>
<ul>
<li>编码简单，易于实现，也就是我们很容易想到</li>
<li>此外可以在简单算法的基础上再做改进</li>
<li>特殊场景下，简单的排序算法更为有效</li>
<li>由简入难，从简单的排序算法思想再推演出复杂的排序算法</li>
</ul>
<h3 id="一句白话说选择排序"><a href="#一句白话说选择排序" class="headerlink" title="一句白话说选择排序"></a>一句白话说选择排序</h3><p>一句白话说选择排序：选择排序就是每次都从一堆元素中选出一个最小（大）的<br>详细一点就是：假设总共n个元素，第一趟从n个元素的数据序列中选出关键字最小/大的元素并放在最前/后位置，下一趟从n-1个元素中选出最小/大的元素并放在最前/后位置。以此类推，经过n-1趟完成排序。</p>
<h3 id="选择排序的具体实现"><a href="#选择排序的具体实现" class="headerlink" title="选择排序的具体实现"></a>选择排序的具体实现</h3><ul>
<li>C语言实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//寻找[i， n)之间的最小值</span></span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    selectionSort(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>C++实现</li>
</ul>
<p>清单1：头文件<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SELECTIONSORT_STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTIONSORT_STUDENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Student &amp;otherStudent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> score != otherStudent.score ? score &lt; otherStudent.score : name &lt; otherStudent.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Student &amp;student)</span><br><span class="line">    &#123;</span><br><span class="line">        os&lt;&lt;<span class="string">&quot;Student: &quot;</span>&lt;&lt;student.name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;student.score&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SELECTIONSORT_STUDENT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>清单2：具体实现<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> minIndex = i;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])</span><br><span class="line">             &#123;</span><br><span class="line">                 minIndex = j;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">swap</span>(arr[i], arr[minIndex]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">selectionSort</span>(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> b[<span class="number">4</span>] = &#123;<span class="number">4.4</span>, <span class="number">3.3</span>, <span class="number">2.2</span>, <span class="number">1.1</span>&#125;;</span><br><span class="line">    <span class="built_in">selectionSort</span>(b, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    string c[<span class="number">4</span>] = &#123;<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">selectionSort</span>(c, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;c[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    Student d[<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;D&quot;</span>,<span class="number">90</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;C&quot;</span>, <span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>,<span class="number">95</span>&#125;, </span><br><span class="line">    &#123;<span class="string">&quot;A&quot;</span>,<span class="number">95</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">selectionSort</span>(d, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>上述C++代码中用了到运算符重载，简单回顾一下：<br><strong>为什么要对运算符进行重载：</strong><br>C++预定义中的运算符的操作对象只局限于基本的内置数据类型，但是对于我们自定义的类型（类）是没有办法操作的。但是大多时候我们需要对我们定义的类型进行类似的运算，这个时候就需要我们对这么运算符进行重新定义，赋予其新的功能，以满足自身的需求。<br><strong>C++运算符重载的实质：</strong><br>运算符重载的实质就是函数重载或函数多态。运算符重载是一种形式的C++多态。目的在于让人能够用同名的函数来完成不同的基本操作。要重载运算符，需要使用被称为运算符函数的特殊函数形式，运算符函数形式：operatorp（argument-list）//operator 后面的’p’为要重载的运算符符号。<br>即：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;返回类型说明符&gt; <span class="keyword">operator</span> &lt;运算符符号&gt;(&lt;参数表&gt;)  </span><br><span class="line">&#123;  </span><br><span class="line">     &lt;函数体&gt;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到使用了模板或者其他语言中的泛型后，这样的一个程序的通用性就非常强，前面的C语言实现只能针对一种类型的数据进行排序！ </p>
</blockquote>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3>]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2018/04/05/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本文主要回顾排序算法中的插入排序，主要有如下内容：<br>1.一句白话说插入排序<br>2.插入排序的具体实现<br>3.插入排序与选择排序的性能对比</p>
<hr>
<h3 id="一句白话说插入排序"><a href="#一句白话说插入排序" class="headerlink" title="一句白话说插入排序"></a>一句白话说插入排序</h3><p>一句白话说插入排序：每次将一个待排序的元素，按大小插入到前面已经排好序的子序列中的适当位置，直到全部元素插入完成为止。</p>
<h3 id="插入排序的具体实现"><a href="#插入排序的具体实现" class="headerlink" title="插入排序的具体实现"></a>插入排序的具体实现</h3><ul>
<li>C语言实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写法一</span></span><br><span class="line">        <span class="comment">//for(int j = i; j &gt; 0; j--)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    if(arr[j] &lt; arr[j-1])</span></span><br><span class="line">        <span class="comment">//        swap(&amp;arr[j], &amp;arr[j-1]);</span></span><br><span class="line">        <span class="comment">//   else</span></span><br><span class="line">        <span class="comment">//        break;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//写法二</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="number">-1</span>]; j--)</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    InsertSort(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>C++实现</li>
</ul>
<p>清单1：头文件SortTestHelper.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SORT_TEST_HELPER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SORT_TEST_HELPER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SortTestHelper</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//生成有n个元素的随机数组，每个元素的随机范围为[range_l, range_r]</span></span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">generateRandomArray</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> range_l, <span class="type">int</span> range_r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = <span class="built_in">rand</span>()%(range_r - range_l + <span class="number">1</span>) + range_l;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝整型数组a中的所有元素到一个新的数组，并返回新的数组</span></span><br><span class="line">    <span class="function"><span class="type">int</span> *<span class="title">copyIntArray</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数组中所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数组是否有序</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">bool</span> <span class="title">isSorted</span><span class="params">(T a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i<span class="number">+1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试排序算法的正确性和算法运行的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">testSort</span><span class="params">(<span class="type">const</span> string &amp;sortName, <span class="type">void</span>(*sortAlgo)(T[], <span class="type">int</span>), T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">clock_t</span> startTime = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">sortAlgo</span>(arr, n);</span><br><span class="line">        <span class="type">clock_t</span> endTime = <span class="built_in">clock</span>();</span><br><span class="line">        cout &lt;&lt; sortName &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">double</span>(endTime - startTime)/CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; s&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isSorted</span>(arr, n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SORT_TEST_HELPER</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>清单2：头文件SelectionSort.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SELECTION_SORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SELECTION_SORT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[i], arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SELECTION_SORT</span></span></span><br></pre></td></tr></table></figure></p>
<p>清单3:insertSort.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SelectionSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入排序时，第一个元素默认已经是排好序了，所以i从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="number">-1</span>]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyIntArray</span>(arr1, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertSort, arr1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Selection Sort&quot;</span>, selectionSort, arr2, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了delete函数里面new出来的数组，否则会造成内存泄露</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">200000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr3 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr4 = SortTestHelper::<span class="built_in">copyIntArray</span>(arr3, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertSort, arr3, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Selection Sort&quot;</span>, selectionSort, arr4, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了delete函数里面new出来的数组，否则会造成内存泄露</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述C++代码代码实现中对插入排序和选择排序进行了对比<br>在我自己的电脑上实际运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Test for random array, size = 20000, random range [0, 20000]</span><br><span class="line">Insert Sort:0.618 s</span><br><span class="line">Selection Sort:0.517 s</span><br><span class="line">Test for random array, size = 200000, random range [0, 200000]</span><br><span class="line">Insert Sort:61.7 s</span><br><span class="line">Selection Sort:52.298 s</span><br><span class="line"></span><br><span class="line">Process returned 0 (0x0)   execution time : 115.749 s</span><br><span class="line">Press any key to continue.</span><br></pre></td></tr></table></figure>
<p>从运行结果可以看出：</p>
<ul>
<li><p>选择排序和插入排序所耗费的时间确实满足O( n^2 )规律的，当数据规模扩大10倍时，运行时间几乎扩大100倍</p>
</li>
<li><p>插入排序从理论上来说比选择排序要快一些的，因为插入排序内部循环在满足arr[j] &gt;= arr[j-1]时就可以停下来了，也就是说内部循环的次数是比选择排序要少的；但是为何实际测试的结果却比选择排序慢呢</p>
</li>
</ul>
<h3 id="插入排序与选择排序的性能对比"><a href="#插入排序与选择排序的性能对比" class="headerlink" title="插入排序与选择排序的性能对比"></a>插入排序与选择排序的性能对比</h3><p>从理论上来说二者都是O( n^2 )的排序算法</p>
<ul>
<li>选择排序：对于任何一个数组，两层循环，每层循环都会完全的执行完成，效率慢  </li>
<li>插入排序：第二层循环根据数组情况，可能会提前跳出循环，比如说在近乎有序的情况，因此在近乎有序的情况下，插入排序的性能是很高的  </li>
</ul>
<p>上一小节留下了一个问题，那就是为何上面的插入排序的实现比选择排序的实测结果要慢：<br>其实原因是上面的实现每次都有去swap交换，而每次swap里面就有三次赋值，还不考虑其他的，这样累积下来就比选择排序耗时了。<br>既然如此，那我们是不是应该想办法对上述的插入排序进行优化了，避免每次都去swap<br>优化的方法就是避免每次都去swap，将swap转换为普通的赋值，而不是每次都去swap，具体实现见清单4：</p>
<p>清单4：优化后的插入排序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SelectionSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入排序时，第一个元素默认已经是排好序了，所以i从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//(int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]; j--)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    swap(arr[j], arr[j-1]);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        T tmp = arr[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; tmp; j--)</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyIntArray</span>(arr1, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertSort, arr1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Selection Sort&quot;</span>, selectionSort, arr2, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了delete函数里面new出来的数组，否则会造成内存泄露</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">200000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr3 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr4 = SortTestHelper::<span class="built_in">copyIntArray</span>(arr3, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertSort, arr3, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Selection Sort&quot;</span>, selectionSort, arr4, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了delete函数里面new出来的数组，否则会造成内存泄露</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>实际运行结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Test for random array, size = 20000, random range [0, 20000]</span><br><span class="line">Insert Sort:0.271 s</span><br><span class="line">Selection Sort:0.528 s</span><br><span class="line">Test for random array, size = 200000, random range [0, 200000]</span><br><span class="line">Insert Sort:28.025 s</span><br><span class="line">Selection Sort:52.455 s</span><br><span class="line"></span><br><span class="line">Process returned 0 (0x0)   execution time : 83.397 s</span><br><span class="line">Press any key to continue.</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>数组近乎有序时的测试</strong></p>
<p>清单5：头文件SortTestHelper.h加入生成近乎有序数组的函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SORT_TEST_HELPER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SORT_TEST_HELPER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">namespace SortTestHelper</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//生成有n个元素的随机数组，每个元素的随机范围为[range_l, range_r]</span></span><br><span class="line">    <span class="type">int</span> *<span class="title function_">generateRandomArray</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> range_l, <span class="type">int</span> range_r)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arr = new <span class="type">int</span>[n];</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = rand()%(range_r - range_l + <span class="number">1</span>) + range_l;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个近乎有序的数组</span></span><br><span class="line">    <span class="comment">// 首先生成一个含有[0...n-1]的完全有序数组, 之后随机交换swapTimes对数据</span></span><br><span class="line">    <span class="comment">// swapTimes定义了数组的无序程度:</span></span><br><span class="line">    <span class="comment">// swapTimes == 0 时, 数组完全有序</span></span><br><span class="line">    <span class="comment">// swapTimes 越大, 数组越趋向于无序</span></span><br><span class="line">    <span class="type">int</span> *<span class="title function_">generateNearlyOrderedArray</span><span class="params">(<span class="type">int</span> n , <span class="type">int</span> swapTimes)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arr = new <span class="type">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = i;</span><br><span class="line"></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; swapTimes; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> posx = rand()%n;</span><br><span class="line">            <span class="type">int</span> posy = rand()%n;</span><br><span class="line">            swap(arr[posx], arr[posy]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝整型数组a中的所有元素到一个新的数组，并返回新的数组</span></span><br><span class="line">    <span class="type">int</span> *<span class="title function_">copyIntArray</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arr = new <span class="type">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            arr[i] = a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印数组中所有元素</span></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数组是否有序</span></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    <span class="type">bool</span> <span class="title function_">isSorted</span><span class="params">(T a[], <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试排序算法的正确性和算法运行的时间</span></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">testSort</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> &amp;sortName, <span class="type">void</span>(*sortAlgo)(T[], <span class="type">int</span>), T arr[], <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">clock_t</span> startTime = clock();</span><br><span class="line">        sortAlgo(arr, n);</span><br><span class="line">        <span class="type">clock_t</span> endTime = clock();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sortName &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="type">double</span>(endTime - startTime)/CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; s&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        assert(isSorted(arr, n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SORT_TEST_HELPER</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>清单6：insertSort.cpp加入对近乎有序的数组的测试<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SelectionSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入排序时，第一个元素默认已经是排好序了，所以i从1开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//(int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]; j--)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    swap(arr[j], arr[j-1]);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        T tmp = arr[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; tmp; j--)</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyIntArray</span>(arr1, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertSort, arr1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Selection Sort&quot;</span>, selectionSort, arr2, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了delete函数里面new出来的数组，否则会造成内存泄露</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">200000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr3 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr4 = SortTestHelper::<span class="built_in">copyIntArray</span>(arr3, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertSort, arr3, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Selection Sort&quot;</span>, selectionSort, arr4, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了delete函数里面new出来的数组，否则会造成内存泄露</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试近乎有序的数组</span></span><br><span class="line">    <span class="type">int</span> swapTimes = <span class="number">1000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for nearly ordered array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, swap time= &quot;</span>&lt;&lt;swapTimes&lt;&lt;endl;</span><br><span class="line">    arr1 = SortTestHelper::<span class="built_in">generateNearlyOrderedArray</span>(n, swapTimes);</span><br><span class="line">    arr2 = SortTestHelper::<span class="built_in">copyIntArray</span>(arr1, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insertion Sort&quot;</span>, insertSort, arr1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Selection Sort&quot;</span>, selectionSort, arr2, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>实测结果<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Test for random array, size = 20000, random range [0, 20000]</span><br><span class="line">Insert Sort:0.285 s</span><br><span class="line">Selection Sort:0.516 s</span><br><span class="line">Test for random array, size = 200000, random range [0, 200000]</span><br><span class="line">Insert Sort:28.214 s</span><br><span class="line">Selection Sort:52.536 s</span><br><span class="line">Test for nearly ordered array, size = 200000, swap time= 1000</span><br><span class="line">Insertion Sort:0.063 s</span><br><span class="line">Selection Sort:52.458 s</span><br><span class="line"></span><br><span class="line">Process returned 0 (0x0)   execution time : 137.457 s</span><br><span class="line">Press any key to continue.</span><br></pre></td></tr></table></figure></p>
<p>可以看到虽然同为O( n^2 )的排序算法，但是在近乎有序的情况下，插入排序的性能是极大的好于选择排序的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/liuyitian/p/4072262.html">白话排序算法–插入排序</a></p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序与Shell排序</title>
    <url>/2018/04/07/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8EShell%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本文主要回顾排序算法中的冒泡排序与Shell排序，主要有如下内容：  </p>
<ol>
<li>一句白话说冒泡排序  </li>
<li>冒泡排序的具体实现  </li>
<li>一句白话说shell排序  </li>
<li>Shell排序的具体实现</li>
</ol>
<hr>
<h3 id="一句白话说冒泡排序"><a href="#一句白话说冒泡排序" class="headerlink" title="一句白话说冒泡排序"></a>一句白话说冒泡排序</h3><p>一句白话说冒泡排序（升序排列）：假设序列长度为n，相邻元素两两比较，大的往后放，第一次完成后，最大的元素就出现在最大索引处；同理，剩下的元素继续这样操作，经过n-1次后排序即可得到一个有序序列。</p>
<h3 id="冒泡排序的具体实现"><a href="#冒泡排序的具体实现" class="headerlink" title="冒泡排序的具体实现"></a>冒泡排序的具体实现</h3><p>清单1：冒泡排序具体实现<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)<span class="comment">//只需要比较n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j<span class="number">+1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j<span class="number">+1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">bubbleSort</span>(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>上一篇文章<a href="https://ahnselina.github.io/插入排序/">插入排序</a>的插入排序最开始的实现，内层循环也是两两比较，不过他是往前比较，得益于前面的序列是有序的特点，所以插入排序可以提交结束循环。那么在这里的冒泡排序是不是可以优化一下呢，比如已经是有序的情况下就跳出循环：<br>清单2：优化后的冒泡排序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> notSorted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)<span class="comment">//只需要比较n-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j<span class="number">+1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                notSorted = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j<span class="number">+1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!notSorted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">bubbleSort</span>(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一句白话说Shell排序"><a href="#一句白话说Shell排序" class="headerlink" title="一句白话说Shell排序"></a>一句白话说Shell排序</h3><p>一句白话说Shell排序（升序排列）：<br>将整个待排元素序列切割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p>
<p>PS:可以认为Shell排序是对直接插入排序的一种优化,如果希望能看到比较清楚的图解，可以参考<a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法(二)之希尔排序</a>。<br><strong><em>由于直接插入排序在元素基本有序的情况下，效率是非常高的，因此希尔排序在时间效率上有较大提高。</em></strong></p>
<h3 id="Shell排序实现"><a href="#Shell排序实现" class="headerlink" title="Shell排序实现"></a>Shell排序实现</h3><p>清单3：头文件shellSort.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHELL_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = gap; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            T e = arr[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i; j &gt;= gap &amp;&amp;arr[j-gap] &gt; e; j -= gap)</span><br><span class="line">                arr[j] = arr[j-gap];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SHELL_SORT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>清单4：main函数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;insertionSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shellSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array,size：&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;].&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Shell Sort&quot;</span>, shellSort, arr, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertionSort, arr1, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr, n);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line"></span><br><span class="line">    n=<span class="number">100000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array,size：&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;].&quot;</span>&lt;&lt;endl;</span><br><span class="line">    arr = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    arr1 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Shell Sort&quot;</span>, shellSort, arr, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertionSort, arr1, n);</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意：SortTestHelper.h和insertionSort.h可参考上一篇文章<a href="https://ahnselina.github.io/插入排序/">插入排序</a>，这里就不贴这块代码了。<br>上面shell排序的实现的步长或者叫增量，选择是从n/2开始，每次再减半，直在结束时1。事实上，它可能有其他更有效的步长选择：<br>不同的增量将导致不同的效率，除了上述实现的增量选择，还可以选择增量为(1，4,13,40，121，…,3*h+1)，3*h+1 是使用最广泛的增量序列之一,时间复杂度为O( n^3/2 )</p>
<p>下面是其实现:<br>清单5：shell排序另一种增量选择<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHELL_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//增量为n/2的一种选择</span></span><br><span class="line"><span class="comment">//    for(int gap = n / 2; gap &gt; 0; gap /= 2)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        for(int i = gap; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            T e = arr[i];</span></span><br><span class="line"><span class="comment">//            int j;</span></span><br><span class="line"><span class="comment">//            for(j = i; j &gt;= gap &amp;&amp;arr[j-gap] &gt; e; j -= gap)</span></span><br><span class="line"><span class="comment">//                arr[j] = arr[j-gap];</span></span><br><span class="line"><span class="comment">//            arr[j] = e;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//增量为3*h+1的一种选择</span></span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &lt; n/<span class="number">3</span>)</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            T e = arr[i];</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i; j &gt;=h &amp;&amp; arr[j-h] &gt; e; j-=h)</span><br><span class="line">                arr[j] = arr[j-h];</span><br><span class="line">            arr[j] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SHELL_SORT_H</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/morewindows/article/details/6668714">白话经典算法系列之三 希尔排序的实现</a><br><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法(二)之希尔排序</a><br><a href="https://blog.csdn.net/z3881006/article/details/61922109">希尔排序详解</a></p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2018/04/10/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本文主要回顾归并排序，主要有如下内容：  </p>
<ol>
<li>白话说归并排序  </li>
<li>归并排序的具体实现  </li>
<li>归并排序的优化</li>
</ol>
<hr>
<h3 id="白话说归并排序"><a href="#白话说归并排序" class="headerlink" title="白话说归并排序"></a>白话说归并排序</h3><p>   归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案merge在一起，即分而治之)。</p>
<p>   归并排序将待排序数组A[1..n]分成两个各含n/2个元素的子序列，然后对这个两个子序列进行递归排序，最后将这两个已排序的子序列进行合并，即得到最终排好序的序列。<br>具体示例，比如下图中的序列：<br><img src="https://img1.sycdn.imooc.com/szimg/5aca41c00001029d12800720.jpg" alt="">  </p>
<p>首先，要想将该8个元素的序列进行排序，利用分而治之的想法，就可以不断的分解，分解到第三层的时候，每个子序列就只剩一个元素了，那此时就是有序的了。<br>可以看到8个元素的序列，可以分成3层，2^3 = 8，其实N个元素的序列就可以分为log(N)个层级；<br>其次另外一个问题，就是子序列有序了，如何merge成一个更大的有序的序列；比如下图左右两边都是有序的，如何merge<br><img src="https://img1.sycdn.imooc.com/szimg/5aca4264000160be12800720.jpg" alt="">  </p>
<p>这个时候其实需要开辟一段辅助空间来，<em>其实就是利用空间换取时间</em><br>merge过程图示：<br><img src="https://img1.sycdn.imooc.com/szimg/5a3b27640001a02712800720.jpg" alt=""><br>下面另外开辟一段辅助空间复制了一份待归并的2个序列，分别用了k指向待排序的序列的索引（l&lt;=k&lt;=r），i指向待归并的左边序列（l&lt;=i&lt;=mid）,j指向右边待归并的序列（mid+1&lt;=j&lt;r）.</p>
<p>通过上面的分析，我们比较直观地能感受到归并排序的时间复杂度为O( Nlog^N ),本文不做详细论证，有兴趣的同学可以查阅相关资料。</p>
<h3 id="归并排序的具体实现"><a href="#归并排序的具体实现" class="headerlink" title="归并排序的具体实现"></a>归并排序的具体实现</h3><p>清单1 归并排序具体实现的头文件mergeSort.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MERGE_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __merge(T a[], <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    T aux[r-l<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        aux[i-l] = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = aux[j-l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = aux[i-l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(aux[i-l] &lt; aux[j-l])</span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = aux[i-l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = aux[j-l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __mergeSort(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    __mergeSort(a, l, mid);</span><br><span class="line">    __mergeSort(a, mid<span class="number">+1</span>, r);</span><br><span class="line">    __merge(a, l, mid, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __mergeSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MERGE_SORT_H</span></span></span><br></pre></td></tr></table></figure><br>清单2 main函数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;insertionSort.h&quot;</span></span><br><span class="line"><span class="comment">//#include &quot;shellSort.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mergeSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;].&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr1, n);</span></span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr1, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr2, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr2, n);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    n=100000;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;Test for random array,size£º&quot;&lt;&lt;n&lt;&lt;&quot; range [0, &quot;&lt;&lt;n&lt;&lt;&quot;].&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    arr = SortTestHelper::generateRandomArray(n, 0, n);</span></span><br><span class="line"><span class="comment">//    arr1 = SortTestHelper::copyArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr1, n);</span></span><br><span class="line"><span class="comment">//    delete[] arr;</span></span><br><span class="line"><span class="comment">//    delete[] arr1;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：SortTestHelper.h与<a href="https://ahnselina.github.io/插入排序/">插入排序</a>中清单1头文件相同。</p>
<h3 id="归并排序的优化"><a href="#归并排序的优化" class="headerlink" title="归并排序的优化"></a>归并排序的优化</h3><ul>
<li>归并时判断，如果a[mid] &lt;= a[mid+1],其实左右两边就已经有序了，此次就不需要归并了</li>
<li>递归结束的时间点，在序列剩下较小数量的时候可以采用直接插入排序进行优化</li>
</ul>
<p>清单3：归并排序优化1<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MERGE_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __merge(T a[], <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    T aux[r-l<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        aux[i-l] = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = aux[j-l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = aux[i-l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(aux[i-l] &lt; aux[j-l])</span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = aux[i-l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = aux[j-l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __mergeSort(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对于剩余小规模数组，比如剩下15时, 可以使用插入排序进行优化</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    __mergeSort(a, l, mid);</span><br><span class="line">    __mergeSort(a, mid<span class="number">+1</span>, r);</span><br><span class="line">    <span class="comment">// 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge</span></span><br><span class="line">    <span class="comment">// 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失</span></span><br><span class="line">    <span class="keyword">if</span>( a[mid] &gt; a[mid<span class="number">+1</span>] )</span><br><span class="line">        __merge(a, l, mid, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __mergeSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MERGE_SORT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a>  </p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb用法总结</title>
    <url>/2018/04/01/GDB%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本文主要介绍强大的gdb工具，主要有如下内容：</p>
<ul>
<li>gdb使用前置条件</li>
<li>gdb一般用法</li>
<li>gdb常用命令</li>
<li>如何用gdb找到死锁</li>
</ul>
<p>GDB（GNU Debugger）是在Unix以及类Unix系统下的调试工具。功能极其强大，几乎涵盖了你所需要的全部功能。<br>GDB主要帮忙你完成下面四个方面的功能:<br>1.启动你的程序，可以按照你的定制要求随心所欲的运行程序。<br>2.可让被调试的程序在你所指定的调置的断点处停住。<br>3.当程序被停住时，可以检查此时你的程序中所发生的事，以及内存状态等。<br>4.动态的改变你程序的执行环境。</p>
<p><strong><em>gdb使用总旨：多用help！help里面总会有你需要的信息。如果你不知道如何使用help，请在gdb里面输入：help all</em></strong></p>
<hr>
<h3 id="gdb使用前置条件"><a href="#gdb使用前置条件" class="headerlink" title="gdb使用前置条件"></a>gdb使用前置条件</h3><ul>
<li><p>编译时加入debug信息</p>
</li>
<li><p>gcc/g++是在编译时加入-g，其他语言请自行百度。</p>
<blockquote>
<p>值得注意的是，-g分4个等级：<br>-g0等于不加-g,即不包含任何信息;<br>-g1只包含最小信息，一般来说只有你不需要debug，只需要backtrace信息，并且真的很在意程序大小，或者有其他保密/特殊需求时才会使用-g1;<br>–g2为gdb默认等级，包含绝大多数你需要的信息;<br>–g3包含一些额外信息，例如包含宏定义信息。当你需要调试宏定义时，请使用-g3</p>
</blockquote>
</li>
</ul>
<h3 id="gdb一般用法"><a href="#gdb一般用法" class="headerlink" title="gdb一般用法"></a>gdb一般用法</h3><pre><code>1. 调试程序。有几种方法可以在gdb下运行你的程序：

    1)    gdb $&#123;你的程序&#125; 进入gdb后，输入run(简写r) $&#123;arg1&#125; $&#123;arg2&#125; … $&#123;argN&#125;

    2)    gdb --args $&#123;你的程序&#125; $&#123;arg1&#125; $&#123;arg2&#125; … $&#123;argN&#125; 进入gdb后，运行run。

    3)    gdb进入gdb后，输入file $&#123;你的程序&#125;。然后使用set args  $&#123;arg1&#125; $&#123;arg2&#125; … $&#123;argN&#125; 设定好你的程序参数，再运行run。

 2. 调试正在运行的程序：

    gdb $&#123;你的程序&#125; $&#123;程序pid&#125;

 3. 查core：

    gdb $&#123;你的程序&#125; $&#123;core文件&#125;
</code></pre><h3 id="gdb常用命令"><a href="#gdb常用命令" class="headerlink" title="gdb常用命令"></a>gdb常用命令</h3><ol>
<li><p>backtrace：显示栈信息，<strong><em>简写为bt</em></strong>。</p>
</li>
<li><p>frame x 切换到第x帧，其中x会在bt命令中显示，从0开始（0表示栈顶）<strong><em>简写为f</em></strong>。</p>
</li>
<li><p>up/down x 往栈顶/栈底移动x帧；当不输入x时，默认为1。</p>
</li>
<li><p>print x打印x的信息，x可以是变量，也可以是对象或者数组，<strong><em>简写为p</em></strong>。</p>
</li>
<li><p>print */&amp;x 打印x的内容/地址。</p>
</li>
<li><p>call 调用函数。注意此命令需要一个正在运行的程序。</p>
</li>
<li><p>set substitute-path from_path  to_path，替换源码文件路径。当编译机与运行程序的机器代码路径不同时，需要使用该指令替换代码路径，否则你无法在gdb中看到源码。</p>
</li>
<li><p>break x.cpp:n 在x.cpp的第n行设置断点，然后gdb会给出断点编号m，。<strong><em>命令简写为b</em></strong>。</p>
</li>
<li><p>command m 设置程序执行到断点m时要看的内容，例如：</p>
<p>  command n</p>
<pre><code>&gt;printf &quot;x is %d\n&quot;,x

&gt;c

&gt;end
</code></pre><p>  如果command后面没有参数n，则命令被赋给最后一个breakpoint，这其实是说break和command连在一起用，在脚本里用就非常方便了。</p>
</li>
<li><p>x /nfu ${addr} 打印addr的内容。addr可以是任何合法的地址表达式，例如0x562fb3d，一个当前有效的指针变量p，或者一个当前有效的变量var的地址&amp;var。nfu是格式，n表示查看的长度，F表示格式（例如16进制或10进制），U表示单位（例如单字节b，双字h，四字w等）。举个栗子：</p>
<blockquote>
<p>(gdb) x /3xw 0x562fb3d //这个指令的意思为：以16进制格式显示地址0x562fb3d处3个单位，每个单位四字节的内容。你将得到下列数值:<br>0x562fb3d:    0x00282ff4    0x080484e0    0x00000000</p>
</blockquote>
</li>
<li><p>continue 继续运行程序。进入调试模式后，若你已经获取了你需要的信息或者需要程序继续运行时使用,<strong><em>简写为c</em></strong></p>
</li>
<li><p>until 执行到当前循环完成,<strong><em>可简写为u</em></strong></p>
</li>
<li><p>step 单步调试，步入当前函数,<strong><em>可简写为s</em></strong></p>
</li>
<li><p>next 单步调试，步过当前函数,<strong><em>可简写为n</em></strong></p>
</li>
<li><p>finish 执行到当前函数返回</p>
</li>
<li><p>set var x=10 改变当前变量x的值。也可以这样用：set {int}0x83040 = 10把内存地址0x83040的值强制转换为int并赋值为10</p>
</li>
<li><p>info locals 打印当前栈帧的本地变量</p>
</li>
<li><p>jump使当前执行的程序跳转到某一行，或者跳转到某个地址。由于只会使程序跳转而不会改变栈值，因此若跳出函数到另外的地方 会导致return出错。另外，熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如： set $pc = 0x485</p>
</li>
<li><p>return: 强制函数返回。可以指定返回值</p>
</li>
</ol>
<h3 id="如何用gdb找到死锁"><a href="#如何用gdb找到死锁" class="headerlink" title="如何用gdb找到死锁"></a>如何用gdb找到死锁</h3><h4 id="定位死锁问题常用的几个命令"><a href="#定位死锁问题常用的几个命令" class="headerlink" title="定位死锁问题常用的几个命令"></a>定位死锁问题常用的几个命令</h4><blockquote>
<p>gdb attach pid<br>info threads //显示所有线程信息<br>thread applay all bt//<strong><em>可简写为t a a bt</em></strong><br>thread 2  //跳到第2个线程<br>bt  //查看线程2的堆栈</p>
</blockquote>
<h4 id="死锁问题实例"><a href="#死锁问题实例" class="headerlink" title="死锁问题实例"></a>死锁问题实例</h4><p>清单 1. 测试程序<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1 = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex2 = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex3 = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex4 = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sequence1 = <span class="number">0</span>; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sequence2 = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">   pthread_mutex_lock(&amp;mutex1); </span><br><span class="line">   ++sequence1; </span><br><span class="line">   sleep(<span class="number">1</span>); </span><br><span class="line">   pthread_mutex_lock(&amp;mutex2); </span><br><span class="line">   ++sequence2; </span><br><span class="line">   pthread_mutex_unlock(&amp;mutex2); </span><br><span class="line">   pthread_mutex_unlock(&amp;mutex1); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sequence1; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">   pthread_mutex_lock(&amp;mutex2); </span><br><span class="line">   ++sequence2; </span><br><span class="line">   sleep(<span class="number">1</span>); </span><br><span class="line">   pthread_mutex_lock(&amp;mutex1); </span><br><span class="line">   ++sequence1; </span><br><span class="line">   pthread_mutex_unlock(&amp;mutex1); </span><br><span class="line">   pthread_mutex_unlock(&amp;mutex2); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sequence2; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread1</span><span class="params">(<span class="type">void</span>* arg)</span> </span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">int</span> iRetValue = func1(); </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (iRetValue == <span class="number">100000</span>) </span><br><span class="line">       &#123; </span><br><span class="line">           pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread2</span><span class="params">(<span class="type">void</span>* arg)</span> </span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       <span class="type">int</span> iRetValue = func2(); </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (iRetValue == <span class="number">100000</span>) </span><br><span class="line">       &#123; </span><br><span class="line">           pthread_exit(<span class="literal">NULL</span>); </span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread3</span><span class="params">(<span class="type">void</span>* arg)</span> </span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       sleep(<span class="number">1</span>); </span><br><span class="line">       <span class="type">char</span> szBuf[<span class="number">128</span>]; </span><br><span class="line">       <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(szBuf)); </span><br><span class="line">       <span class="built_in">strcpy</span>(szBuf, <span class="string">&quot;thread3&quot;</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread4</span><span class="params">(<span class="type">void</span>* arg)</span> </span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       sleep(<span class="number">1</span>); </span><br><span class="line">       <span class="type">char</span> szBuf[<span class="number">128</span>]; </span><br><span class="line">       <span class="built_in">memset</span>(szBuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(szBuf)); </span><br><span class="line">       <span class="built_in">strcpy</span>(szBuf, <span class="string">&quot;thread3&quot;</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">   <span class="type">pthread_t</span> tid[<span class="number">4</span>]; </span><br><span class="line">   <span class="keyword">if</span> (pthread_create(&amp;tid[<span class="number">0</span>], <span class="literal">NULL</span>, &amp;thread1, <span class="literal">NULL</span>) != <span class="number">0</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       _exit(<span class="number">1</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span> (pthread_create(&amp;tid[<span class="number">1</span>], <span class="literal">NULL</span>, &amp;thread2, <span class="literal">NULL</span>) != <span class="number">0</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       _exit(<span class="number">1</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span> (pthread_create(&amp;tid[<span class="number">2</span>], <span class="literal">NULL</span>, &amp;thread3, <span class="literal">NULL</span>) != <span class="number">0</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       _exit(<span class="number">1</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span> (pthread_create(&amp;tid[<span class="number">3</span>], <span class="literal">NULL</span>, &amp;thread4, <span class="literal">NULL</span>) != <span class="number">0</span>) </span><br><span class="line">   &#123; </span><br><span class="line">       _exit(<span class="number">1</span>); </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   sleep(<span class="number">5</span>); </span><br><span class="line">   <span class="comment">//pthread_cancel(tid[0]); </span></span><br><span class="line"></span><br><span class="line">   pthread_join(tid[<span class="number">0</span>], <span class="literal">NULL</span>); </span><br><span class="line">   pthread_join(tid[<span class="number">1</span>], <span class="literal">NULL</span>); </span><br><span class="line">   pthread_join(tid[<span class="number">2</span>], <span class="literal">NULL</span>); </span><br><span class="line">   pthread_join(tid[<span class="number">3</span>], <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">   pthread_mutex_destroy(&amp;mutex1); </span><br><span class="line">   pthread_mutex_destroy(&amp;mutex2); </span><br><span class="line">   pthread_mutex_destroy(&amp;mutex3); </span><br><span class="line">   pthread_mutex_destroy(&amp;mutex4); </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清单 2. 编译测试程序<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[dyu@xilinuxbldsrv purify]$ g++ -g lock.cpp -o lock -lpthread</span><br></pre></td></tr></table></figure><br>清单 3. 查找测试程序的进程号<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[dyu@xilinuxbldsrv purify]$ ps -ef|grep lock </span><br><span class="line">dyu       6721  5751  0 15:21 pts/3    00:00:00 ./lock</span><br></pre></td></tr></table></figure><br>清单 4. 对死锁进程第一次执行 pstack（pstack –进程号）的输出结果（pstack用法可以查阅文末参考资料）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[dyu@xilinuxbldsrv purify]$ pstack 6721 </span><br><span class="line">Thread 5 (Thread 0x41e37940 (LWP 6722)): </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000003d1a80d4c4 <span class="keyword">in</span> __lll_lock_wait () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000003d1a808e1a <span class="keyword">in</span> _L_lock_1034 () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0000003d1a808cdc <span class="keyword">in</span> pthread_mutex_lock () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x0000000000400a9b <span class="keyword">in</span> func1() ()</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000000000400ad7 <span class="keyword">in</span> thread1(void*) ()</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span> </span><br><span class="line">Thread 4 (Thread 0x42838940 (LWP 6723)): </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000003d1a80d4c4 <span class="keyword">in</span> __lll_lock_wait () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000003d1a808e1a <span class="keyword">in</span> _L_lock_1034 () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0000003d1a808cdc <span class="keyword">in</span> pthread_mutex_lock () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x0000000000400a17 <span class="keyword">in</span> func2() ()</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000000000400a53 <span class="keyword">in</span> thread2(void*) ()</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span> </span><br><span class="line">Thread 3 (Thread 0x43239940 (LWP 6724)): </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000003d19c9a541 <span class="keyword">in</span> nanosleep () from /lib64/libc.so.6</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000003d19c9a364 <span class="keyword">in</span> <span class="built_in">sleep</span> () from /lib64/libc.so.6</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00000000004009bc <span class="keyword">in</span> thread3(void*) ()</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span> </span><br><span class="line">Thread 2 (Thread 0x43c3a940 (LWP 6725)): </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000003d19c9a541 <span class="keyword">in</span> nanosleep () from /lib64/libc.so.6</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000003d19c9a364 <span class="keyword">in</span> <span class="built_in">sleep</span> () from /lib64/libc.so.6</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0000000000400976 <span class="keyword">in</span> thread4(void*) ()</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span> </span><br><span class="line">Thread 1 (Thread 0x2b984ecabd90 (LWP 6721)): </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000003d1a807b35 <span class="keyword">in</span> pthread_join () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000000000400900 <span class="keyword">in</span> main ()</span></span><br></pre></td></tr></table></figure>
<p>清单 5. 对死锁进程第二次执行 pstack（pstack –进程号）的输出结果<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> [dyu@xilinuxbldsrv purify]$ pstack 6721 </span><br><span class="line"> Thread 5 (Thread 0x40bd6940 (LWP 6722)): </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">0  0x0000003d1a80d4c4 <span class="keyword">in</span> __lll_lock_wait () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">1  0x0000003d1a808e1a <span class="keyword">in</span> _L_lock_1034 () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">2  0x0000003d1a808cdc <span class="keyword">in</span> pthread_mutex_lock () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">3  0x0000000000400a87 <span class="keyword">in</span> func1() ()</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">4  0x0000000000400ac3 <span class="keyword">in</span> thread1(void*) ()</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">5  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">6  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span> </span><br><span class="line"> Thread 4 (Thread 0x415d7940 (LWP 6723)): </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">0  0x0000003d1a80d4c4 <span class="keyword">in</span> __lll_lock_wait () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">1  0x0000003d1a808e1a <span class="keyword">in</span> _L_lock_1034 () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">2  0x0000003d1a808cdc <span class="keyword">in</span> pthread_mutex_lock () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">3  0x0000000000400a03 <span class="keyword">in</span> func2() ()</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">4  0x0000000000400a3f <span class="keyword">in</span> thread2(void*) ()</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">5  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">6  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span> </span><br><span class="line"> Thread 3 (Thread 0x41fd8940 (LWP 6724)): </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">0  0x0000003d19c7aec2 <span class="keyword">in</span> memset () from /lib64/libc.so.6</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">1  0x00000000004009be <span class="keyword">in</span> thread3(void*) ()</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">2  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">3  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span> </span><br><span class="line"> Thread 2 (Thread 0x429d9940 (LWP 6725)): </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">0  0x0000003d19c7ae0d <span class="keyword">in</span> memset () from /lib64/libc.so.6</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">1  0x0000000000400982 <span class="keyword">in</span> thread4(void*) ()</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">2  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">3  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span> </span><br><span class="line"> Thread 1 (Thread 0x2af906fd9d90 (LWP 6721)): </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">0  0x0000003d1a807b35 <span class="keyword">in</span> pthread_join () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_"> #</span><span class="language-bash">1  0x0000000000400900 <span class="keyword">in</span> main ()</span></span><br><span class="line">连续多次查看这个进程的函数调用关系堆栈进行分析：当进程吊死时，多次使用 pstack 查看进程的函数调用堆栈，死锁线程将一直处于等锁的状态，对比多次的函数调用堆栈输出结果，确定哪两个线程（或者几个线程）一直没有变化且一直处于等锁的状态（可能存在两个线程 一直没有变化）。</span><br><span class="line">输出分析：</span><br><span class="line">根据上面的输出对比可以发现，线程 1 和线程 2 由第一次 pstack 输出的处在 sleep 函数变化为第二次 pstack 输出的处在 memset 函数。但是线程 4 和线程 5 一直处在等锁状态（pthread_mutex_lock），在连续两次的 pstack 信息输出中没有变化，所以我们可以推测线程 4 和线程 5 发生了死锁。</span><br><span class="line">Gdb into thread输出：</span><br></pre></td></tr></table></figure></p>
<p>清单 6. 然后通过 gdb attach 到死锁进程<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  (gdb) info thread </span><br><span class="line"> 5 Thread 0x41e37940 (LWP 6722)  0x0000003d1a80d4c4 in __lll_lock_wait () </span><br><span class="line"> from /lib64/libpthread.so.0 </span><br><span class="line"> 4 Thread 0x42838940 (LWP 6723)  0x0000003d1a80d4c4 in __lll_lock_wait () </span><br><span class="line"> from /lib64/libpthread.so.0 </span><br><span class="line"> 3 Thread 0x43239940 (LWP 6724)  0x0000003d19c9a541 in nanosleep () </span><br><span class="line">from /lib64/libc.so.6 </span><br><span class="line"> 2 Thread 0x43c3a940 (LWP 6725)  0x0000003d19c9a541 in nanosleep () </span><br><span class="line">from /lib64/libc.so.6 </span><br><span class="line">* 1 Thread 0x2b984ecabd90 (LWP 6721)  0x0000003d1a807b35 in pthread_join () </span><br><span class="line">from /lib64/libpthread.so.0</span><br></pre></td></tr></table></figure><br>清单 7. 切换到线程 5 的输出<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) thread 5 </span><br><span class="line">[Switching to thread 5 (Thread 0x41e37940 (LWP 6722))]#0  0x0000003d1a80d4c4 in </span><br><span class="line">__lll_lock_wait () from /lib64/libpthread.so.0 </span><br><span class="line">(gdb) where </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x0000003d1a80d4c4 <span class="keyword">in</span> __lll_lock_wait () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000003d1a808e1a <span class="keyword">in</span> _L_lock_1034 () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0000003d1a808cdc <span class="keyword">in</span> pthread_mutex_lock () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x0000000000400a9b <span class="keyword">in</span> func1 () at lock.cpp:18</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000000000400ad7 <span class="keyword">in</span> thread1 (arg=0x0) at lock.cpp:43</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x0000003d1a80673d <span class="keyword">in</span> start_thread () from /lib64/libpthread.so.0</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x0000003d19cd40cd <span class="keyword">in</span> <span class="built_in">clone</span> () from /lib64/libc.so.6</span></span><br></pre></td></tr></table></figure><br>清单 8. 线程 4 和线程 5 的输出<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) f 3 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x0000000000400a9b <span class="keyword">in</span> func1 () at lock.cpp:18</span> </span><br><span class="line">18          pthread_mutex_lock(&amp;mutex2); </span><br><span class="line">(gdb) thread 4 </span><br><span class="line">[Switching to thread 4 (Thread 0x42838940 (LWP 6723))]#0  0x0000003d1a80d4c4 in </span><br><span class="line">__lll_lock_wait () from /lib64/libpthread.so.0 </span><br><span class="line">(gdb) f 3 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x0000000000400a17 <span class="keyword">in</span> func2 () at lock.cpp:31</span> </span><br><span class="line">31          pthread_mutex_lock(&amp;mutex1); </span><br><span class="line">(gdb) p mutex1 </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;__data = &#123;__lock = 2, __count = 0, __owner = 6722, __nusers = 1, __kind = 0,</span> </span><br><span class="line">__spins = 0, __list = &#123;__prev = 0x0, __next = 0x0&#125;&#125;, </span><br><span class="line"> __size = &quot;\002\000\000\000\000\000\000\000B\032\000\000\001&quot;, &#x27;\000&#x27;</span><br><span class="line">&lt;repeats 26 times&gt;, __align = 2&#125; </span><br><span class="line">(gdb) p mutex3 </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;__data = &#123;__lock = 0, __count = 0, __owner = 0, __nusers = 0,</span> </span><br><span class="line">__kind = 0, __spins = 0, __list = &#123;__prev = 0x0, __next = 0x0&#125;&#125;, </span><br><span class="line">__size = &#x27;\000&#x27; &lt;repeats 39 times&gt;, __align = 0&#125; </span><br><span class="line">(gdb) p mutex2 </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;__data = &#123;__lock = 2, __count = 0, __owner = 6723, __nusers = 1,</span> </span><br><span class="line">__kind = 0, __spins = 0, __list = &#123;__prev = 0x0, __next = 0x0&#125;&#125;, </span><br><span class="line"> __size = &quot;\002\000\000\000\000\000\000\000C\032\000\000\001&quot;, &#x27;\000&#x27;</span><br><span class="line">&lt;repeats 26 times&gt;, __align = 2&#125; </span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>从上面可以发现，线程 4 正试图获得锁 mutex1，但是锁 mutex1 已经被 LWP 为 6722 的线程得到（<strong>owner = 6722），线程 5 正试图获得锁 mutex2，但是锁 mutex2 已经被 LWP 为 6723 的 得到（</strong>owner = 6723），从 pstack 的输出可以发现，LWP 6722 与线程 5 是对应的，LWP 6723 与线程 4 是对应的。所以我们可以得出， 线程 4 和线程 5 发生了交叉持锁的死锁现象。查看线程的源代码发现，线程 4 和线程 5 同时使用 mutex1 和 mutex2，且申请顺序不合理。</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/xsln/p/gdb_instructions1.html">GDB常用命令使用说明（一）</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-deadlock/">一个 Linux 上分析死锁的简单方法</a><br><a href="http://man.linuxde.net/pstack">pstack命令</a><br><a href="https://blog.csdn.net/wyaibyn/article/details/28442347">pstack</a>  </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>问题定位</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2018/04/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本文主要回顾快速排序，主要有如下内容：  </p>
<ol>
<li>白话快速排序  </li>
<li>快速排序的具体实现  </li>
<li>快速排序的问题与优化（两路快速排序与三路快速排序）</li>
</ol>
<hr>
<h3 id="白话快速排序"><a href="#白话快速排序" class="headerlink" title="白话快速排序"></a>白话快速排序</h3><p>快速排序被列为20世纪最伟大的算法之一，当然是因为其排序的效率高，但是其实算法也是在逐渐优化改进的。快速排序同归并排序一样，也采用分而治之的策略，但是分的策略是有差异的，后面准备专门写一篇来讲述分而治之，先说快速排序，其基本思想如下：  </p>
<ol>
<li>先从数列中取出一个数作为基准数。  </li>
<li>分区过程，将比这个数大的或者等于它的数全放到它的右边，小于它的数全放到它的左边。  </li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ol>
<p><img src="https://img1.sycdn.imooc.com/szimg/59a762e6000184df12800720.jpg" alt=""><br>如上图，划分的过程中会出现如上图的情况，l+1到j的数都小于v（即图中橙色部分）,j+1到i（不包括i，i是当前正在考察的元素，考察完之后再决定加入哪个部分，即图中紫色部分，图中紫色）&gt;=v，当前元素e如果小于v，那么需要将该元素放大橙色的部分，如何放呢？<br>就是将j后面一个元素与e所在元素交换，然后j计数加一即可。如果e不小于v，那直接放入紫色部分，i++即可。</p>
<blockquote>
<p>快速排序通常情况下的时间复杂度为O( Nlog^N ),但是在某些特殊场景的下，比如完全有序的序列，会退化成O( N^2 )的时间复杂度，针对此种情况本文后面有优化方案，详见后文。</p>
</blockquote>
<h3 id="快速排序的具体实现"><a href="#快速排序的具体实现" class="headerlink" title="快速排序的具体实现"></a>快速排序的具体实现</h3><p>清单1 基本的快速排序实现–quickSort.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUICK_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUICK_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> __partitionQ(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    T e = a[l];</span><br><span class="line">    <span class="comment">//[l+1,j] &lt; e;[j+1,i) &gt; e</span></span><br><span class="line">    <span class="type">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; e)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="built_in">swap</span>(a[j], a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __quickSort(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = __partitionQ(a, l, r);</span><br><span class="line">    __quickSort(a, l, p<span class="number">-1</span>);</span><br><span class="line">    __quickSort(a, p<span class="number">+1</span>, r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __quickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// QUICK_SORT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>清单2 main函数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;selectionSort.h&quot;</span></span><br><span class="line"><span class="comment">//#include &quot;insertionSort.h&quot;</span></span><br><span class="line"><span class="comment">//#include &quot;shellSort.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mergeSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quickSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">200000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;].&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;select Sort&quot;, selectionSort, arr, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr1, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr1, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr2, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr, n);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr3, n);</span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr3, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr4, n);</span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr4, n);</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line"></span><br><span class="line">    n=<span class="number">75000</span>;</span><br><span class="line">    <span class="type">int</span> swaptime=<span class="number">100</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for nearly ordered array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, swap time = &quot;</span>&lt;&lt;swaptime&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr_n1 = SortTestHelper::<span class="built_in">generateNearlySortedArray</span>(n, swaptime);</span><br><span class="line">    <span class="type">int</span> *arr_n2 = SortTestHelper::<span class="built_in">copyArray</span>(arr_n1, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr_n1, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr3, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr_n2, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr4, n);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr_n1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr_n2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    n=100000;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;Test for random array,size£º&quot;&lt;&lt;n&lt;&lt;&quot; range [0, &quot;&lt;&lt;n&lt;&lt;&quot;].&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    arr = SortTestHelper::generateRandomArray(n, 0, n);</span></span><br><span class="line"><span class="comment">//    arr1 = SortTestHelper::copyArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr1, n);</span></span><br><span class="line"><span class="comment">//    delete[] arr;</span></span><br><span class="line"><span class="comment">//    delete[] arr1;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：SortTestHelper.h与<a href="https://ahnselina.github.io/插入排序/">插入排序</a>中清单1头文件相同。</p>
<p>清单3 上述程序运行结果（windows 10 笔记本，4G内存）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test <span class="keyword">for</span> random array,size:<span class="number">200000</span> range [<span class="number">0</span>, <span class="number">200000</span>].</span><br><span class="line">Merge Sort : <span class="number">0.049</span> s</span><br><span class="line">Quick sort : <span class="number">0.034</span> s</span><br><span class="line">Test <span class="keyword">for</span> nearly ordered array,size:<span class="number">75000</span>, swap time = <span class="number">100.</span></span><br><span class="line">Merge Sort : <span class="number">0.013</span> s</span><br><span class="line">Quick sort : <span class="number">2.35</span> s</span><br><span class="line"></span><br><span class="line">Process returned <span class="number">0</span> (<span class="number">0x0</span>)   execution time : <span class="number">3.228</span> s</span><br><span class="line">Press any key to <span class="keyword">continue</span>.</span><br></pre></td></tr></table></figure></p>
<h3 id="快速排序的问题与优化"><a href="#快速排序的问题与优化" class="headerlink" title="快速排序的问题与优化"></a>快速排序的问题与优化</h3><p>注意上面清单3的程序的运行结果：在随机的数组无序情况下，快速排序比归并排序稍微快一点，但差距不大；但是在近乎有序的情况，快速的运行时间为2.35秒，而同为O( Nlog^N )归并排序仅花了0.013s，快速排序比归并排序慢了180倍！！！这是为什么呢？？  </p>
<blockquote>
<p>原因是在近乎有序的情况下，上述的基本的快速排序实现的时间复杂度退化成了几乎是O( N^2 )</p>
</blockquote>
<p>优化方法：基本的快速排序实现，在选取那个基准数的时候，每次都是选第一个，在有序的时候复杂度就退化成了O( N^2 )，在分而治之的时候，左边没有分到元素，全部都分到右边去了，左右两边极度的不平衡，因此优化方案就是避免此种情况出现，所以每次都随机选择一个基准数。</p>
<p>清单4 优化选择基准数后的快速排序实现<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUICK_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUICK_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> __partitionQ(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[<span class="built_in">rand</span>()%(r-l<span class="number">+1</span>)+l]);</span><br><span class="line">    T e = a[l];</span><br><span class="line">    <span class="comment">//[l+1,j] &lt; e;[j+1,i) &gt; e</span></span><br><span class="line">    <span class="type">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; e)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="built_in">swap</span>(a[j], a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __quickSort(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = __partitionQ(a, l, r);</span><br><span class="line">    __quickSort(a, l, p<span class="number">-1</span>);</span><br><span class="line">    __quickSort(a, p<span class="number">+1</span>, r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// QUICK_SORT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>清单5 优化后的运行结果<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test <span class="keyword">for</span> random array,size:<span class="number">200000</span> range [<span class="number">0</span>, <span class="number">200000</span>].</span><br><span class="line">Merge Sort : <span class="number">0.062</span> s</span><br><span class="line">Quick sort : <span class="number">0.047</span> s</span><br><span class="line">Test <span class="keyword">for</span> nearly ordered array,size:<span class="number">75000</span>, swap time = <span class="number">100.</span></span><br><span class="line">Merge Sort : <span class="number">0.016</span> s</span><br><span class="line">Quick sort : <span class="number">0.015</span> s</span><br><span class="line"></span><br><span class="line">Process returned <span class="number">0</span> (<span class="number">0x0</span>)   execution time : <span class="number">0.749</span> s</span><br><span class="line">Press any key to <span class="keyword">continue</span>.</span><br></pre></td></tr></table></figure><br>可以看到优化之后，快速排序与归并排序所消耗的时间已经相差无几了。</p>
<p><strong>对有大量相同元素的数组进行排序测试</strong></p>
<p>清单6 测试存在包含大量相同元素的数组<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;selectionSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;insertionSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shellSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mergeSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quickSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">200000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;].&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;select Sort&quot;, selectionSort, arr, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr1, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr1, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr2, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr, n);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr3, n);</span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr3, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr4, n);</span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr4, n);</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line"></span><br><span class="line">    n=<span class="number">200000</span>;</span><br><span class="line">    <span class="type">int</span> swaptime=<span class="number">100</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for nearly ordered array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, swap time = &quot;</span>&lt;&lt;swaptime&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr_n1 = SortTestHelper::<span class="built_in">generateNearlySortedArray</span>(n, swaptime);</span><br><span class="line">    <span class="type">int</span> *arr_n2 = SortTestHelper::<span class="built_in">copyArray</span>(arr_n1, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr_n1, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr3, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr_n2, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr4, n);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr_n1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr_n2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试3 测试存在包含大量相同元素的数组</span></span><br><span class="line">    <span class="comment">// 使用双快速排序后, 我们的快速排序算法可以轻松的处理包含大量元素的数组</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0,10]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick Sort&quot;</span>, quickSort, arr2, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    n=100000;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;Test for random array,size£º&quot;&lt;&lt;n&lt;&lt;&quot; range [0, &quot;&lt;&lt;n&lt;&lt;&quot;].&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    arr = SortTestHelper::generateRandomArray(n, 0, n);</span></span><br><span class="line"><span class="comment">//    arr1 = SortTestHelper::copyArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr, n);</span></span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr1, n);</span></span><br><span class="line"><span class="comment">//    delete[] arr;</span></span><br><span class="line"><span class="comment">//    delete[] arr1;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>测试结果<br>Test for random array,size:200000 range [0, 200000].<br>Merge Sort : 0.053 s<br>Quick sort : 0.031 s<br>Test for nearly ordered array,size:200000, swap time = 100.<br>Merge Sort : 0.024 s<br>Quick sort : 0.018 s<br>Test for random array, size = 200000, random range [0,10]<br>Merge Sort : 0.031 s<br>Quick Sort : 4.616 s</p>
</blockquote>
<p>第三组测试，200000个数据在[0,10]之间，必然包含大量重复元素，此时发现快速排序比归并排序慢了148倍！！</p>
<p>####两路快速排序算法</p>
<p>在有很多重复元素的情况下，也会使得递归的过程变得很不平衡，很容易出现如下图的情况<br><img src="https://img1.sycdn.imooc.com/szimg/593f8a000001124112800720.jpg" alt=""></p>
<p>解决这种问题一个办法是采用<strong>双路快速排序</strong>，就是从数组的左右两边分别往中间的靠</p>
<p>双路快速排序示意图<br><img src="https://img1.sycdn.imooc.com/szimg/593f8e4400015a7112800720.jpg" alt=""><br>清单7 <strong>双路快速排序实现</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUICK_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUICK_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> __partitionQ(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[<span class="built_in">rand</span>()%(r-l<span class="number">+1</span>)+l]);</span><br><span class="line">    T e = a[l];</span><br><span class="line">    <span class="comment">//[l+1,j] &lt; e;[j+1,i) &gt; e</span></span><br><span class="line"><span class="comment">//    int j = l;</span></span><br><span class="line"><span class="comment">//    for(int i = l + 1; i &lt;= r; i++)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        if(a[i] &lt; e)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            j++;</span></span><br><span class="line"><span class="comment">//            swap(a[j], a[i]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    swap(a[l], a[j]);</span></span><br><span class="line">    <span class="comment">//[l+1,i) &lt; e; (j, r] &gt; e</span></span><br><span class="line">    <span class="type">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r &amp;&amp; a[i] &lt; e)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= l<span class="number">+1</span> &amp;&amp; a[j] &gt; e)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __quickSort(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = __partitionQ(a, l, r);</span><br><span class="line">    __quickSort(a, l, p<span class="number">-1</span>);</span><br><span class="line">    __quickSort(a, p<span class="number">+1</span>, r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// QUICK_SORT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="三路快速排序算法"><a href="#三路快速排序算法" class="headerlink" title="三路快速排序算法"></a>三路快速排序算法</h4><p>此外针对有大量重复元素的序列，还有一种<strong>三路快速排序算法</strong>，<br>基本思路是：<br>将arr分为三部分，分别为 arr[l+1… lt] &lt; v, arr[lt+1… i-1] ==v, arr[gt…r] &gt; v三部分，i指向待排元素(e)的位置<br>(1)当i&lt;v时 swap(arr[lt+1], arr[i]) i++, lt++<br>(2)当i&gt;v时 swap(arr[gt-1], arr[i]) gt–<br>(3)当e==v时i++ </p>
<p>示意图如下：<br><img src="https://img1.sycdn.imooc.com/szimg/5aa23ca70001aa3912800720.jpg" alt=""><br>排序后：<br><img src="https://img1.sycdn.imooc.com/szimg/59a7b3f50001581812800720.jpg" alt=""><br>注意需要将v与arr[lt]交换，将v换到中间等于v的区域</p>
<p><strong><em>三路快速排序的好处是如果有大量的重复元素，可以对这些处于中间重复元素不再进行处理，只需要处理两边区域里面的元素即可，可以节约时间</em></strong></p>
<p>清单8 三路快速排序实现<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUICK_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUICK_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3路快速排序</span></span><br><span class="line"><span class="comment">//[l+1， lt] &lt; e</span></span><br><span class="line"><span class="comment">//[gt, r] &gt; e</span></span><br><span class="line"><span class="comment">//[lt+1, i) == e</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __quickSort3Ways(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[<span class="built_in">rand</span>()%(r-l<span class="number">+1</span>)+l]);</span><br><span class="line">    T v = a[l];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lt = l;</span><br><span class="line">    <span class="type">int</span> gt = r + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; gt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[lt<span class="number">+1</span>]);</span><br><span class="line">            lt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i], a[gt<span class="number">-1</span>]);</span><br><span class="line">            gt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[lt]);</span><br><span class="line">    __quickSort3Ways(a, l, lt<span class="number">-1</span>);</span><br><span class="line">    __quickSort3Ways(a, gt, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort3Ways</span><span class="params">(T a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort3Ways(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// QUICK_SORT_H</span></span></span><br></pre></td></tr></table></figure></p>
<p>清单9 测试函数main<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quickSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">300000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;].&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line">    <span class="type">int</span> *arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr, n);</span><br><span class="line"></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr3, n);</span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr3, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr4, n);</span><br><span class="line"><span class="comment">//    //SortTestHelper::printArray(arr4, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 3 ways&quot;</span>, quickSort3Ways, arr, n);</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line"></span><br><span class="line">    n=<span class="number">300000</span>;</span><br><span class="line">    <span class="type">int</span> swaptime=<span class="number">100</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for nearly ordered array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, swap time = &quot;</span>&lt;&lt;swaptime&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr_n1 = SortTestHelper::<span class="built_in">generateNearlySortedArray</span>(n, swaptime);</span><br><span class="line">    <span class="type">int</span> *arr_n2 = SortTestHelper::<span class="built_in">copyArray</span>(arr_n1, n);</span><br><span class="line">    arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr_n1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr_n1, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr3, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr_n2, n);</span><br><span class="line">    <span class="comment">//SortTestHelper::printArray(arr4, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 3 ways&quot;</span>, quickSort3Ways, arr3, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr_n1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr_n2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试3 测试存在包含大量相同元素的数组</span></span><br><span class="line">    <span class="comment">// 使用双快速排序后, 我们的快速排序算法可以轻松的处理包含大量元素的数组</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0,10]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr1, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick Sort&quot;</span>, quickSort, arr2, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick Sort 3 ways&quot;</span>, quickSort3Ways, arr2, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果：</p>
<blockquote>
<p>Test for random array,size:300000 range [0, 300000].<br>Merge Sort : 0.098 s<br>Quick sort : 0.066 s<br>Quick sort 3 ways : 0.057 s<br>Test for nearly ordered array,size:300000, swap time = 100.<br>Merge Sort : 0.042 s<br>Quick sort : 0.031 s<br>Quick sort 3 ways : 0.064 s<br>Test for random array, size = 300000, random range [0,10]<br>Merge Sort : 0.052 s<br>Quick Sort : 0.032 s<br>Quick Sort 3 ways : 0.011 s  </p>
</blockquote>
<p>从上述结果中可以看到，<strong>有大量重复元素时，三路快速排序的性能是很棒的</strong></p>
<p><strong>另外一个优化点，是在递归退出的时候，比如只剩下少量元素时选用插入排序，因为元素很少时，插入排序的性能是很棒的，所以插入排序经常用来优化归并排序和快速排序</strong></p>
<p>清单10 用插入排序优化快速排序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUICK_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUICK_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;insertionSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双路快速排序的partition函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> __partitionQ2(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[<span class="built_in">rand</span>()%(r-l<span class="number">+1</span>)+l]);</span><br><span class="line">    T v = a[l];</span><br><span class="line">    <span class="comment">//[l+1, i) &lt; v (j, r] &gt; v</span></span><br><span class="line">    <span class="type">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r &amp;&amp; a[i] &lt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= l + <span class="number">1</span> &amp;&amp; a[j] &gt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __quickSort(T a[], <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//利用插入排序优化快速排序</span></span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insertionSort</span>(a, l, r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p = __partitionQ2(a, l, r);</span><br><span class="line">    __quickSort(a, l, p<span class="number">-1</span>);</span><br><span class="line">    __quickSort(a, p<span class="number">+1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(T a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    __quickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// QUICK_SORT_H</span></span></span><br></pre></td></tr></table></figure><br>对于 insertionSort(a, l, r)这样子的插入排序本文就省略了，可以参考<a href="https://ahnselina.github.io/插入排序/">插入排序</a>一文自己实现。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[算法（第4版）]</p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2018/04/29/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>本文主要回顾堆排序，主要有如下内容：   </p>
<ol>
<li>优先级队列     </li>
<li>堆及堆的基本实现  </li>
<li>堆排序的实现及优化  </li>
</ol>
<hr>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><strong>普通队列</strong>：先进先出，后进后出；<br><strong>优先级队列</strong>：出队顺序与入队顺序无关，和优先级有关。比如绝大多数手机分配给来电的优先级都会比游戏程序的高。<br>一种合适数据结构应该支持两种操作：<strong><em>删除最大元素（取出优先级最高的元素）</em></strong>和<strong><em>插入元素</em></strong>，这种数据类型叫做优先级队列。</p>
<p><strong>优先级队列的实现</strong>  </p>
<p>优先级队列的具体实现可以用普通数组、顺序数组，还可以用堆，如下图所示：<br><img src="https://img1.sycdn.imooc.com/szimg/593f94f50001904112800720.jpg" alt=""><br>可以看到对于总共N个请求：  </p>
<ul>
<li>使用普通数组或者顺序数组，最差情况时间复杂度为：O( n^2 )</li>
<li>使用堆:O(nlogn)</li>
</ul>
<p><strong>优先队列的应用场景</strong></p>
<ul>
<li>操作系统的任务调度处理（根据任务优先级进行调度）</li>
<li>游戏AI自动攻击在范围内的敌人（比如范围内敌人很多，便可根据优先级队列进行选择:) ） </li>
<li>堆排序<br>….</li>
</ul>
<blockquote>
<p>堆是优先级队列的一种经典实现方法，准确的说，二叉堆是优先级队列的一种经典实现方法，当然也可以用d-叉堆来实现（比如三叉堆）。</p>
</blockquote>
<h3 id="堆及其基本实现"><a href="#堆及其基本实现" class="headerlink" title="堆及其基本实现"></a>堆及其基本实现</h3><p>堆是一种数据结构，其经典实现是二叉堆，二叉堆可以视为一棵完全二叉树，关于完全二叉树请参考<a href="https://www.cnblogs.com/idorax/p/6441043.html">这篇文章</a>。<br><img src="https://img1.sycdn.imooc.com/szimg/5ab9ecc400017bb412800720.jpg" alt=""><br><strong>二叉堆的表示法</strong><br>既然二叉堆是一颗完全二叉树，我们很自然的想到了用指针来构造二叉堆；<br>不过还可以使用数组的索引来表示元素在二叉堆中的位置，如下图：<br><img src="http://images.cnitblog.com/blog/94031/201403/022349569016960.png" alt=""><br>这是二叉堆的一种经典表示法，不使用数组的第一个位置即a[0],那么容易看出：   </p>
<ul>
<li>元素k的父节点所在的位置为[i/2]（向下取整，比如5/2向下取整得2）</li>
<li>元素k的子节点所在的位置为2i和2i+1<br><img src="https://img1.sycdn.imooc.com/szimg/5ad368e40001c41f12800720.jpg" alt=""></li>
</ul>
<p><strong><em>堆有最大堆（有的叫“大顶堆”）最小堆（有的叫“小顶堆”）</em></strong>，二者可以用如下公式进行定义：  </p>
<ul>
<li>最大堆：arr[k] &gt;= arr[2k] &amp;&amp; arr[k] &gt;= arr[2k+1]</li>
<li>最小堆：arr[k] &lt;= arr[2k] &amp;&amp; arr[k] &lt;= arr[2k+1]  </li>
</ul>
<p>本文在后面实现堆排序时，采用最大堆。</p>
<p><strong>堆的基本实现</strong>  </p>
<p>清单1 堆的基本实现<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item* data;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity<span class="number">+1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MaxHeap</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEAP_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="堆排序及其基本实现"><a href="#堆排序及其基本实现" class="headerlink" title="堆排序及其基本实现"></a>堆排序及其基本实现</h3><p> 了解了前面的相关知识后，可以介绍堆排序了，其实就是用来最大堆的特性。<br> 堆排序<strong>基本思想</strong>是:<br>  将待排序序列构造成一个最大堆，此时，整个序列的最大值就是堆顶的根节点，取出根节点后，剩下元素重新构造形成一个最大堆，再取出根节点…如此反复，便能得到一个有序序列了（需要注意这样得到的序列是从大到小的）。</p>
<p><strong>堆排序的基本实现</strong>  </p>
<p>清单2 堆的基本操作实现heap.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxHeap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item* data;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; data[k/<span class="number">2</span>] &lt; data[k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(data[k/<span class="number">2</span>], data[k]);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*k &lt;= count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>(j<span class="number">+1</span> &lt;= count &amp;&amp; data[j<span class="number">+1</span>] &gt; data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(data[k] &gt;= data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(data[k], data[j]);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MaxHeap</span>(<span class="type">int</span> capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[capacity<span class="number">+1</span>];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数, 通过一个给定数组创建一个最大堆</span></span><br><span class="line">    <span class="comment">// 该构造堆的过程, 时间复杂度为O(n)</span></span><br><span class="line">    <span class="built_in">MaxHeap</span>(Item arr[], <span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        data = <span class="keyword">new</span> Item[n<span class="number">+1</span>];</span><br><span class="line">        capacity = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i<span class="number">+1</span>] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        count = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = count/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">shiftDown</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MaxHeap</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(count<span class="number">+1</span> &lt;= capacity);</span><br><span class="line">        data[count<span class="number">+1</span>] = item;</span><br><span class="line">        <span class="built_in">shiftUp</span>(count<span class="number">+1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Item ret = data[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">swap</span>(data[<span class="number">1</span>], data[count]);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="built_in">shiftDown</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEAP_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>清单3 堆排序基本实现heapSort.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序</span></span><br><span class="line"><span class="comment">// 无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn)</span></span><br><span class="line"><span class="comment">// 整个堆排序的整体时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = <span class="built_in">MaxHeap</span>&lt;T&gt;(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxheap.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = maxheap.<span class="built_in">extractMax</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEAP_SORT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>堆排序优化一</strong>  </p>
<p>heapSort1, 将所有的元素依次添加到堆中, 在将所有元素从堆中依次取出来, 即完成了排序,无论是创建堆的过程, 还是从堆中依次取出元素的过程, 时间复杂度均为O(nlogn); 整个堆排序的整体时间复杂度为O(nlogn)。</p>
<p>另一种办法是将数组直接先构造成一个最大堆，然后再从堆中依次取出元素。构造一个最大堆的过程被称为heapify<br><img src="http://img1.sycdn.imooc.com/szimg/5ad77ba800013f8412800720.jpg" alt=""><br>heapify的代码见清单2中“通过一个给定数组创建一个最大堆的构造函数”<br>直接通过数组的方式构造堆，其复杂度为O(n);将n个元素逐个插入空堆中来构造堆，复杂度是O(nlogn)  </p>
<p>清单4 加入优化heapSort2的heapSort.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = <span class="built_in">MaxHeap</span>&lt;T&gt;(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxheap.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = maxheap.<span class="built_in">extractMax</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort2</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = <span class="built_in">MaxHeap</span>&lt;T&gt;(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = maxheap.<span class="built_in">extractMax</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEAP_SORT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>清单5 测试程序<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;selectionSort.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;insertionSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shellSort.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;bubbleSort.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mergeSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quickSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heapSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;].&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr5 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr6 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr7 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr8 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr9 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr10 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;select Sort&quot;, selectionSort, arr1, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertionSort, arr2, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Shell Sort&quot;</span>, shellSort, arr3, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Bubble Sort&quot;, bubbleSort, arr4, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge sort&quot;</span>, mergeSort, arr5, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr6, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 2 Ways&quot;</span>, quickSort2Ways, arr7, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 3 ways&quot;</span>, quickSort3Ways, arr8, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 1&quot;</span>, heapSort1, arr9, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 2&quot;</span>, heapSort2, arr10, n);</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line">    <span class="keyword">delete</span>[] arr5;</span><br><span class="line">    <span class="keyword">delete</span>[] arr6;</span><br><span class="line">    <span class="keyword">delete</span>[] arr7;</span><br><span class="line">    <span class="keyword">delete</span>[] arr8;</span><br><span class="line">    <span class="keyword">delete</span>[] arr9;</span><br><span class="line">    <span class="keyword">delete</span>[] arr10;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试2 近乎有序的数组</span></span><br><span class="line">    n=<span class="number">100000</span>;</span><br><span class="line">    <span class="type">int</span> swaptime=<span class="number">100</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for nearly ordered array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, swap time = &quot;</span>&lt;&lt;swaptime&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    arr1 = SortTestHelper::<span class="built_in">generateNearlySortedArray</span>(n, swaptime);</span><br><span class="line">    arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr5 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr6 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr7 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr8 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr9 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr10 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;select Sort&quot;, selectionSort, arr1, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertionSort, arr2, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Shell Sort&quot;</span>, shellSort, arr3, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Bubble Sort&quot;, bubbleSort, arr4, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr5, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr6, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 2Ways&quot;</span>, quickSort2Ways, arr7, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 3 ways&quot;</span>, quickSort3Ways, arr8, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 1&quot;</span>, heapSort1, arr9, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 2&quot;</span>, heapSort2, arr10, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line">    <span class="keyword">delete</span>[] arr5;</span><br><span class="line">    <span class="keyword">delete</span>[] arr6;</span><br><span class="line">    <span class="keyword">delete</span>[] arr7;</span><br><span class="line">    <span class="keyword">delete</span>[] arr8;</span><br><span class="line">    <span class="keyword">delete</span>[] arr9;</span><br><span class="line">    <span class="keyword">delete</span>[] arr10;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试3 测试存在包含大量相同元素的数组</span></span><br><span class="line">    <span class="comment">// 使用双快速排序后, 我们的快速排序算法可以轻松的处理包含大量元素的数组</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0,10]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr5 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr6 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr7 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr8 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr9 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr10 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;select Sort&quot;, selectionSort, arr1, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Insert Sort&quot;</span>, insertionSort, arr2, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Shell Sort&quot;</span>, shellSort, arr3, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Bubble Sort&quot;, bubbleSort, arr4, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr5, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr6, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 2Ways&quot;</span>, quickSort2Ways, arr7, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 3 ways&quot;</span>, quickSort3Ways, arr8, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 1&quot;</span>, heapSort1, arr9, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 2&quot;</span>, heapSort2, arr10, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line">    <span class="keyword">delete</span>[] arr5;</span><br><span class="line">    <span class="keyword">delete</span>[] arr6;</span><br><span class="line">    <span class="keyword">delete</span>[] arr7;</span><br><span class="line">    <span class="keyword">delete</span>[] arr8;</span><br><span class="line">    <span class="keyword">delete</span>[] arr9;</span><br><span class="line">    <span class="keyword">delete</span>[] arr10;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意测试程序中其他排序排序算法的具体实现请参考前面的文章。<br>运行结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Test for random array,size:100000 range [0, 100000].</span><br><span class="line">Insert Sort : 7.344 s</span><br><span class="line">Shell Sort : 0.02 s</span><br><span class="line">Merge sort : 0.021 s</span><br><span class="line">Quick sort : 0.018 s</span><br><span class="line">Quick sort 2 Ways : 0.016 s</span><br><span class="line">Quick sort 3 ways : 0.02 s</span><br><span class="line">Heap sort 1 : 0.033 s</span><br><span class="line">Heap sort 2 : 0.03 s</span><br><span class="line">Test for nearly ordered array,size:100000, swap time = 100.</span><br><span class="line">Insert Sort : 0.008 s</span><br><span class="line">Shell Sort : 0.004 s</span><br><span class="line">Merge Sort : 0.016 s</span><br><span class="line">Quick sort : 0.012 s</span><br><span class="line">Quick sort 2Ways : 0.008 s</span><br><span class="line">Quick sort 3 ways : 0.021 s</span><br><span class="line">Heap sort 1 : 0.034 s</span><br><span class="line">Heap sort 2 : 0.02 s</span><br><span class="line">Test for random array, size = 100000, random range [0,10]</span><br><span class="line">Insert Sort : 6.6 s</span><br><span class="line">Shell Sort : 0.008 s</span><br><span class="line">Merge Sort : 0.016 s</span><br><span class="line">Quick sort : 1.164 s</span><br><span class="line">Quick sort 2Ways : 0.016 s</span><br><span class="line">Quick sort 3 ways : 0.004 s</span><br><span class="line">Heap sort 1 : 0.028 s</span><br><span class="line">Heap sort 2 : 0.024 s</span><br></pre></td></tr></table></figure><br>可以看到，进行优化后，heapSort2比heapSort1稍微快一点。</p>
<p><strong>堆排序优化二</strong><br>前面的两种方法都是用了额外的最大堆，因此可以直接在原数组上进行原地的堆排序。<br>优化之后的代码见清单6</p>
<p><strong>堆排序优化方法三</strong><br>堆排序shiftDown过程中有许多swap操作，可以像插入排序一样把swap操作优化掉。<br>注意在优化二和优化三中，直接使用了原地排序，也就使用了数组的第一个位置即a[0],那么容易看出：   </p>
<ul>
<li>元素k的父节点所在的位置为[(i-1)/2]（向下取整，比如5/2向下取整得2）</li>
<li>元素k的子节点所在的位置为2i+1和2i+2<br><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png" alt=""></li>
</ul>
<p>清单6 加入原地堆排序的heapSort.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_SORT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_SORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = <span class="built_in">MaxHeap</span>&lt;T&gt;(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxheap.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = maxheap.<span class="built_in">extractMax</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort2</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap&lt;T&gt; maxheap = <span class="built_in">MaxHeap</span>&lt;T&gt;(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = maxheap.<span class="built_in">extractMax</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始的shiftDown过程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __shiftDown1(T arr[], <span class="type">int</span> n, <span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k<span class="number">+1</span> &lt; n )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>*k<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>( j<span class="number">+1</span> &lt; n &amp;&amp; arr[j<span class="number">+1</span>] &gt; arr[j] )</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( arr[k] &gt;= arr[j] )<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>( arr[k] , arr[j] );</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化的shiftDown过程, 使用赋值的方式取代不断的swap,</span></span><br><span class="line"><span class="comment">// 该优化思想和我们之前对插入排序进行优化的思路是一致的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> __shiftDown2(T arr[], <span class="type">int</span> n, <span class="type">int</span> k)&#123;</span><br><span class="line"></span><br><span class="line">    T e = arr[k];</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k<span class="number">+1</span> &lt; n )&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span>*k<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>( j<span class="number">+1</span> &lt; n &amp;&amp; arr[j<span class="number">+1</span>] &gt; arr[j] )</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( e &gt;= arr[j] ) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        arr[k] = arr[j];</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[k] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort3</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，此时我们的堆是从0开始索引的</span></span><br><span class="line">    <span class="comment">// 从(最后一个元素的索引-1)/2开始</span></span><br><span class="line">    <span class="comment">// 最后一个元素的索引 = n-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = (n<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        __shiftDown1(arr, n, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span> ; i-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>( arr[<span class="number">0</span>] , arr[i] );</span><br><span class="line">        __shiftDown1(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用一个额外的最大堆, 直接在原数组上进行原地的堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort4</span><span class="params">(T arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，此时我们的堆是从0开始索引的</span></span><br><span class="line">    <span class="comment">// 从(最后一个元素的索引-1)/2开始</span></span><br><span class="line">    <span class="comment">// 最后一个元素的索引 = n-1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = (n<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i -- )</span><br><span class="line">        __shiftDown2(arr, n, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span> ; i-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>( arr[<span class="number">0</span>] , arr[i] );</span><br><span class="line">        __shiftDown2(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEAP_SORT_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>清单7 测试程序main.cpp<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SortTestHelper.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;selectionSort.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;insertionSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shellSort.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;bubbleSort.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mergeSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;quickSort.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heapSort.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">400000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; range [0, &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;].&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> *arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="type">int</span> *arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr5 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr6 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr7 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr8 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr9 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr10 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr11 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    <span class="type">int</span> *arr12 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;select Sort&quot;, selectionSort, arr1, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr2, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr3, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Bubble Sort&quot;, bubbleSort, arr4, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge sort&quot;</span>, mergeSort, arr5, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr6, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 2 Ways&quot;</span>, quickSort2Ways, arr7, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 3 ways&quot;</span>, quickSort3Ways, arr8, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 1&quot;</span>, heapSort1, arr9, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 2&quot;</span>, heapSort2, arr10, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 3&quot;</span>, heapSort3, arr11, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 4&quot;</span>, heapSort4, arr12, n);</span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line">    <span class="keyword">delete</span>[] arr5;</span><br><span class="line">    <span class="keyword">delete</span>[] arr6;</span><br><span class="line">    <span class="keyword">delete</span>[] arr7;</span><br><span class="line">    <span class="keyword">delete</span>[] arr8;</span><br><span class="line">    <span class="keyword">delete</span>[] arr9;</span><br><span class="line">    <span class="keyword">delete</span>[] arr10;</span><br><span class="line">    <span class="keyword">delete</span>[] arr11;</span><br><span class="line">    <span class="keyword">delete</span>[] arr12;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试2 近乎有序的数组</span></span><br><span class="line">    n=<span class="number">400000</span>;</span><br><span class="line">    <span class="type">int</span> swaptime=<span class="number">100</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for nearly ordered array,size:&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, swap time = &quot;</span>&lt;&lt;swaptime&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    arr1 = SortTestHelper::<span class="built_in">generateNearlySortedArray</span>(n, swaptime);</span><br><span class="line">    arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr5 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr6 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr7 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr8 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr9 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr10 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr11 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr12 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;select Sort&quot;, selectionSort, arr1, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr2, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr3, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Bubble Sort&quot;, bubbleSort, arr4, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr5, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr6, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 2Ways&quot;</span>, quickSort2Ways, arr7, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 3 ways&quot;</span>, quickSort3Ways, arr8, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 1&quot;</span>, heapSort1, arr9, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 2&quot;</span>, heapSort2, arr10, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 3&quot;</span>, heapSort3, arr11, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 4&quot;</span>, heapSort4, arr12, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line">    <span class="keyword">delete</span>[] arr5;</span><br><span class="line">    <span class="keyword">delete</span>[] arr6;</span><br><span class="line">    <span class="keyword">delete</span>[] arr7;</span><br><span class="line">    <span class="keyword">delete</span>[] arr8;</span><br><span class="line">    <span class="keyword">delete</span>[] arr9;</span><br><span class="line">    <span class="keyword">delete</span>[] arr10;</span><br><span class="line">    <span class="keyword">delete</span>[] arr11;</span><br><span class="line">    <span class="keyword">delete</span>[] arr12;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试3 测试存在包含大量相同元素的数组</span></span><br><span class="line">    <span class="comment">// 使用双快速排序后, 我们的快速排序算法可以轻松的处理包含大量元素的数组</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Test for random array, size = &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;, random range [0,10]&quot;</span>&lt;&lt;endl;</span><br><span class="line">    arr1 = SortTestHelper::<span class="built_in">generateRandomArray</span>(n,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    arr2 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr3 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr4 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr5 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr6 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr7 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr8 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr9 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr10 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr11 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line">    arr12 = SortTestHelper::<span class="built_in">copyArray</span>(arr1, n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;select Sort&quot;, selectionSort, arr1, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Insert Sort&quot;, insertionSort, arr2, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Shell Sort&quot;, shellSort, arr3, n);</span></span><br><span class="line"><span class="comment">//    SortTestHelper::testSort(&quot;Bubble Sort&quot;, bubbleSort, arr4, n);</span></span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Merge Sort&quot;</span>, mergeSort, arr5, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort&quot;</span>, quickSort, arr6, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 2Ways&quot;</span>, quickSort2Ways, arr7, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Quick sort 3 ways&quot;</span>, quickSort3Ways, arr8, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 1&quot;</span>, heapSort1, arr9, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 2&quot;</span>, heapSort2, arr10, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 3&quot;</span>, heapSort3, arr11, n);</span><br><span class="line">    SortTestHelper::<span class="built_in">testSort</span>(<span class="string">&quot;Heap sort 4&quot;</span>, heapSort4, arr12, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] arr1;</span><br><span class="line">    <span class="keyword">delete</span>[] arr2;</span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line">    <span class="keyword">delete</span>[] arr4;</span><br><span class="line">    <span class="keyword">delete</span>[] arr5;</span><br><span class="line">    <span class="keyword">delete</span>[] arr6;</span><br><span class="line">    <span class="keyword">delete</span>[] arr7;</span><br><span class="line">    <span class="keyword">delete</span>[] arr8;</span><br><span class="line">    <span class="keyword">delete</span>[] arr9;</span><br><span class="line">    <span class="keyword">delete</span>[] arr10;</span><br><span class="line">    <span class="keyword">delete</span>[] arr11;</span><br><span class="line">    <span class="keyword">delete</span>[] arr12;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Test for random array,size:400000 range [0, 400000].</span><br><span class="line">Merge sort : 0.078 s</span><br><span class="line">Quick sort : 0.079 s</span><br><span class="line">Quick sort 2 Ways : 0.062 s</span><br><span class="line">Quick sort 3 ways : 0.078 s</span><br><span class="line">Heap sort 1 : 0.125 s</span><br><span class="line">Heap sort 2 : 0.123 s</span><br><span class="line">Heap sort 3 : 0.11 s</span><br><span class="line">Heap sort 4 : 0.078 s</span><br><span class="line">Test for nearly ordered array,size:400000, swap time = 100.</span><br><span class="line">Merge Sort : 0.062 s</span><br><span class="line">Quick sort : 0.047 s</span><br><span class="line">Quick sort 2Ways : 0.047 s</span><br><span class="line">Quick sort 3 ways : 0.094 s</span><br><span class="line">Heap sort 1 : 0.125 s</span><br><span class="line">Heap sort 2 : 0.093 s</span><br><span class="line">Heap sort 3 : 0.078 s</span><br><span class="line">Heap sort 4 : 0.063 s</span><br><span class="line">Test for random array, size = 400000, random range [0,10]</span><br><span class="line">Merge Sort : 0.062 s</span><br><span class="line">Quick sort : 17.537 s</span><br><span class="line">Quick sort 2Ways : 0.031 s</span><br><span class="line">Quick sort 3 ways : 0.016 s</span><br><span class="line">Heap sort 1 : 0.094 s</span><br><span class="line">Heap sort 2 : 0.093 s</span><br><span class="line">Heap sort 3 : 0.094 s</span><br><span class="line">Heap sort 4 : 0.063 s</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在N个元素中选出前M个元素，普通队列排序：NlogN;<br> 优先队列：NlogM<br> 堆排序主要用于动态数据的维护。</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[算法（第4版）]<br><a href="https://www.cnblogs.com/idorax/p/6441043.html">完美二叉树, 完全二叉树和完满二叉树</a><br><a href="https://blog.csdn.net/justdoithai/article/details/51525921">经典算法和数据结构(一) 优先级队列与堆排序</a><br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>堆排序</tag>
        <tag>堆</tag>
        <tag>优先级队列</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2018/04/30/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要回顾二分查找，主要有如下内容：   </p>
<ol>
<li>二分查找  </li>
<li>二分查找的非递归实现    </li>
<li>二分查找的递归实现</li>
</ol>
<p>PS:本文仅回顾最基本的二分查找，其实二分查找还有许多其他变形，详细的可以参考文末的参考资料。</p>
<hr>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>查找问题是计算机中最基本最朴素的问题，也非常重要。我们知道要在一个数组中查找一个元素，直接遍历的办法，其时间复杂度为O(n)。那么有没有更快的办法呢？<br>答案是有的，使用二分查找，但是二分查找的使用是有条件的，那便是要求查找的数组或者序列是<strong>有序的</strong>。<br>注意有些地方又把二分查找叫折半查找或者二分搜索。</p>
<hr>
<h3 id="二分查找的非递归实现"><a href="#二分查找的非递归实现" class="headerlink" title="二分查找的非递归实现"></a>二分查找的非递归实现</h3><p>清单1：二分查找的非递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 二分查找法,在有序数组arr中,查找target</span></span><br><span class="line"><span class="comment">// 如果找到target,返回相应的索引index</span></span><br><span class="line"><span class="comment">// 如果没有找到target,返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(T a[], <span class="type">int</span> n, T target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//在[l, r]中查找</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 防止极端情况下的整形溢出，使用下面的逻辑求出mid</span></span><br><span class="line">        <span class="type">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            l = mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有找到target，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二分查找的递归实现"><a href="#二分查找的递归实现" class="headerlink" title="二分查找的递归实现"></a>二分查找的递归实现</h3><p>清单2 二分查找的递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> __binarySearch(T a[], <span class="type">int</span> l, <span class="type">int</span> r, T target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == a[mid])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; a[mid])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __binarySearch(a, l, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __binarySearch(a, mid<span class="number">+1</span>, r, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchR</span><span class="params">(T a[], <span class="type">int</span> n, T target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __binarySearch(a, <span class="number">0</span>, n<span class="number">-1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>二分查找的非递归版本性能上会比递归版本好一些（常数级别的差异）。<br>递归优点：代码简洁清晰，可读性更好<br>递归可读性好这一点，对于初学者可能会反对。实际上递归的代码更清晰，但是从学习的角度要理解递归真正发生的什么，是如何调用的，调用层次和路线，调用堆栈中保存了什么，可能是不容易。但是不可否认递归的代码更简洁。一般来说，一个人可能很容易的写出前中后序的二叉树遍历的递归算法，要写出相应的非递归算法就比较考验水平了，恐怕至少一半的人搞不定。所以说递归代码更简洁明了。<br>递归缺点：由于递归需要系统堆栈，所以空间消耗要比非递归代码要大。而且，如果递归深度太大，系统堆栈可能耗尽，导致程序崩溃。 </p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[算法（第4版）]<br><a href="https://www.cnblogs.com/bofengyu/p/6761389.html">你真的会写二分查找吗？</a> </p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>AWK的一些基本用法</title>
    <url>/2018/05/07/awk/</url>
    <content><![CDATA[<p>AWK是Linux下处理文本经常用到的神器，本文简单总结一些AWK的常见用法。<br>AWK是贝尔实验室1977年搞出来的文本出现神器，之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符。</p>
<ul>
<li>内建变量</li>
<li>常见用法</li>
<li>一个项目中的实例</li>
</ul>
<h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><p>awk常用的内建变量：</p>
<ul>
<li>$0：    当前记录（这个变量中存放着整个行的内容）  </li>
<li>$1~$n：    当前记录的第n个字段，字段间由FS分隔  </li>
<li>FS：    输入字段分隔符 默认是空格或Tab  </li>
<li>NF：    当前记录中的字段个数，就是有多少列  </li>
<li>NR：    已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。  </li>
<li>FNR：    当前记录数，与NR不同的是，这个值会是各个文件自己的行号  </li>
<li>RS：    输入的记录分隔符， 默认为换行符  </li>
<li>OFS：    输出字段分隔符， 默认也是空格  </li>
<li>ORS：    输出的记录分隔符，默认为换行符  </li>
<li>FILENAME：    当前输入文件的名字 </li>
</ul>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>测试文本为test<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local-Address          Foreign-Address             State</span><br><span class="line">tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 test:80        124.205.5.146:18245         TIME_WAIT</span><br><span class="line">tcp        0      0 test:80        61.140.101.185:37538        FIN_WAIT2</span><br><span class="line">tcp        0      0 test:80        110.194.134.189:1032        ESTABLISHED</span><br><span class="line">tcp        0      0 test:80        123.169.124.111:49809       ESTABLISHED</span><br><span class="line">tcp        0      0 test:80        116.234.127.77:11502        FIN_WAIT2</span><br><span class="line">tcp        0      0 test:80        123.169.124.111:49829       ESTABLISHED</span><br><span class="line">tcp        0      0 test:80        183.60.215.36:36970         TIME_WAIT</span><br><span class="line">tcp        0   4166 test:80        61.148.242.38:30901         ESTABLISHED</span><br><span class="line">tcp        0      1 test:80        124.152.181.209:26825       FIN_WAIT1</span><br><span class="line">tcp        0      0 test:80        110.194.134.189:4796        ESTABLISHED</span><br><span class="line">tcp        0      0 test:80        183.60.212.163:51082        TIME_WAIT</span><br><span class="line">tcp        0      1 test:80        208.115.113.92:50601        LAST_ACK</span><br><span class="line">tcp        0      0 test:80        123.169.124.111:49840       ESTABLISHED</span><br><span class="line">tcp        0      0 test:80        117.136.20.85:50025         FIN_WAIT2</span><br><span class="line">tcp        0      0 :::22                  :::*                        LISTEN</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="1-输出文本第1列和第4例"><a href="#1-输出文本第1列和第4例" class="headerlink" title="1. 输出文本第1列和第4例"></a><strong>1. 输出文本第1列和第4例</strong></h5><p>比如文本是test<br>awk ‘{print $1, $4}’ test 或者 cat test | awk ‘{print $1, $4}’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proto Local-Address</span><br><span class="line">tcp 0.0.0.0:3306</span><br><span class="line">tcp 0.0.0.0:80</span><br><span class="line">tcp 127.0.0.1:9000</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp test:80</span><br><span class="line">tcp :::22</span><br></pre></td></tr></table></figure>
<p><strong><em>其中单引号中的被大括号括着的就是awk的语句，注意，其只能被单引号包含</em></strong>  </p>
<h5 id="2-第三列的值为0-amp-amp-第6列的值为LISTEN"><a href="#2-第三列的值为0-amp-amp-第6列的值为LISTEN" class="headerlink" title="2. 第三列的值为0 &amp;&amp; 第6列的值为LISTEN"></a><strong>2. 第三列的值为0 &amp;&amp; 第6列的值为LISTEN</strong></h5><p>awk ‘$3==0 &amp;&amp; $6==”LISTEN” ‘ test<br>或者<br>cat test | awk ‘$3==0 &amp;&amp; $6==”LISTEN”‘</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat test | awk &#x27;$3==0 &amp;&amp; $6==&quot;LISTEN&quot;&#x27;</span><br><span class="line">tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 :::22                  :::*                  </span><br></pre></td></tr></table></figure>
<p><strong>其中的“==”为比较运算符。当然也可以使用其他比较运算符：!=, &gt;, &lt;, &gt;=, &lt;=</strong><br>如果需要第一行的话，我们可以引入内建变量NR：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat test | awk &#x27;$3==0 &amp;&amp; $6==&quot;LISTEN&quot; || NR==1&#x27;</span><br><span class="line">Proto Recv-Q Send-Q Local-Address          Foreign-Address             State</span><br><span class="line">tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN</span><br><span class="line">tcp        0      0 :::22                  :::*                        LISTEN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="排除第一行"><a href="#排除第一行" class="headerlink" title="排除第一行"></a>排除第一行</h5><p>NR == 1表示第一行，所有只需要NR &gt; 1即可排除第一行<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images | awk &#x27;&#123;print $3&#125;&#x27;</span><br><span class="line">IMAGE</span><br><span class="line">3ab9bf2ca2ae</span><br><span class="line">6dcff10458ed</span><br><span class="line">0d9be02372b5</span><br><span class="line">d88ab8e2621d</span><br><span class="line">91edd2ee25bc</span><br><span class="line">78b317f01851</span><br><span class="line">03f0c8e66a3f</span><br><span class="line">5d1c1efa947c</span><br><span class="line">8563f56c190f</span><br><span class="line">81c524fb1f3c</span><br><span class="line">d311f26b1e1f</span><br><span class="line">9cedadac57d9</span><br><span class="line">8624e4df51ea</span><br><span class="line">60950016331f</span><br><span class="line">d57cff1bbe9e</span><br><span class="line">7fb238f56747</span><br><span class="line">5fde56634b93</span><br><span class="line">8d13f4a4b67d</span><br><span class="line">e1fc4e346a21</span><br><span class="line">bb776ce48575</span><br><span class="line">2aef0c7c6a81</span><br><span class="line">566653aecc40</span><br><span class="line">f2cd7c8a619e</span><br><span class="line">31b9460465eb</span><br><span class="line">5a21fbd7ad1c</span><br><span class="line">7edb19ba7ce4</span><br><span class="line">8a651548383b</span><br><span class="line">04ff2f5d7aa0</span><br><span class="line">67ad6ac4aa43</span><br><span class="line">9f38484d220f</span><br><span class="line">9361ce633ff1</span><br><span class="line">fce289e99eb9</span><br><span class="line">fce289e99eb9</span><br><span class="line">fce289e99eb9</span><br><span class="line">9e2c9d5f44ef</span><br><span class="line">466c57ab0dc3</span><br><span class="line">0bf029990080</span><br><span class="line">138bd936fa29</span><br><span class="line">2bef5870dbb0</span><br></pre></td></tr></table></figure><br>排除第一行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images | awk &#x27;&#123; if (NR &gt; 1) print $3&#125;&#x27;</span><br><span class="line">3ab9bf2ca2ae</span><br><span class="line">6dcff10458ed</span><br><span class="line">0d9be02372b5</span><br><span class="line">d88ab8e2621d</span><br><span class="line">91edd2ee25bc</span><br><span class="line">78b317f01851</span><br><span class="line">03f0c8e66a3f</span><br><span class="line">5d1c1efa947c</span><br><span class="line">8563f56c190f</span><br><span class="line">81c524fb1f3c</span><br><span class="line">d311f26b1e1f</span><br><span class="line">9cedadac57d9</span><br><span class="line">8624e4df51ea</span><br><span class="line">60950016331f</span><br><span class="line">d57cff1bbe9e</span><br><span class="line">7fb238f56747</span><br><span class="line">5fde56634b93</span><br><span class="line">8d13f4a4b67d</span><br><span class="line">e1fc4e346a21</span><br><span class="line">bb776ce48575</span><br><span class="line">2aef0c7c6a81</span><br><span class="line">566653aecc40</span><br><span class="line">f2cd7c8a619e</span><br><span class="line">31b9460465eb</span><br><span class="line">5a21fbd7ad1c</span><br><span class="line">7edb19ba7ce4</span><br><span class="line">8a651548383b</span><br><span class="line">04ff2f5d7aa0</span><br><span class="line">67ad6ac4aa43</span><br><span class="line">9f38484d220f</span><br><span class="line">9361ce633ff1</span><br><span class="line">fce289e99eb9</span><br><span class="line">fce289e99eb9</span><br><span class="line">fce289e99eb9</span><br><span class="line">9e2c9d5f44ef</span><br><span class="line">466c57ab0dc3</span><br><span class="line">0bf029990080</span><br><span class="line">138bd936fa29</span><br><span class="line">2bef5870dbb0</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>关于行数的变化就可以使用NR来灵活处理</strong></p>
<h5 id="3-指定分隔符"><a href="#3-指定分隔符" class="headerlink" title="3. 指定分隔符"></a>3. 指定分隔符</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk  &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1,$3,$6&#125;&#x27; /etc/passwd</span><br><span class="line">root 0 /root</span><br><span class="line">bin 1 /bin</span><br><span class="line">daemon 2 /sbin</span><br><span class="line">adm 3 /var/adm</span><br><span class="line">lp 4 /var/spool/lpd</span><br><span class="line">sync 5 /sbin</span><br><span class="line">shutdown 6 /sbin</span><br><span class="line">halt 7 /sbin</span><br></pre></td></tr></table></figure>
<p>上面的命令也等价于：（-F的意思就是指定分隔符）:awk  -F: ‘{print $1,$3,$6}’ /etc/passwd<br><strong><em>如果你要指定多个分隔符，可以这样使用：awk -F ‘[;:]’</em></strong></p>
<h5 id="4-字符串匹配"><a href="#4-字符串匹配" class="headerlink" title="4. 字符串匹配"></a>4. 字符串匹配</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat 1 | awk &#x27;$6 ~ /FIN/ || NR==1 &#123;print NR,$4,$5,$6&#125;&#x27;</span><br><span class="line">1 Local-Address Foreign-Address State</span><br><span class="line">6 test:80 61.140.101.185:37538 FIN_WAIT2</span><br><span class="line">9 test:80 116.234.127.77:11502 FIN_WAIT2</span><br><span class="line">13 test:80 124.152.181.209:26825 FIN_WAIT1</span><br><span class="line">18 test:80 117.136.20.85:50025 FIN_WAIT2</span><br></pre></td></tr></table></figure>
<p><strong>其中NR用于打印出行号</strong>，该示例用于匹配FIN字样状态。<br>~表示模式开始，//中是模式，这就是一个<a href="https://ahnselina.github.io/正则表达式常见用法/">正则表达式</a>的匹配。</p>
<p>其他一些常见用法可以参考耗子叔的<a href="https://coolshell.cn/articles/9070.html">AWK 简明教程</a></p>
<h5 id="一个项目中的实例"><a href="#一个项目中的实例" class="headerlink" title="一个项目中的实例"></a>一个项目中的实例</h5><p>在实际的项目中，经常会用到shell脚本，里面经常会对一些打印做处理，也就有了awk的用武之地: )<br>比如脚本中需要获取打印中的某几列的值，然后根据另一关键字来获取当前想要的值。<br>当然获取某几列的值，其实很简单就是上面介绍的第一种用法。但是由于项目组其他成员经常会改打印，提出要求希望能够在脚本中去获取含有某关键字的值，而不是写死获取某一列。</p>
<p>打印例子存于true.log：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AZ ID| RACK ID| POOL ID| SERVER ID| STORAGE_IP  |</span><br><span class="line">0    |     1  |    0   |       3  | 192.168.0.1 |</span><br><span class="line">0    |     1  |    0   |       3  | 192.168.0.1 |</span><br><span class="line">0    |     1  |    0   |       3  | 192.168.0.1 |</span><br><span class="line">0    |     1  |    0   |       3  | 192.168.0.1 |</span><br><span class="line">0    |     1  |    0   |       5  | 192.168.0.2 |</span><br><span class="line">0    |     1  |    0   |       5  | 192.168.0.2 |</span><br><span class="line">0    |     1  |    0   |       5  | 192.168.0.2 |</span><br><span class="line">0    |     1  |    0   |       5  | 192.168.0.2 |</span><br></pre></td></tr></table></figure>
<p>比如就如上的打印，希望能根据IP获取当前的RACK ID 和 SERVER ID，但不能写死打印1、3、5列。<br>运行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat true.log | awk &#x27;BEGIN&#123;FS=&quot;|&quot;&#125;&#123;for(i=1;i&lt;=NF;i++) &#123;if($i ~ /RACK ID/) n=i;if($i ~ /SERVER ID/) m=i;if($i ~ /STORAGE_IP/) k=i&#125;&#125;&#123;print $n,$m,$k&#125;&#x27;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RACK ID  SERVER ID  STORAGE_IP</span><br><span class="line">    1          3    192.168.0.1</span><br><span class="line">    1          3    192.168.0.1</span><br><span class="line">    1          3    192.168.0.1</span><br><span class="line">    1          3    192.168.0.1</span><br><span class="line">    1          5    192.168.0.2</span><br><span class="line">    1          5    192.168.0.2</span><br><span class="line">    1          5    192.168.0.2</span><br><span class="line">    1          5    192.168.0.2</span><br></pre></td></tr></table></figure>
<p>这样再稍加处理就可以完成任务了: )</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat true.log | awk &#x27;BEGIN&#123;FS=&quot;|&quot;&#125;&#123;for(i=1;i&lt;=NF;i++) &#123;if($i ~ /RACK ID/) n=i;if($i ~ /SERVER ID/) m=i;if($i ~ /STORAGE_IP/) k=i&#125;&#125;&#123;print $n,$m,$k&#125;&#x27; | grep -w &quot;192.168.0.2&quot; | head -1</span><br><span class="line">    1          5    192.168.0.2</span><br></pre></td></tr></table></figure>
<p>这样就能很OK获取到某一节点STORAGE_IP的RACK ID和SERVER ID了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://coolshell.cn/articles/9070.html">AWK 简明教程</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
        <tag>awk</tag>
        <tag>日常积累</tag>
      </tags>
  </entry>
  <entry>
    <title>strace命令用法介绍</title>
    <url>/2018/05/18/strace%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D-/</url>
    <content><![CDATA[<p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间，strace命令能够显示所有在程序中使用的系统调用。</p>
<p>本文主要介绍如下内容：</p>
<ul>
<li>strace能做什么</li>
<li>strace怎么用</li>
<li>strace问题定位案例</li>
</ul>
<hr>
<h3 id="strace能做什么？"><a href="#strace能做什么？" class="headerlink" title="strace能做什么？"></a>strace能做什么？</h3><p>strace作为一种动态跟踪工具，能够帮助运维高效地定位进程和服务故障。它像是一个侦探，通过系统调用的蛛丝马迹，告诉你异常的真相。</p>
<p>先来个例子：<br>假设我们从别的机器copy了个叫做some_server的软件包过来，开发说直接启动就行，啥都不用改。可是尝试启动时却报错，根本起不来！</p>
<p><strong>启动命令：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./some_server ../conf/some_server.conf</span><br></pre></td></tr></table></figure>
<p>输出:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FATAL: InitLogFile failed iRet: -1!</span><br><span class="line">Init error: -1655</span><br></pre></td></tr></table></figure><br>为什么起不来呢？从日志看，是初始化日志文件失败，真相到底怎样呢？我们用strace来看看。</p>
<p>strace -tt -f  ./some_server ../conf/some_server.conf<br>输出:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">23:14:24.448034 open(&quot;/usr/local/apps/some_server/log//server_agent.log&quot;, O_RDWR|O_CREAT|O_APPEND|O_LARGEFILE, 0666) = -1 ENOENT (No such file or directory)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><br>注意到，有个open系统调用，它尝试打开文件/usr/local/apps/some_server/log//server_agent.log来写(若文件不存在则创建)，可是却出错了，返回码是-1, 系统错误号errorno为ENOENT。</p>
<p>搜索ENOENT这个错误号errno的解释:</p>
<blockquote>
<p>ENOENT O_CREAT  is not set and the named file does not exist.  Or, a directory component in pathname does not exist or is a dangling symbolic link.</p>
</blockquote>
<p>这里说得比较清楚，因为我们例子中的open选项指定了O_CREAT选项，这里errno为ENOENT的原因是日志路径中某个部分不存在或者是一个失效的符号链接。我们来一级一级看下路径中的哪部分不存在：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l /usr/local/apps/some_server/log</span><br><span class="line">ls: cannot access /usr/local/apps/some_server/log: No such file or directory</span><br><span class="line">ls -l /usr/local/apps/some_server</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 root users 4096 May 14 23:13 bin</span><br><span class="line">drwxr-xr-x 2 root users 4096 May 14 22:48 conf</span><br></pre></td></tr></table></figure><br>原来是log子目录不存在！上层目录都是存在的。手工创建log子目录后，服务就能正常启动了。</p>
<p>回过头来， strace究竟能做什么呢？</p>
<p><strong><em>它能够打开应用进程的这个黑盒，通过系统调用的线索，告诉你进程大概在干嘛。</em></strong></p>
<hr>
<h3 id="strace怎么用？"><a href="#strace怎么用？" class="headerlink" title="strace怎么用？"></a>strace怎么用？</h3><p>关于系统调用：</p>
<p>按维基百科中的解释，在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。</p>
<p>系统调用提供用户程序与操作系统之间的接口。操作系统的进程空间分为用户空间和内核空间：</p>
<p>操作系统内核直接运行在硬件上，提供设备管理、内存管理、任务调度等功能。<br>用户空间通过API请求内核空间的服务来完成其功能——内核提供给用户空间的这些API, 就是系统调用。<br>在Linux系统上，应用代码通过glibc库封装的函数，间接使用系统调用。</p>
<p>Linux内核目前有300多个系统调用，详细的列表可以通过syscalls手册页查看。这些系统调用主要分为几类：</p>
<blockquote>
<p>文件和设备访问类 比如open/close/read/write/chmod等<br>进程管理类 fork/clone/execve/exit/getpid等<br>信号类 signal/sigaction/kill 等<br>内存管理 brk/mmap/mlock等<br>进程间通信IPC shmget/semget * 信号量，共享内存，消息队列等<br>网络通信 socket/connect/sendto/sendmsg 等<br>其他  </p>
</blockquote>
<p>熟悉Linux系统调用/系统编程，能够让我们在使用strace时得心应手。不过，对于问题定位来说，知道strace这个工具，会查系统调用手册，就差不多够了。</p>
<p>想要深入了解的同学，建议阅读《Linux系统编程》, 《Unix环境高级编程》等书籍。</p>
<p><strong>strace命令参数</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等. </span><br><span class="line">-d 输出strace关于标准错误的调试信息. </span><br><span class="line">-f 跟踪由fork调用所产生的子进程. </span><br><span class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. </span><br><span class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. </span><br><span class="line">-h 输出简要的帮助信息. </span><br><span class="line">-i 输出系统调用的入口指针. </span><br><span class="line">-q 禁止输出关于脱离的消息. </span><br><span class="line">-r 打印出相对时间关于,,每一个系统调用. </span><br><span class="line">-t 在输出中的每一行前加上时间信息. </span><br><span class="line">-tt 在输出中的每一行前加上时间信息,微秒级. </span><br><span class="line">-ttt 微秒级输出,以秒了表示时间. </span><br><span class="line">-T 显示每一调用所耗的时间. </span><br><span class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. </span><br><span class="line">-V 输出strace的版本信息. </span><br><span class="line">-x 以十六进制形式输出非标准字符串 </span><br><span class="line">-xx 所有字符串以十六进制形式输出. </span><br><span class="line">-a column </span><br><span class="line">设置返回值的输出位置.默认 为40. </span><br><span class="line">-e expr </span><br><span class="line">指定一个表达式,用来控制如何跟踪.格式如下: </span><br><span class="line">[qualifier=][!]value1[,value2]... </span><br><span class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如: </span><br><span class="line">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. </span><br><span class="line">注意有些shell使用!来执行历史记录里的命令,所以要使用\\. </span><br><span class="line">-e trace=set </span><br><span class="line">只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. </span><br><span class="line">-e trace=file </span><br><span class="line">只跟踪有关文件操作的系统调用. </span><br><span class="line">-e trace=process </span><br><span class="line">只跟踪有关进程控制的系统调用. </span><br><span class="line">-e trace=network </span><br><span class="line">跟踪与网络有关的所有系统调用. </span><br><span class="line">-e strace=signal </span><br><span class="line">跟踪所有与系统信号有关的 系统调用 </span><br><span class="line">-e trace=ipc </span><br><span class="line">跟踪所有与进程通讯有关的系统调用 </span><br><span class="line">-e abbrev=set </span><br><span class="line">设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. </span><br><span class="line">-e raw=set </span><br><span class="line">将指 定的系统调用的参数以十六进制显示. </span><br><span class="line">-e signal=set </span><br><span class="line">指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. </span><br><span class="line">-e read=set </span><br><span class="line">输出从指定文件中读出 的数据.例如: </span><br><span class="line">-e read=3,5 </span><br><span class="line">-e write=set </span><br><span class="line">输出写入到指定文件中的数据. </span><br><span class="line">-o filename </span><br><span class="line">将strace的输出写入文件filename </span><br><span class="line">-p pid </span><br><span class="line">跟踪指定的进程pid. </span><br><span class="line">-s strsize </span><br><span class="line">指定输出的字符串的最大长度.默认为32.文件名一直全部输出. </span><br><span class="line">-u username </span><br><span class="line">以username 的UID和GID执行被跟踪的命令</span><br></pre></td></tr></table></figure></p>
<p><strong>使用方法</strong><br>strace有两种使用方法：<br>一种是通过它启动要跟踪的进程。用法很简单，在原本的命令前加上strace即可。比如我们要跟踪 “ls -lh /var/log/messages” 这个命令的执行，可以这样：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace ls -lh /var/log/messages</span><br></pre></td></tr></table></figure><br>另外一种运行模式，是跟踪已经在运行的进程，在不中断进程执行的情况下，理解它在干嘛。 这种情况，给strace传递个-p pid 选项即可。<br>比如，有个在运行的some_server服务，第一步，查看pid:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pidof some_server                      </span><br><span class="line">17553</span><br></pre></td></tr></table></figure><br>得到其pid 17553然后就可以用strace跟踪其执行:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace -p 17553</span><br></pre></td></tr></table></figure><br>完成跟踪时，按ctrl + C 结束strace即可</p>
<hr>
<h3 id="strace问题定位案例"><a href="#strace问题定位案例" class="headerlink" title="strace问题定位案例"></a>strace问题定位案例</h3><p><strong>解决库依赖问题</strong><br>starce 的另一个用处是解决和动态库相关的问题。当对一个可执行文件运行ldd时，它会告诉你程序使用的动态库和找到动态库的位置。<br>尽管这样，ldd并不能把所有程序依赖的动态库列出 来，系统调用dlopen可以在需要的时候自动调入需要的动态库，而这些库可能不会被ldd列出来。作为glibc的一部分的NSS（Name Server Switch）库就是一个典型的例子，NSS的一个作用就是告诉应用程序到哪里去寻找系统帐号数据库。应用程序不会直接连接到NSS库，glibc则会通 过dlopen自动调入NSS库。如果这样的库偶然丢失，你不会被告知存在库依赖问题，但这样的程序就无法通过用户名解析得到用户ID了。让我们看一个例子：<br>whoami程序会给出你自己的用户名，这个程序在一些需要知道运行程序的真正用户的脚本程序里面非常有用，whoami的一个示例 输出如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><br>假设因为某种原因在升 级glibc的过程中负责用户名和用户ID转换的库NSS丢失，我们可以通过把nss库改名来模拟这个环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mv</span> /lib/libnss_files.so.2 /lib/libnss_files.so.2.backup</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">whoami</span></span></span><br><span class="line">whoami: cannot find username for UID 0</span><br></pre></td></tr></table></figure>
<p>这里你可以看到，运行whoami时出现了错误，ldd程序的输出不会提供有用的帮助：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ldd /usr/bin/whoami</span><br><span class="line">libc.so.6 =&gt; /lib/libc.so.6 (0x4001f000)</span><br><span class="line">/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</span><br></pre></td></tr></table></figure>
<p>你只会看到whoami依赖Libc.so.6和ld-linux.so.2，它没有给出运行whoami所必须的其他库。这里时用strace跟踪 whoami时的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -o whoami-strace.txt whoami</span><br><span class="line"></span><br><span class="line">open(&quot;/lib/libnss_files.so.2&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/lib/i686/mmx/libnss_files.so.2&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">stat64(&quot;/lib/i686/mmx&quot;, 0xbffff190) = -1 ENOENT (No such file or directory) </span><br><span class="line">open(&quot;/lib/i686/libnss_files.so.2&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">stat64(&quot;/lib/i686&quot;, 0xbffff190) = -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;/lib/mmx/libnss_files.so.2&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">stat64(&quot;/lib/mmx&quot;, 0xbffff190) = -1 ENOENT (No such file or directory) </span><br><span class="line">open(&quot;/lib/libnss_files.so.2&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">stat64(&quot;/lib&quot;, &#123;st_mode=S_IFDIR|0755, st_size=2352, ...&#125;) = 0</span><br><span class="line">open(&quot;/usr/lib/i686/mmx/libnss_files.so.2&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br><span class="line">stat64(&quot;/usr/lib/i686/mmx&quot;, 0xbffff190) = -1 ENOENT (No such file or directory) </span><br><span class="line">open(&quot;/usr/lib/i686/libnss_files.so.2&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br></pre></td></tr></table></figure>
<p>你可以发现在不同目录下面查找libnss.so.2的尝试，但是都失败了。如果没有strace这样的工具，很难发现这个错误是由于缺少动态库造成的。现 在只需要找到libnss.so.2并把它放回到正确的位置就可以了。</p>
<p>除了上述问题，strace还可以用于<br><strong>定位进程异常退出</strong><br><strong>某个命令执行耗时很长</strong><br>笔者曾经在定位问题时就遇到一个命令执行很慢的问题，当时是用rpm命令查询：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa| grep agent</span><br></pre></td></tr></table></figure><br>结果该命令执行很慢，要几秒，明显能感觉到比平时慢了很多。这个时候就可以用strace命令进行分析了。<br>比如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -c rpm -qa| grep agent</span><br></pre></td></tr></table></figure><br>可以看到各个系统调用耗时统计<br>然后看到conect xxx的时候耗时较长，最终发现是/etc/hosts没有配置  </p>
<p>hosts文件可以帮助解决远程登录linux主机过慢问题<br>比如有时候客户端想要远程登录一台linux主机，但每次登录输入密码后都会等很长一段时间才会进入，这是因为linux主机在返回信息时需要解析IP，如果在linux主机的hosts文件事先就加入客户端的IP地址，这时再从客户端远程登录linux就会很快。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://man.linuxde.net/strace?ymnats=iai0l">strace命令</a><br><a href="https://www.linuxidc.com/Linux/2018-01/150654.htm">强大的strace命令用法详解</a><br><a href="https://www.cnblogs.com/fhefh/archive/2011/04/16/2018327.html">Linux错误代码含义/Linux Error Code</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
        <tag>日常积累</tag>
        <tag>strace</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2018/05/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>二叉搜索树有的叫二分搜索树，还有的叫二叉查找树。<br>本文主要回顾二叉搜索树，主要有如下内容：   </p>
<ol>
<li>二叉搜索树的特点及优势  </li>
<li>二叉搜索树的基本操作（插入、查找）   </li>
<li>二叉搜索树的深度优先遍历（前序、中序、后序遍历）  </li>
<li>二叉搜索树的广度优先遍历（层序遍历）  </li>
<li>二叉搜索树删除操作（最小值、最大值、指定节点）</li>
<li>二叉搜索树的顺序性  </li>
<li>二叉搜索树的局限性</li>
<li>总结</li>
</ol>
<hr>
<h3 id="二叉搜索树的特点及优势"><a href="#二叉搜索树的特点及优势" class="headerlink" title="二叉搜索树的特点及优势"></a>二叉搜索树的特点及优势</h3><p>二叉搜索树本质是一棵二叉树，有如下<strong>特点</strong>：</p>
<ul>
<li>每个节点的键值大于左孩子</li>
<li>每个节点的键值小于右孩子</li>
<li>以左右孩子为根的子树仍为二叉搜索树</li>
</ul>
<p>从其特点可以看出，二叉树天然带有递归的特点 ：)<br>注意前面的讲<a href="https://ahnselina.github.io/堆排序/">堆排序</a>中的二叉堆是一个完全二叉树，但是<strong>二叉搜索树不一定是完全二叉树</strong>。</p>
<p>二叉搜索树的优势：</p>
<p>时间复杂度对比<br><img src="https://img1.sycdn.imooc.com/szimg/5abc91b900010e8012800720.jpg" alt=""></p>
<p>不仅可查找数据，还可以高效地插入，删除数据之类的<strong>动态维护数据</strong>。<br>可以方便地回答很多<strong>数据之间的关系问题</strong>：<br>min, max<br>floor, ceil<br>rank<br>select</p>
<hr>
<h3 id="二叉搜索树的基本操作"><a href="#二叉搜索树的基本操作" class="headerlink" title="二叉搜索树的基本操作"></a>二叉搜索树的基本操作</h3><h4 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h4><p>判断node节点是否为空，为空则创建节点并将其返回（ 判断递归到底的情况）。<br>若不为空，则继续判断根元素的key值是否等于根元素的key值： </p>
<ul>
<li>若相等则直接更新value值即可。</li>
<li>若不相等，则根据其大小比较在左孩子或右孩子部分继续递归直至找到合适位置为止。</li>
</ul>
<p>插入操作代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 向二分搜索树中插入一个新的(key, value)数据对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Key key, Value value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        root = <span class="built_in">insert</span>(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* node, Key key, Value value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key == node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">insert</span>(node-&gt;left, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">insert</span>(node-&gt;right, key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉搜索树的查找操作"><a href="#二叉搜索树的查找操作" class="headerlink" title="二叉搜索树的查找操作"></a>二叉搜索树的查找操作</h4><p>理解上面的插入操作之后，查找操作的过程本质是一样的，插入是找到合适的位置插入节点，查找是要找特定key的值。<br>这里直接给出 Value<em> search(Key key)：在二分搜索树中搜索键key所对应的值。如果这个值不存在, 则返回NULL。（注意：这里返回值使用Value</em> ，是为了避免用户查找的值并不存在而出现异常）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在二分搜索树中搜索键key所对应的值。如果这个值不存在, 则返回NULL</span></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Node* node, Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key == node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二叉搜索树的深度优先遍历"><a href="#二叉搜索树的深度优先遍历" class="headerlink" title="二叉搜索树的深度优先遍历"></a>二叉搜索树的深度优先遍历</h3><p><strong>前序遍历</strong>：先访问当前节点，再依次递归访问左右子树<br>可以参考下图进行理解：<br><img src="https://img1.sycdn.imooc.com/szimg/5aeb286400017d2612800720.jpg" alt=""><br>其实在遍历过程中每个节点都访问了3次，对应着这3个小点，顺序为前-&gt; 中 -&gt; 后，只有在“前”点时才会打印该节点元素值即上图中蓝色的点）。</p>
<p><strong>中序遍历</strong>：先递归访问左子树，再访问自身，再递归访问右子树<br>可以参考下图进行理解：<br><img src="https://img1.sycdn.imooc.com/szimg/5ae09a3300013d3112800720.jpg" alt=""><br>在遍历过程中每个节点都访问了3次，对应着这3个小点，顺序为前-&gt; 中 -&gt; 后，只有在“中”点时才会打印该节点元素值（即上图中蓝色的点）。<br>由于二叉搜索树的定义，中序遍历的输出其实是元素从小到大的输出，因此<strong>在进行实际应用时，可使用二叉搜索树的中序遍历将元素按照从小到大顺序输出。</strong></p>
<p><strong>后序遍历</strong>：先递归访问左右子树，再访问自身节点<br>可以参考下图进行理解：<br><img src="https://img1.sycdn.imooc.com/szimg/5ae09bbc0001d94812800720.jpg" alt=""><br>在遍历过程中每个节点都访问了3次，对应着这3个小点，顺序为前-&gt; 中 -&gt; 后，只有在“后”点时才会打印该节点元素值（即上图中蓝色的点）。  </p>
<p>代码实现见清单1.</p>
<hr>
<h3 id="二叉搜索树的广度优先遍历（层序遍历）"><a href="#二叉搜索树的广度优先遍历（层序遍历）" class="headerlink" title="二叉搜索树的广度优先遍历（层序遍历）"></a>二叉搜索树的广度优先遍历（层序遍历）</h3><p>上面提到的前序、中序、后序遍历都属于深度优先遍历，遍历一开始首先会走到最深，再回溯到开始遍历整棵树。<br>而广度优先遍历则是层序遍历，一层一层地向下遍历，其实很好理解，广度优先就是先把当前层都遍历完了才开始下一层，深度优先则是先沿一条路走到底，再回来走其他路 : )<br>二叉搜索树的广度优先遍历的实现，借助了一个队列，首先是先将根节点入队，然后取出队列中第一个节点（也就是根节点），然后分别判断是否有左右子节点，如果有则入队。<br>二叉树的广度优先遍历可以参考下图进行理解：<br><img src="https://img1.sycdn.imooc.com/szimg/5ae1f9560001a4d812800720.jpg" alt=""><br>根节点出队，子节点就入队，根据队列先进先出的性质，就实现了一个广度优先的二分搜索树的遍历。<br>注意：当循环到最底下的时候，因为再没有子节点了，所以最下层的节点全部出队即可。</p>
<hr>
<h3 id="二叉搜索树的删除操作"><a href="#二叉搜索树的删除操作" class="headerlink" title="二叉搜索树的删除操作"></a>二叉搜索树的删除操作</h3><p>删除操作是二叉搜索树中最难的操作，其实查找需要删除的节点和删除本身不难，难的是在待删除节点有左右子树的时候，如何操作才能使删除后整棵树仍然保持二叉搜索树的性质。<br>先来看看简单的情况，删除最小值和最大值。<br><strong>删除最小值</strong><br>删除最小值，根据二叉搜索树的定义或者特点，我们很容易可以得出，其实就是要删除最左边的节点；<br>也就是从根节点开始递归的往左子树寻找，直到某一个节点的左子树为空，那么该节点就是最小的节点了,那么该节点可能有右节点，也可能没有右节点；当该节点有右节点时，需要把右节点返回。<br>注意下面代码中的待删除节点的右节点可能是为空的，不过这并不影响，正好两种情况都包含在内。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            root = <span class="built_in">removeMin</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* rightNode = node-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;left = <span class="built_in">removeMin</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><strong>删除最大值</strong>则是往右子树递归到最右边即可，在此省略</p>
<p>其实通过描述，也可以发现，这两个地方可以不用递归的方式实现，有兴趣的读者可以试试用非递归的方式实现: )</p>
<p><strong>删除指定节点</strong></p>
<p>如果待删除节点只有1个孩子节点或者没有孩子节点，那么删除该节点操作与删除最大值最小值的操作无异，在删除该节点之后，其孩子节点可以顶替。<br>我们需要真正考虑的是，如果待删除节点有左右孩子节点（有左右子树）时要如何操作。<br>幸运的是，这个难题前人Hubbard已经帮我们解决了，其实当有左右孩子时需要找合适的节点来替代当前节点，使得整棵二叉搜索树性质不变。<br>Hubbard认为替代删除节点的合适节点是待删除节点的右子树中最小节点。因此，整个过程可以总结为首先寻找待删除节点的后继节点（右子树中的最小值），由后继节点代替待删除节点即可。该算法也被叫做Hubbard Deletion算法。</p>
<p>删除节点过程可以参考下图进行理解  </p>
<p><img src="https://img1.sycdn.imooc.com/szimg/58fb523a00014d5612800720.jpg" alt=""><br><img src="https://img1.sycdn.imooc.com/szimg/5ae4901600013bc912800720.jpg" alt=""><br>如图，59便是s节点，也是d节点的后继节点<br><img src="https://img1.sycdn.imooc.com/szimg/5ae490f30001fdb512800720.jpg" alt=""><br>代码见清单1.</p>
<hr>
<h3 id="二叉搜索树的顺序性"><a href="#二叉搜索树的顺序性" class="headerlink" title="二叉搜索树的顺序性"></a>二叉搜索树的顺序性</h3><p>除了上面提到的二叉搜索树的各种操作，大部分情况将二叉搜索树当作查找表来实现，主要关注的是如何查找一个key对应的value值，同时完成插入、删除、查找、遍历所有元素等操作。<br>注意二叉搜索树还有一个重要的特征：顺序性，也就是说不仅可以在二分搜索树中定位一个元素，还可以回答其顺序性相关的问题：<br>minimum , maximum：已经实现，非常容易可在一组数据中找到最小、大值。<br>successor , predecessor：待实现，可找到一个元素的前驱节点和后继节点。<br>floor , ceil：待实现<br>rank<br>select<br>感兴趣的读者可以尝试自行实现: )</p>
<h3 id="二叉搜索树的局限性"><a href="#二叉搜索树的局限性" class="headerlink" title="二叉搜索树的局限性"></a>二叉搜索树的局限性</h3><p>二叉搜索树的局限性来源于在特殊情况下，二叉搜索树可能会退化成链表，其查找过程是与其高度相关，此时高度为n，时间复杂度为O(n)。<br>比如：下图所示，同样的数据，可以对应不同的二分搜索树。<br><img src="https://img1.sycdn.imooc.com/szimg/5aeb26b500012a1512800720.jpg" alt=""></p>
<p>需要注意的是，二叉搜索树退化成链表后，但是在实现操作过程中还是有左孩子的概念，所以需要一直判断左孩子为空的情况，并且BST采用递归方式实现，其中的入栈出栈操作也会耗费一些时间，所以此时的二叉搜索树通常性能会比直接用链表性能要慢。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来说二叉搜索树性能还是不错的，也很常用，需要掌握其各种操作。<br>关于二叉搜索树退化成链表的情况还是有解决办法的，可以改造二叉树的实现，使得其无法退化成链表，通常采用平衡二叉树，它有左右两棵子树，并且其高度差不会超过1，因此可以保证其高度一定是 logn 级别的，此概念的经典实现就是红黑树。 </p>
<p>清单1 二叉搜索树的具体实现(包含上文的各种操作及测试程序)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node* left;</span><br><span class="line">        Node* right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(Key key, Value value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(Node *node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;key = node-&gt;key;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value = node-&gt;value;</span><br><span class="line">            <span class="keyword">this</span>-&gt;left = node-&gt;left;</span><br><span class="line">            <span class="keyword">this</span>-&gt;right = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Node* root;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BST</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">BST</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Key key, Value value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        root = <span class="built_in">insert</span>(root, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contain</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">contain</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">preOrder</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            Node* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;node-&gt;key&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Key <span class="title">minimum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(count != <span class="number">0</span>);</span><br><span class="line">        Node* minNode = <span class="built_in">minimum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> minNode-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Key <span class="title">maxmum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(count != <span class="number">0</span>);</span><br><span class="line">        Node * maxNode = <span class="built_in">maxmum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxNode-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            root = <span class="built_in">removeMin</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">           root = <span class="built_in">removeMax</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="built_in">remove</span>(root, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* node, Key key, Value value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key == node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">insert</span>(node-&gt;left, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">insert</span>(node-&gt;right, key, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contain</span><span class="params">(Node* node, Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key == node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">contain</span>(node-&gt;left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">contain</span>(node-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Node* node, Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key == node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">search</span>(node-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != node)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;node-&gt;key&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">preOrder</span>(node-&gt;left);</span><br><span class="line">            <span class="built_in">preOrder</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">inOrder</span>(node-&gt;left);</span><br><span class="line">            cout&lt;&lt;node-&gt;key&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">inOrder</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">postOrder</span>(node-&gt;left);</span><br><span class="line">            <span class="built_in">postOrder</span>(node-&gt;right);</span><br><span class="line">            cout&lt;&lt;node-&gt;key&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> != node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">destroy</span>(node-&gt;left);</span><br><span class="line">            <span class="built_in">destroy</span>(node-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">minimum</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">minimum</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* rightNode = node-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;left = <span class="built_in">removeMin</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">removeMax</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* leftNode = node-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;right = <span class="built_in">removeMax</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">remove</span><span class="params">(Node* node, Key key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(key &lt; node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">remove</span>(node-&gt;left, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; node-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">remove</span>(node-&gt;right, key);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//key == node-&gt;key</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* rightNode = node-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                count--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* leftNode = node-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                count--;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//node-&gt;left != NULL &amp;&amp; node-&gt;right != NULL</span></span><br><span class="line">            Node* successor = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">minimum</span>(node-&gt;right));</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">            successor-&gt;right = <span class="built_in">removeMin</span>(node-&gt;right);</span><br><span class="line">            successor-&gt;left = node-&gt;left;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shuffle</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">rand</span>()%(i<span class="number">+1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    BST&lt;<span class="type">int</span>, <span class="type">int</span>&gt; bst = <span class="built_in">BST</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> key = <span class="built_in">rand</span>()%n;</span><br><span class="line">        <span class="type">int</span> value = key;</span><br><span class="line">        bst.<span class="built_in">insert</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> order[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        order[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shuffle</span>(order, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bst.<span class="built_in">contain</span>(order[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            bst.<span class="built_in">remove</span>(order[i]);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;After remove &quot;</span>&lt;&lt;order[i]&lt;&lt;<span class="string">&quot; size = &quot;</span>&lt;&lt;bst.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;bst.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[算法（第4版）]<br><a href="https://blog.csdn.net/itermeng/article/details/77763237">挖掘算法中的数据结构（七）：二分搜索树（删除、广度优先遍历、顺序性）及 衍生算法问题</a><br><a href="https://blog.csdn.net/itermeng/article/details/77737480">可以看这篇文章的动图演示</a></p>
]]></content>
      <categories>
        <category>重温数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码阅读--简单动态字符串SDS</title>
    <url>/2018/05/20/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB--%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</url>
    <content><![CDATA[<p>从5.20开始开一个新坑，嗯，520是个好的开始呢。“Redis源码阅读”主要解读阅读Redis源码的理解，阅读的源码版本不是最新的，慢慢来 手动斜眼笑&lt;-_&lt;-</p>
<p>本文主要介绍如下内容：</p>
<ul>
<li>简单动态字符串SDS</li>
<li>SDS的优点</li>
<li>SDS API</li>
<li>sds.c部分函数节选</li>
</ul>
<hr>
<h3 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h3><p>Redis中使用了一个叫SDS（simple dynamic string）的字符串,其关键定义如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型别名，用于指向 sdshdr 的 buf 属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>初一看表示这不还是char *，这是坑爹呢，阅读了sds.h和sds.c文件后，发现事情并没有这表面看起来那么简单，嗯，作者是在下一盘很大的棋&lt;-_&lt;-</p>
<p>但我们仔细想想C语言传统的字符串就知道一些端倪了，传统的字符串用起来总感觉好像有点别扭，使用的时候没有python之类的字符串方便好用&lt;-_&lt;-</p>
<p>对于SDS，我们需要注意sds是指向了结构体中buf的这个空间的，只要记住了这点，我们看到如下的函数就不会表示奇怪了<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回 sds 实际保存的字符串的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdslen</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此外，还需要留意，结构体sdshdr中还有len和free两个字段，分别表示sds的目前已经占用的空间的长度和剩余空间的长度。<br>其中char buf[]可以参考<a href="https://blog.csdn.net/encourage2011/article/details/51971509">零长度数组</a></p>
<h3 id="SDS的优点"><a href="#SDS的优点" class="headerlink" title="SDS的优点"></a>SDS的优点</h3><ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串时所需的内存重分配次数</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>
<p>这些优点都是相对于C字符串而言的：<br><strong>常数复杂度获取字符串长度</strong><br>这个很好理解，因为sdshdr结构中就已经有了长度len表示字符串长度，所以直接获取即可，时间复杂度为常数O(1)。</p>
<p><strong>杜绝缓冲区溢出</strong><br>C字符串本身不记录自身长度，比较容易出现缓冲区溢出（buffer overflow）问题。比如\&lt;string.h>中的strcat函数可以将src字符串的内容拼接到dest字符串的末尾：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><br>如果dest的剩余空间不足以容纳src，那么就会产生缓冲区溢出。</p>
<p><strong>减少修改字符串时所需的内存重分配次数</strong><br>直接看sdsMakeRoomFor这个API代码一目了然: )<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsMakeRoomFor</span><span class="params">(sds s, <span class="type">size_t</span> addlen)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="type">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="type">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>二进制安全</strong><br>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。Redis中二进制安全请参考：<br><a href="https://www.cnblogs.com/Alight/p/4123043.html">二进制安全是什么意思?</a></p>
<h3 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h3><p>详情请参考Redis的sds.h文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SDS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SDS_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_MAX_PREALLOC (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdslen</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdsavail</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdsnewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span>;<span class="comment">//创建一个指定长度的sds，接受一个指定的C字符串作为初始化值</span></span><br><span class="line">sds <span class="title function_">sdsnew</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init)</span>;<span class="comment">//根据给定的C字符串，创建一个相应的sds</span></span><br><span class="line">sds <span class="title function_">sdsempty</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">////创建一个只包含空字符串””的sds</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">sdslen</span><span class="params">(<span class="type">const</span> sds s)</span>;</span><br><span class="line">sds <span class="title function_">sdsdup</span><span class="params">(<span class="type">const</span> sds s)</span>;<span class="comment">//复制给定的sds</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsfree</span><span class="params">(sds s)</span>;<span class="comment">//释放给定的sds</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">sdsavail</span><span class="params">(<span class="type">const</span> sds s)</span>;</span><br><span class="line">sds <span class="title function_">sdsgrowzero</span><span class="params">(sds s, <span class="type">size_t</span> len)</span>;<span class="comment">//将给定的sds扩展到指定的长度，空余的部分用\0进行填充</span></span><br><span class="line">sds <span class="title function_">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span>;将一个C字符串追加到给定的sds对应sdshdr的buf</span><br><span class="line">sds <span class="title function_">sdscat</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t)</span>;</span><br><span class="line">sds <span class="title function_">sdscatsds</span><span class="params">(sds s, <span class="type">const</span> sds t)</span>;</span><br><span class="line">sds <span class="title function_">sdscpylen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t, <span class="type">size_t</span> len)</span>;<span class="comment">//将一个C字符串复制到sds中，需要依据sds的总长度来判断是否需要扩展</span></span><br><span class="line">sds <span class="title function_">sdscpy</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t)</span>;</span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdscatvprintf</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">sds <span class="title function_">sdscatprintf</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">    __<span class="title function_">attribute__</span><span class="params">((format(<span class="built_in">printf</span>, <span class="number">2</span>, <span class="number">3</span>)))</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">sds <span class="title function_">sdscatprintf</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdscatfmt</span><span class="params">(sds s, <span class="type">char</span> <span class="type">const</span> *fmt, ...)</span>;</span><br><span class="line">sds <span class="title function_">sdstrim</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *cset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsrange</span><span class="params">(sds s, <span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsupdatelen</span><span class="params">(sds s)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsclear</span><span class="params">(sds s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sdscmp</span><span class="params">(<span class="type">const</span> sds s1, <span class="type">const</span> sds s2)</span>;</span><br><span class="line">sds *<span class="title function_">sdssplitlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> len, <span class="type">const</span> <span class="type">char</span> *sep, <span class="type">int</span> seplen, <span class="type">int</span> *count)</span>;<span class="comment">//对给定的字符串s按照给定的sep分隔字符串来进行切割</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sdstolower</span><span class="params">(sds s)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sdstoupper</span><span class="params">(sds s)</span>;</span><br><span class="line">sds <span class="title function_">sdsfromlonglong</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span>;</span><br><span class="line">sds <span class="title function_">sdscatrepr</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *p, <span class="type">size_t</span> len)</span>;</span><br><span class="line">sds *<span class="title function_">sdssplitargs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> *argc)</span>;</span><br><span class="line">sds <span class="title function_">sdsmapchars</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *from, <span class="type">const</span> <span class="type">char</span> *to, <span class="type">size_t</span> setlen)</span>;</span><br><span class="line">sds <span class="title function_">sdsjoin</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> argc, <span class="type">char</span> *sep)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level functions exposed to the user API */</span></span><br><span class="line">sds <span class="title function_">sdsMakeRoomFor</span><span class="params">(sds s, <span class="type">size_t</span> addlen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsIncrLen</span><span class="params">(sds s, <span class="type">int</span> incr)</span>;</span><br><span class="line">sds <span class="title function_">sdsRemoveFreeSpace</span><span class="params">(sds s)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">sdsAllocSize</span><span class="params">(sds s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="sds-c部分函数节选"><a href="#sds-c部分函数节选" class="headerlink" title="sds.c部分函数节选"></a>sds.c部分函数节选</h3><p>sds sdsnewlen(const void *init, size_t initlen);用指定的指针和长度创建一个新的sds，带注释的源码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsnewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an empty (zero length) sds string. Even in this case the string</span></span><br><span class="line"><span class="comment"> * always has an implicit null term. */</span></span><br><span class="line">sds <span class="title function_">sdsempty</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Create a new sds string starting from a null termined C string. */</span></span><br><span class="line">sds <span class="title function_">sdsnew</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>sdscatlen将t中长度为len的内容添加到s的后面<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Append the specified binary-safe string pointed by &#x27;t&#x27; of &#x27;len&#x27; bytes to the</span></span><br><span class="line"><span class="comment"> * end of the specified sds string &#x27;s&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line">sds <span class="title function_">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="type">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sdstrim对sds左右两端进行修剪，清除其中cset指定的所有字符<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove the part of the string from left and from right composed just of</span></span><br><span class="line"><span class="comment"> * contiguous characters found in &#x27;cset&#x27;, that is a null terminted C string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;AA...AA.a.aa.aHelloWorld     :::&quot;);</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,&quot;A. :&quot;);</span></span><br><span class="line"><span class="comment"> * printf(&quot;%s\n&quot;, s);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Output will be just &quot;Hello World&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">sds <span class="title function_">sdstrim</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *cset)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="type">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</span><br><span class="line">    sh-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sdsjoin把参数argv的个字符串拼接起来，并且每个字符串之间用sep隔开<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Join an array of C strings using the specified separator (also a C string).</span></span><br><span class="line"><span class="comment"> * Returns the result as an sds string. */</span></span><br><span class="line">sds <span class="title function_">sdsjoin</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> argc, <span class="type">char</span> *sep)</span> &#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        join = sdscat(join, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscat(join,sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，关于SDS就介绍这么多，有兴趣的读者去读源码哦:)</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="">Redis设计与实现</a><br><a href="https://blog.csdn.net/acceptedxukai/article/details/17482611">Redis内部数据结构详解之简单动态字符串(sds)</a><br><a href="https://blog.csdn.net/sunnyyoona/article/details/39118465">sizeof与strlen的区别</a><br><a href="https://blog.csdn.net/u012005313/article/details/52122077">C stdarg.h的使用</a><br><a href="https://blog.csdn.net/hpu11/article/details/53326609"><br>c语言中__attribute__的意义</a><br><a href="https://www.cnblogs.com/Cccarl/p/7215515.html?utm_source=itdadao&amp;utm_medium=referral">gcc中预定义的宏<strong>GNUC</strong></a><br><a href="https://blog.csdn.net/u012567219/article/details/15028419">vsnprintf函数用法</a><br><a href="https://blog.csdn.net/li_ning_/article/details/51418400">memmove 和 memcpy的区别以及处理内存重叠问题</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Key-Value存储系统</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码阅读--双向链表</title>
    <url>/2018/05/24/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB--%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>Redis的双向链表基本实现在源码adlist.h和adlist.c中，非常简洁经典，值得一读，很多实现都是链表常见的且非常经典的实现方式，在我们写代码的时候也值得借鉴。<br>本文主要介绍如下内容：</p>
<ul>
<li>Redis双向链表的实现及特点</li>
<li>Redis双向链表源码展示</li>
</ul>
<hr>
<h3 id="Redis双向链表的实现及特点"><a href="#Redis双向链表的实现及特点" class="headerlink" title="Redis双向链表的实现及特点"></a>Redis双向链表的实现及特点</h3><p>Redis双向链表实现的基本数据结构如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>listNode表示链表中的节点，每个节点都有两个指针，分别指向前一个节点和后一个节点，节点的值存放于void *的指针中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure><br>listIter是访问链表的迭代器, 指针(next)指向链表的某个结点, direction表示迭代访问的方向(宏AL_START_HEAD表示向前,AL_START_TAIL表示向后)。<br>该迭代器的经典用法如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line"><span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">listReleaseIterator(iter);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>Redis的双向链表通过list定义, head、tail两个指针分别指向头部的结点和尾部的结点；<br>三个函数指针, 供用户传入自定义函数, 用于复制(dup)、释放(free)和匹配(match)链表中的结点的值(value); 通过无符号长整数len, 表明链表的长度。</p>
<p>通过以上介绍，可以总结出Redis双向链表的如下特性：</p>
<ul>
<li>双向，链表每个节点都带有prev和next指针，获取某一个节点的前置节点和后置节点的复杂度都是O(1)</li>
<li>无环，链表的首节点prev指针和表尾节点next指针都指向NULL</li>
<li>带表头指针和表尾指针，使得访问表头节点和表尾节点的时间复杂度均为O(1)</li>
<li>带链表长度计数器len，使得获取链表长度的时间复杂度为O(1)</li>
<li>多态，链表节点使用void *指针来保存节点的值，链表可以用于保存各种类型的值</li>
</ul>
<h3 id="Redis双向链表源码展示"><a href="#Redis双向链表源码展示" class="headerlink" title="Redis双向链表源码展示"></a>Redis双向链表源码展示</h3><p>本部分源码阅读难度：易<br>只要学过C语言，知道链表操作就能看懂。<br>所以不多解释，直接上源码 &lt;-_-</p>
<p>头文件adlist.h<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ADLIST_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ADLIST_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prototypes */</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *value)</span>;</span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *value)</span>;</span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="type">void</span> *value, <span class="type">int</span> after)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span>;</span><br><span class="line">listIter *<span class="title function_">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">int</span> direction)</span>;</span><br><span class="line">listNode *<span class="title function_">listNext</span><span class="params">(listIter *iter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listReleaseIterator</span><span class="params">(listIter *iter)</span>;</span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span>;</span><br><span class="line">listNode *<span class="title function_">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *key)</span>;</span><br><span class="line">listNode *<span class="title function_">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">long</span> index)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_TAIL 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ADLIST_H__ */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>文件adlist.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;adlist.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zmalloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new list. The created list can be freed with</span></span><br><span class="line"><span class="comment"> * AlFreeList(), but private value of every node need to be freed</span></span><br><span class="line"><span class="comment"> * by the user before to call AlFreeList().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned. Otherwise the pointer to the new list. */</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listCreate</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free the whole list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can&#x27;t fail. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new node to the list, to head, containing the specified &#x27;value&#x27;</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the &#x27;list&#x27; pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add a new node to the list, to tail, containing the specified &#x27;value&#x27;</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the &#x27;list&#x27; pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="type">void</span> *value, <span class="type">int</span> after)</span> &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove the specified node from the specified list.</span></span><br><span class="line"><span class="comment"> * It&#x27;s up to the caller to free the private value of the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can&#x27;t fail. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns a list iterator &#x27;iter&#x27;. After the initialization every</span></span><br><span class="line"><span class="comment"> * call to listNext() will return the next element of the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can&#x27;t fail. */</span></span><br><span class="line">listIter *<span class="title function_">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">int</span> direction)</span></span><br><span class="line">&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Release the iterator memory */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listReleaseIterator</span><span class="params">(listIter *iter)</span> &#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an iterator in the list private iterator structure */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> &#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> &#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the next element of an iterator.</span></span><br><span class="line"><span class="comment"> * It&#x27;s valid to remove the currently returned element using</span></span><br><span class="line"><span class="comment"> * listDelNode(), but not to remove other elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns a pointer to the next element of the list,</span></span><br><span class="line"><span class="comment"> * or NULL if there are no more elements, so the classical usage patter</span></span><br><span class="line"><span class="comment"> * is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * iter = listGetIterator(list,&lt;direction&gt;);</span></span><br><span class="line"><span class="comment"> * while ((node = listNext(iter)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     doSomethingWith(listNodeValue(node));</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">listNode *<span class="title function_">listNext</span><span class="params">(listIter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Duplicate the whole list. On out of memory NULL is returned.</span></span><br><span class="line"><span class="comment"> * On success a copy of the original list is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &#x27;Dup&#x27; method set with listSetDupMethod() function is used</span></span><br><span class="line"><span class="comment"> * to copy the node value. Otherwise the same pointer value of</span></span><br><span class="line"><span class="comment"> * the original node is used as value of the copied node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The original list both on success or error is never modified. */</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search the list for a node matching a given key.</span></span><br><span class="line"><span class="comment"> * The match is performed using the &#x27;match&#x27; method</span></span><br><span class="line"><span class="comment"> * set with listSetMatchMethod(). If no &#x27;match&#x27; method</span></span><br><span class="line"><span class="comment"> * is set, the &#x27;value&#x27; pointer of every node is directly</span></span><br><span class="line"><span class="comment"> * compared with the &#x27;key&#x27; pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success the first matching node pointer is returned</span></span><br><span class="line"><span class="comment"> * (search starts from head). If no matching node exists</span></span><br><span class="line"><span class="comment"> * NULL is returned. */</span></span><br><span class="line">listNode *<span class="title function_">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    iter = listGetIterator(<span class="built_in">list</span>, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the element at the specified zero-based index</span></span><br><span class="line"><span class="comment"> * where 0 is the head, 1 is the element next to head</span></span><br><span class="line"><span class="comment"> * and so on. Negative integers are used in order to count</span></span><br><span class="line"><span class="comment"> * from the tail, -1 is the last element, -2 the penultimate</span></span><br><span class="line"><span class="comment"> * and so on. If the index is out of range NULL is returned. */</span></span><br><span class="line">listNode *<span class="title function_">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rotate the list removing the tail node and inserting it to the head. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/antirez/redis/releases/tag/3.0.6">Redis源码3.0.6</a><br><a href="http://redissrc.readthedocs.io/en/latest/datastruct/adlist.html">双向链表(adlist.h/adlist.c)</a>  </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Key-Value存储系统</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码阅读--字典</title>
    <url>/2018/05/27/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB--%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<p>字典被广泛应用于实现Redis的各种功能，其中包括数据库和哈希键。<br>字典，又称符号表（symbol table）、关联数组（associative array）或者映射(map<br>)，是一种用来保存键值对（key-value pair）的抽象数据结构。<br>本文主要介绍如下内容：</p>
<ul>
<li>Redis字典的实现及特点</li>
<li>Redis字典源码难点分析</li>
<li>Redis字典源码部分节选</li>
</ul>
<hr>
<h3 id="Redis字典的实现及特点"><a href="#Redis字典的实现及特点" class="headerlink" title="Redis字典的实现及特点"></a>Redis字典的实现及特点</h3><p>Redis的数据库就是使用字典作为底层实现的，堆数据库的增删查改操作也是构建在对字典的操作之上的。<br>字典还是哈希键的底层实现之一： 当一个哈希键包含的键值对比较多， 又或者键值对中的元素都是比较长的字符串时， Redis 就会使用字典作为哈希键的底层实现。</p>
<p>举个例子， website 是一个包含 10086 个键值对的哈希键， 这个哈希键的键都是一些数据库的名字， 而键的值就是数据库的主页网址：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">HLEN website</span></span><br><span class="line">(integer) 10086</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">HGETALL website</span></span><br><span class="line">1) &quot;Redis&quot;</span><br><span class="line">2) &quot;Redis.io&quot;</span><br><span class="line">3) &quot;MariaDB&quot;</span><br><span class="line">4) &quot;MariaDB.org&quot;</span><br><span class="line">5) &quot;MongoDB&quot;</span><br><span class="line">6) &quot;MongoDB.org&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">...</span></span><br></pre></td></tr></table></figure><br>website 键的底层实现就是一个字典， 字典中包含了 10086 个键值对：</p>
<p>其中一个键值对的键为 “Redis” ， 值为 “Redis.io”;<br>另一个键值对的键为 “MariaDB” ， 值为 “MariaDB.org” ；<br>还有一个键值对的键为 “MongoDB” ， 值为 “MongoDB.org” ；<br>诸如此类。</p>
<h4 id="具体实现（数据结构）"><a href="#具体实现（数据结构）" class="headerlink" title="具体实现（数据结构）"></a>具体实现（数据结构）</h4><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，每个哈希表节点就保存了字典中的一个键值对。</p>
<p>哈希表节点：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><br>dictEntry结构中key保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或是一个uint64_t 整数，或是一个 int64_t 整数，亦或是一个double类型整数。<br>next是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。Redis是用链地址法(separate chaining)来解决键冲突的，可以参考解决键冲突的多种方法：<a href="https://www.cnblogs.com/gavanwanggw/p/7307596.html">哈希表——线性探測法、链地址法、查找成功、查找不成功的平均长度</a>。</p>
<p>哈希表：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><br>dictht结构中table是一个数组，数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个dictEntry结构保存着一个键值对。<br>size则记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。<br>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。<br>下图便是一个空的哈希表<br><img src="http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png" alt=""></p>
<p>字典结构如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><br>字典结构图示如下：<br><img src="http://redissrc.readthedocs.io/en/latest/_images/graphviz-110ef3a81e3eb42cc35756d79a3f6280470c12f7.png" alt=""><br>Redis字典结构中使用2个哈希表，主要是为了方便进行rehash。在没有进行rehash时，使用的是ht[0]；在 rehash 进行时， 才会同时使用 0 号和 1 号哈希表。dictType主要是方便指定对于key复制函数，value复制函数，key比较函数，key释放函数，value释放函数。</p>
<h5 id="Redis字典的特点"><a href="#Redis字典的特点" class="headerlink" title="Redis字典的特点"></a>Redis字典的特点</h5><ul>
<li>Redis字典的底层实现为哈希表</li>
<li>每个字典使用两个哈希表， 一般情况下只使用 0 号哈希表， 只有在 rehash 进行时， 才会同时使用 0 号和 1 号哈希表</li>
<li>哈希表使用链地址法来解决键冲突的问题</li>
<li>自动 Rehash 扩展或收缩哈希表</li>
<li>对哈希表的 rehash 是分多次、渐进式地进行的(防止rehash时间太长，对上层造成阻塞)</li>
</ul>
<h5 id="关于rehash"><a href="#关于rehash" class="headerlink" title="关于rehash"></a>关于rehash</h5><p>本文暂不介绍rehash，有兴趣的可以参考<a href="http://redisbook.com/preview/dict/rehashing.html">rehash</a><br>其实这个rehash并不难理解，把相应的几个函数看明白就自然懂了: )<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Redis字典源码难点分析"><a href="#Redis字典源码难点分析" class="headerlink" title="Redis字典源码难点分析"></a>Redis字典源码难点分析</h3><h5 id="难点一：typedef用法"><a href="#难点一：typedef用法" class="headerlink" title="难点一：typedef用法"></a><strong>难点一：typedef用法</strong></h5><p>可能有的同学对如下typedef用法较为陌生<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(dictScanFunction)</span><span class="params">(<span class="type">void</span> *privdata, <span class="type">const</span> dictEntry *de)</span>;</span><br></pre></td></tr></table></figure><br>理解typedef void (dictScanFunction)(void <em>privdata, const dictEntry </em>de);的表达。这里定义的不是函数指针，而是一种函数类型，可以利用 dictScanFunction完成类似函数指针的用法，看下面的例子(<a href="https://blog.csdn.net/smuevian/article/details/66971486">基础概念–typedef的学习</a> )：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">using namespace <span class="built_in">std</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintWord</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">//1  </span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(func1)</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//不是函数指针，定义了一个函数类型  </span></span><br><span class="line">    func1 *myfunc1;<span class="comment">//定义函数指针  </span></span><br><span class="line">    myfunc1 = PrintWord;  </span><br><span class="line">    myfunc1(<span class="number">5</span>);  </span><br><span class="line">    <span class="comment">//2  </span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*func2)</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//定义了一种类型，2和3的区别在于typedef的作用上  </span></span><br><span class="line">    func2 myfunc2;<span class="comment">//实例化  </span></span><br><span class="line">    myfunc2 = PrintWord;  </span><br><span class="line">    myfunc2(<span class="number">5</span>);  </span><br><span class="line">    <span class="comment">//3  </span></span><br><span class="line">    <span class="type">void</span>(*func3)(<span class="type">int</span>);  </span><br><span class="line">    func3 = PrintWord;  </span><br><span class="line">    func3(<span class="number">5</span>);  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<h5 id="难点二：关于翻转整数的二进制"><a href="#难点二：关于翻转整数的二进制" class="headerlink" title="难点二：关于翻转整数的二进制"></a><strong>难点二：关于翻转整数的二进制</strong></h5><p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Function to reverse bits. Algorithm from:</span></span><br><span class="line"><span class="comment"> * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">rev</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> v)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s = <span class="number">8</span> * <span class="keyword">sizeof</span>(v); <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mask = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mask ^= (mask &lt;&lt; s);</span><br><span class="line">        v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解析：上述代码完成了对无符号long整型数v的二进制位的翻转。比如原来是0x0011(3)，翻转之后就是0x1100(12)。在32bit的平台上，sizeof(unsigned long)是等于4的，也就是上述的s等于8*4=32；s右移一位，相当于s/=2,也就是第一次s=16；每次mask计算得到的值分别是：0x0000ffff、0x00ff00ff、0x0f0f0f0f、0x33333333和0x55555555。经过以上几次位相关的运算，便可得到按二进制位翻转之后的数，详细可以参考<a href="https://blog.csdn.net/gqtcgq/article/details/50533183">翻转整数的二进制位</a>。</p>
<h5 id="难点三-其中的扫描函数dictScan"><a href="#难点三-其中的扫描函数dictScan" class="headerlink" title="难点三 其中的扫描函数dictScan"></a><strong>难点三 其中的扫描函数dictScan</strong></h5><p>扫描函数源码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dictScan() is used to iterate over the elements of a dictionary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterating works the following way:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) Initially you call the function using a cursor (v) value of 0.</span></span><br><span class="line"><span class="comment"> * 2) The function performs one step of the iteration, and returns the</span></span><br><span class="line"><span class="comment"> *    new cursor value you must use in the next call.</span></span><br><span class="line"><span class="comment"> * 3) When the returned cursor is 0, the iteration is complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function guarantees all elements present in the</span></span><br><span class="line"><span class="comment"> * dictionary get returned between the start and end of the iteration.</span></span><br><span class="line"><span class="comment"> * However it is possible some elements get returned multiple times.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For every element returned, the callback argument &#x27;fn&#x27; is</span></span><br><span class="line"><span class="comment"> * called with &#x27;privdata&#x27; as first argument and the dictionary entry</span></span><br><span class="line"><span class="comment"> * &#x27;de&#x27; as second argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HOW IT WORKS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The iteration algorithm was designed by Pieter Noordhuis.</span></span><br><span class="line"><span class="comment"> * The main idea is to increment a cursor starting from the higher order</span></span><br><span class="line"><span class="comment"> * bits. That is, instead of incrementing the cursor normally, the bits</span></span><br><span class="line"><span class="comment"> * of the cursor are reversed, then the cursor is incremented, and finally</span></span><br><span class="line"><span class="comment"> * the bits are reversed again.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This strategy is needed because the hash table may be resized between</span></span><br><span class="line"><span class="comment"> * iteration calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dict.c hash tables are always power of two in size, and they</span></span><br><span class="line"><span class="comment"> * use chaining, so the position of an element in a given table is given</span></span><br><span class="line"><span class="comment"> * by computing the bitwise AND between Hash(key) and SIZE-1</span></span><br><span class="line"><span class="comment"> * (where SIZE-1 is always the mask that is equivalent to taking the rest</span></span><br><span class="line"><span class="comment"> *  of the division between the Hash of the key and SIZE).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example if the current hash table size is 16, the mask is</span></span><br><span class="line"><span class="comment"> * (in binary) 1111. The position of a key in the hash table will always be</span></span><br><span class="line"><span class="comment"> * the last four bits of the hash output, and so forth.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WHAT HAPPENS IF THE TABLE CHANGES IN SIZE?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the hash table grows, elements can go anywhere in one multiple of</span></span><br><span class="line"><span class="comment"> * the old bucket: for example let&#x27;s say we already iterated with</span></span><br><span class="line"><span class="comment"> * a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the hash table will be resized to 64 elements, then the new mask will</span></span><br><span class="line"><span class="comment"> * be 111111. The new buckets you obtain by substituting in ??1100</span></span><br><span class="line"><span class="comment"> * with either 0 or 1 can be targeted only by keys we already visited</span></span><br><span class="line"><span class="comment"> * when scanning the bucket 1100 in the smaller hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * By iterating the higher bits first, because of the inverted counter, the</span></span><br><span class="line"><span class="comment"> * cursor does not need to restart if the table size gets bigger. It will</span></span><br><span class="line"><span class="comment"> * continue iterating using cursors without &#x27;1100&#x27; at the end, and also</span></span><br><span class="line"><span class="comment"> * without any other combination of the final 4 bits already explored.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Similarly when the table size shrinks over time, for example going from</span></span><br><span class="line"><span class="comment"> * 16 to 8, if a combination of the lower three bits (the mask for size 8</span></span><br><span class="line"><span class="comment"> * is 111) were already completely explored, it would not be visited again</span></span><br><span class="line"><span class="comment"> * because we are sure we tried, for example, both 0111 and 1111 (all the</span></span><br><span class="line"><span class="comment"> * variations of the higher bit) so we don&#x27;t need to test it again.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WAIT... YOU HAVE *TWO* TABLES DURING REHASHING!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Yes, this is true, but we always iterate the smaller table first, then</span></span><br><span class="line"><span class="comment"> * we test all the expansions of the current cursor into the larger</span></span><br><span class="line"><span class="comment"> * table. For example if the current cursor is 101 and we also have a</span></span><br><span class="line"><span class="comment"> * larger table of size 16, we also test (0)101 and (1)101 inside the larger</span></span><br><span class="line"><span class="comment"> * table. This reduces the problem back to having only one table, where</span></span><br><span class="line"><span class="comment"> * the larger one, if it exists, is just an expansion of the smaller one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LIMITATIONS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This iterator is completely stateless, and this is a huge advantage,</span></span><br><span class="line"><span class="comment"> * including no additional memory used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The disadvantages resulting from this design are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) It is possible we return elements more than once. However this is usually</span></span><br><span class="line"><span class="comment"> *    easy to deal with in the application level.</span></span><br><span class="line"><span class="comment"> * 2) The iterator must return multiple elements per call, as it needs to always</span></span><br><span class="line"><span class="comment"> *    return all the keys chained in a given bucket, and all the expansions, so</span></span><br><span class="line"><span class="comment"> *    we are sure we don&#x27;t miss keys moving during rehashing.</span></span><br><span class="line"><span class="comment"> * 3) The reverse cursor is somewhat hard to understand at first, but this</span></span><br><span class="line"><span class="comment"> *    comment is supposed to help.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">dictScan</span><span class="params">(dict *d,</span></span><br><span class="line"><span class="params">                       <span class="type">unsigned</span> <span class="type">long</span> v,</span></span><br><span class="line"><span class="params">                       dictScanFunction *fn,</span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *privdata)</span></span><br><span class="line">&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="type">const</span> dictEntry *de;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment">         * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = de-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment bits not covered by the smaller mask */</span></span><br><span class="line">            v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment">     * operates on the masked bits of the smaller table */</span></span><br><span class="line">    v |= ~m0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">    v = rev(v);</span><br><span class="line">    v++;</span><br><span class="line">    v = rev(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>字典数据结构中最难理解的个人觉得就是这个函数了，看原作者给了那么长的注释，也可以看出作者希望读者通过注释能理解这段代码。这段代码主要功能就是就是根据给定的游标v，用给定的扫描函数，扫描相应哈希表中t0-&gt;table[v &amp; m0]这个bucket中的各个dictEntry；然后根据特定的算法返回一个游标v，注意该函数并没有按我们常规的想法，就是把v++，之所以没有这样做，是因为字典可能存在rehash的过程，这使字典可能扩展，也可能缩小。然而扫描迭代的时候又希望不漏掉遍历开始那一刻的所有元素，又希望把返回重复元素的可能性降到最低，因此便有了上述的很巧妙的算法。<br>我们看下扫描函数中关于游标v的关键部分：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v |= ~m0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">v = rev(v);</span><br><span class="line">v++;</span><br><span class="line">v = rev(v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> v;</span><br></pre></td></tr></table></figure><br>在Redis的字典中哈希表的长度始终是2的n次方，m0也就始终是2^n -1,比如长度为8时，m0=0x111;<br>所以第一步：v |= ~m0;就只保留了v的低n位，其余位全置1;<br>第二步：v = rev(v);将v的二进制位进行翻转，所以v的低n位变成了高n位<br>第三步：v++;这个时候其实最右边是1，+1是向正常的高位进位<br>第四步：v = rev(v);再翻转回来。</p>
<p>因此这四步总结起来就是：<strong>向最高位加1，且向低位方向进位</strong>。<br>比如：<br>当长度为8时，游标cursor的变化过程就是这样：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000</span> --&gt; <span class="number">100</span> --&gt; <span class="number">010</span> --&gt; <span class="number">110</span> --&gt; <span class="number">001</span> --&gt; <span class="number">101</span> --&gt; <span class="number">011</span> --&gt; <span class="number">111</span> --&gt; <span class="number">000</span>  </span><br></pre></td></tr></table></figure><br>关于这部分可以参考<a href="https://blog.csdn.net/gqtcgq/article/details/50533336">Redis源码解析：04字典的遍历dictScan</a>。<br>理解这个过程，那么该dictScan函数就好理解了，主要就是针对有没有在做rehash，如果没有在做rehash，这种情况比较简单，直接在d-&gt;ht[0]这个哈希表中根据v找到需要迭代的bucket索引，针对该bucket中链表中的所有节点，调用用户提供的fn函数即可。<br>对于正在rehash的情况，需要先遍历较小的哈希表，然后遍历较大的哈希表。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment"> * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">    de = t1-&gt;table[v &amp; m1];</span><br><span class="line">    <span class="keyword">while</span> (de) &#123;</span><br><span class="line">        fn(privdata, de);</span><br><span class="line">        de = de-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Increment bits not covered by the smaller mask */</span></span><br><span class="line">    v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">&#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br></pre></td></tr></table></figure><br>这段代码是在遍历较大的哈希表，其中v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);这是在对m0没有覆盖到的位进行加1操作，举个例子就明白了：若t0长度为8，则m0为111，若t1位16，那么m1就是1111,此时m0没有覆盖到位，就是0111的高位那个0，加1后就成了1111，其实对于111这种情况，在大的哈希表中就需要遍历0111和1111这两个bucket。</p>
<h3 id="Redis字典源码部分节选"><a href="#Redis字典源码部分节选" class="headerlink" title="Redis字典源码部分节选"></a>Redis字典源码部分节选</h3><p>头文件dict.h源码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DICT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DICT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DICT_OK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DICT_ERR 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unused arguments generate annoying warnings... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DICT_NOTUSED(V) ((void) V)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    <span class="type">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(dictScanFunction)</span><span class="params">(<span class="type">void</span> *privdata, <span class="type">const</span> dictEntry *de)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the initial size of every hash table */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DICT_HT_INITIAL_SIZE     4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------- Macros ------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictFreeVal(d, entry) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span></span><br><span class="line"><span class="meta">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetVal(d, entry, _val_) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span></span><br><span class="line"><span class="meta">        entry-&gt;v.val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        entry-&gt;v.val = (_val_); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetSignedIntegerVal(entry, _val_) \</span></span><br><span class="line"><span class="meta">    do &#123; entry-&gt;v.s64 = _val_; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetUnsignedIntegerVal(entry, _val_) \</span></span><br><span class="line"><span class="meta">    do &#123; entry-&gt;v.u64 = _val_; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetDoubleVal(entry, _val_) \</span></span><br><span class="line"><span class="meta">    do &#123; entry-&gt;v.d = _val_; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span></span><br><span class="line"><span class="meta">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSetKey(d, entry, _key_) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span></span><br><span class="line"><span class="meta">        entry-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        entry-&gt;key = (_key_); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictCompareKeys(d, key1, key2) \</span></span><br><span class="line"><span class="meta">    (((d)-&gt;type-&gt;keyCompare) ? \</span></span><br><span class="line"><span class="meta">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span></span><br><span class="line"><span class="meta">        (key1) == (key2))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictGetDoubleVal(he) ((he)-&gt;v.d)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* API */</span></span><br><span class="line">dict *<span class="title function_">dictCreate</span><span class="params">(dictType *type, <span class="type">void</span> *privDataPtr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictAdd</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span>;</span><br><span class="line">dictEntry *<span class="title function_">dictAddRaw</span><span class="params">(dict *d, <span class="type">void</span> *key)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictReplace</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span>;</span><br><span class="line">dictEntry *<span class="title function_">dictReplaceRaw</span><span class="params">(dict *d, <span class="type">void</span> *key)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictDelete</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictDeleteNoFree</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dictRelease</span><span class="params">(dict *d)</span>;</span><br><span class="line">dictEntry * <span class="title function_">dictFind</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">dictFetchValue</span><span class="params">(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span>;</span><br><span class="line">dictIterator *<span class="title function_">dictGetIterator</span><span class="params">(dict *d)</span>;</span><br><span class="line">dictIterator *<span class="title function_">dictGetSafeIterator</span><span class="params">(dict *d)</span>;</span><br><span class="line">dictEntry *<span class="title function_">dictNext</span><span class="params">(dictIterator *iter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span>;</span><br><span class="line">dictEntry *<span class="title function_">dictGetRandomKey</span><span class="params">(dict *d)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dictPrintStats</span><span class="params">(dict *d)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGenHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGenCaseHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dictEmpty</span><span class="params">(dict *d, <span class="type">void</span>(callback)(<span class="type">void</span>*))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dictEnableResize</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dictDisableResize</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="type">int</span> ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dictSetHashFunctionSeed</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> initval)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGetHashFunctionSeed</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">dictScan</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> v, dictScanFunction *fn, <span class="type">void</span> *privdata)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Hash table types */</span></span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStringCopyKey;</span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStrings;</span><br><span class="line"><span class="keyword">extern</span> dictType dictTypeHeapStringCopyKeyValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __DICT_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>字典添加元素：</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Our hash table capability is a power of two */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> _dictNextPower(<span class="type">unsigned</span> <span class="type">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand or create the hash table */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hash table */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it&#x27;s not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Incremental rehashing already in progress. Return. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reached the 1:1 ratio, and we are allowed to resize the hash</span></span><br><span class="line"><span class="comment">     * table (global setting) or we should avoid it but the ratio between</span></span><br><span class="line"><span class="comment">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</span></span><br><span class="line"><span class="comment">     * the number of buckets. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the index of a free slot that can be populated with</span></span><br><span class="line"><span class="comment"> * a hash entry for the given &#x27;key&#x27;.</span></span><br><span class="line"><span class="comment"> * If the key already exists, -1 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if we are in the process of rehashing the hash table, the</span></span><br><span class="line"><span class="comment"> * index is always returned in the context of the second (new) hash table. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictKeyIndex(dict *d, <span class="type">const</span> <span class="type">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* Compute the key hash value */</span></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Low level add. This function adds the entry but instead of setting</span></span><br><span class="line"><span class="comment"> * a value returns the dictEntry structure to the user, that will make</span></span><br><span class="line"><span class="comment"> * sure to fill the value field as he wishes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is also directly exposed to the user API to be called</span></span><br><span class="line"><span class="comment"> * mainly in order to store non-pointers inside the hash value, example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * entry = dictAddRaw(dict,mykey);</span></span><br><span class="line"><span class="comment"> * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If key already exists NULL is returned.</span></span><br><span class="line"><span class="comment"> * If key was added, the hash entry is returned to be manipulated by the caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dictEntry *<span class="title function_">dictAddRaw</span><span class="params">(dict *d, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictAdd</span><span class="params">(dict *d, <span class="type">void</span> *key, <span class="type">void</span> *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    dictSetVal(d, entry, val);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该过程图示如下：<br><img src="http://redissrc.readthedocs.io/en/latest/_images/graphviz-10472d0cd7aa2ee803003650472c9bac72f5bf39.png" alt=""></p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://redisbook.com/preview/dict/datastruct.html">Redis设计与实现</a><br><a href="https://github.com/antirez/redis/releases/tag/3.0.6">Redis源码3.0.6</a><br><a href="https://www.cnblogs.com/gavanwanggw/p/7307596.html">哈希表——线性探測法、链地址法、查找成功、查找不成功的平均长度</a><br><a href="https://blog.csdn.net/smuevian/article/details/66971486">基础概念–typedef的学习</a><br><a href="https://blog.csdn.net/gqtcgq/article/details/50533336">Redis源码解析：04字典的遍历dictScan</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Key-Value存储系统</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置NTP时间服务器</title>
    <url>/2018/05/30/Linux%E9%85%8D%E7%BD%AENTP%E6%97%B6%E9%97%B4%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>NTP即Network Time Protocol，是用来同步网络中各个计算机的时间的协议。该协议本身是个挺复杂的协议，但是设置NTP服务器不难。<br>本文主要介绍：</p>
<ul>
<li>背景（即为什么要设置NTP时间服务器）</li>
<li>配置NTP时间服务器端</li>
<li>配置NTP client端</li>
</ul>
<hr>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为什么要设置NTP时间服务器？在日常开发工作中，经常都需要定位多个服务器上的问题，由于是集群环境，经常出现一个问题是：各个服务器上时间不一致，这导致在定位问题时不是很方便，需要自己去对比几个节点时间相差多少，然后才能分析找某一时间点的各个节点的业务进程的日志，如此才能继续定位下去。本文的设置NTP时间服务器的目的就是解决类似的问题。  </p>
<p>原理大家都可以查阅文末的参考资料了解。主要就是拿一个性能较好的机器来作为NTP server，其他所有节点作为NTP client以该节点为标准，同步自己的本地时间。这样可以保证各个节点时间一致。需要注意的是，这样并不能保证各节点时间与真实时间一致。好处是各个节点时间是一致的，而且发现时间不准确时，只需要改NTP server上时间就可以了，其他节点会自动同步。</p>
<h3 id="配置NTP时间服务器"><a href="#配置NTP时间服务器" class="headerlink" title="配置NTP时间服务器"></a>配置NTP时间服务器</h3><p>假设我们用10.11.12.13节点来作为NTP服务器<br>登录到该节点<br>通常Linux服务器上面都已经安装了NTP，如果没有安装请通过搜索引擎或者文末参考资料进行查询并自行安装。  </p>
<p><strong>配置NTP Server的层数提供本地服务</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vi /etc/ntp.conf</span></span><br></pre></td></tr></table></figure><br>添加如下两行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server  127.127.1.0     # local clock</span><br><span class="line">fudge   127.127.1.0 stratum 2</span><br></pre></td></tr></table></figure><br><strong>重启NTP服务</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service ntpd stop</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service ntpd start</span></span><br></pre></td></tr></table></figure></p>
<p><strong>通过查看123端口检测NTP服务是否启动</strong><br>如下便表示正常<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netstat -tlunp | grep ntp</span></span><br><span class="line">udp    0   0 192.168.1.101:123    0.0.0.0:*              2563/ntpd     </span><br><span class="line">udp    0   0 127.0.0.1:123      0.0.0.0:*              2563/ntpd     </span><br><span class="line">udp    0   0 0.0.0.0:123       0.0.0.0:*              2563/ntpd     </span><br><span class="line">udp6    0   0 fe80::20c:29ff:fe7b:123 :::*                2563/ntpd     </span><br><span class="line">udp6    0   0 ::1:123         :::*                2563/ntpd     </span><br><span class="line">udp6    0   0 :::123         :::*                2563/ntpd </span><br></pre></td></tr></table></figure></p>
<p><strong>设置开机时自动运行时间服务</strong><br>重要步骤，别忘了 : )<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig ntpd on</span></span><br></pre></td></tr></table></figure></p>
<p><strong>根据实际设置当前节点时间</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">date</span> -s “2018-05-30 20:11:11”</span></span><br></pre></td></tr></table></figure></p>
<p><strong>将系统时钟同步到硬件时钟</strong><br>避免节点重启之后，时间又错乱<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hclock -w</span></span><br></pre></td></tr></table></figure></p>
<h3 id="配置NTP-client端"><a href="#配置NTP-client端" class="headerlink" title="配置NTP client端"></a>配置NTP client端</h3><p>登录相应节点<br><strong>设置需要需要根据哪个服务器来进行NTP时间同步</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vi /etc/ntp.conf</span><br></pre></td></tr></table></figure><br>在/etc/ntp.conf文件中添加：（服务器当然填上面设置的10.11.12.13）<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server 10.11.12.13</span><br></pre></td></tr></table></figure></p>
<p><strong>故意设置一个错误时间</strong><br>用于检测NTP时间同步服务是否生效<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">date</span> -s “2011-11-11 11:11:11”</span></span><br></pre></td></tr></table></figure></p>
<p><strong>重启NTP服务</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service ntpd stop</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">service ntpd start</span></span><br></pre></td></tr></table></figure></p>
<p><strong>设置开机时自动运行时间服务</strong><br>重要步骤，别忘了 : )<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig ntpd on</span></span><br></pre></td></tr></table></figure></p>
<p><strong>验证ntp服务已经运行</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pgrep ntpd</span><br></pre></td></tr></table></figure><br><strong>或者通过查看123端口检测NTP服务是否启动</strong><br>如下便表示正常<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netstat -tlunp | grep ntp</span></span><br><span class="line">udp    0   0 192.168.1.101:123    0.0.0.0:*              2563/ntpd     </span><br><span class="line">udp    0   0 127.0.0.1:123      0.0.0.0:*              2563/ntpd     </span><br><span class="line">udp    0   0 0.0.0.0:123       0.0.0.0:*              2563/ntpd     </span><br><span class="line">udp6    0   0 fe80::20c:29ff:fe7b:123 :::*                2563/ntpd     </span><br><span class="line">udp6    0   0 ::1:123         :::*                2563/ntpd     </span><br><span class="line">udp6    0   0 :::123         :::*                2563/ntpd </span><br></pre></td></tr></table></figure><br><strong>查看NTP服务器的列表</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ntpq -p</span></span><br><span class="line">remote       refid      st  t   when  poll  reach   delay   offset  jitter</span><br><span class="line">============================================================================</span><br><span class="line">*10.11.12.13   LOCAL(0)  4  u   53   64  377      0.240    0.374   0.240</span><br></pre></td></tr></table></figure><br>各参数含义如下：</p>
<blockquote>
<p>remote：本机和上层ntp的ip或主机名，“+”表示优先，“*”表示次优先<br>refid：参考上一层ntp主机地址<br>st：stratum阶层<br>when：多少秒前曾经同步过时间<br>poll：下次更新在多少秒后<br>reach：已经向上层ntp服务器要求更新的次数<br>delay：网络延迟<br>offset：时间补偿<br>jitter：系统时间与bios时间差</p>
</blockquote>
<p><strong>查看当前时间</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">2018-05-30 20:20:11</span><br></pre></td></tr></table></figure><br>如果不是在设置的错误时间的附件，说明该节点已经同步了 : )</p>
<p><strong>将系统时钟同步到硬件时钟</strong><br>避免节点重启之后，时间又错乱<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hclock -w</span></span><br></pre></td></tr></table></figure></p>
<p>到此已经配置成功，其他需要时间同步的节点，也可以照以上步骤操作。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>有可能会遇到防火墙的问题导致设置失败，需要设置防火墙将123端口开放<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p UDP -i eno16777736 -s 192.168.1.0/24 --dport 123 -j ACCEPT</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/mengfanzhundsc/article/details/62046562">Linux 上配置 NTP SERVER</a><br><a href="https://www.cnblogs.com/lpfuture/p/5756993.html">linux ntp时间服务器配置</a><br><a href="https://blog.csdn.net/to_baidu/article/details/52563357">ntp原理与设置</a><br><a href="https://www.cnblogs.com/quchunhui/p/7658853.html">Linux配置ntp时间服务器（全）</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>日常积累</tag>
        <tag>ntp</tag>
      </tags>
  </entry>
  <entry>
    <title>如何防止业务进程被OOM kill</title>
    <url>/2018/06/04/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E4%B8%9A%E5%8A%A1%E8%BF%9B%E7%A8%8B%E8%A2%ABOOM%20kill/</url>
    <content><![CDATA[<p>OOM Killer 的全称叫 Out Of Memory Killer。<br>本文主要介绍：</p>
<ul>
<li>Out-Of-Memory killer</li>
<li>如何防止业务进程被OOM kill</li>
<li>Linux shell特殊变量含义</li>
</ul>
<hr>
<h3 id="Out-Of-Memory-killer"><a href="#Out-Of-Memory-killer" class="headerlink" title="Out-Of-Memory killer"></a>Out-Of-Memory killer</h3><p>Linux 内核有个机制叫OOM killer（Out-Of-Memory killer），该机制会监控那些占用内存过大，尤其是瞬间很快消耗大量内存的进程，为了防止内存耗尽而内核会把该进程杀掉。<br>典型的情况是：某天一台机器突然ssh远程登录不了，但能ping通，说明不是网络的故障，原因是sshd进程被OOM killer杀掉了（多次遇到这样的假死状况）。重启机器后查看系统日志/var/log/messages会发现Out of Memory: Kill process 1865（sshd）类似的错误信息。</p>
<p>具体的代码和算法可以参考 mm/oom_kill.c，注释写的很清楚。<br><a href="https://github.com/torvalds/linux/blob/master/mm/oom_kill.c">https://github.com/torvalds/linux/blob/master/mm/oom_kill.c</a></p>
<h3 id="防止业务进程被OOM-kill"><a href="#防止业务进程被OOM-kill" class="headerlink" title="防止业务进程被OOM kill"></a>防止业务进程被OOM kill</h3><p>防止重要的系统进程触发(OOM)机制而被杀死：可以设置参数/proc/PID/oom_adj为-17，可临时关闭linux内核的OOM机制。内核会通过特定的算法给每个进程计算一个分数来决定杀哪个进程，每个进程的oom分数可以/proc/PID/oom_score中找到。我们运维过程中保护的一般是sshd和一些管理agent。</p>
<p>也就是说如果想要业务进程加入免杀列表，在知道业务进程id的情况下，可以做如下操作：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -17 &gt; /proc/$PID/oom_adj</span><br></pre></td></tr></table></figure></p>
<p>此外如果业务进程是通过shell脚本拉起，那么脚本里面启动业务进程前，可加入下面语句，将即将启动的业务进程加入免杀列表：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -17 &gt; /proc/$$/oom_adj</span><br></pre></td></tr></table></figure></p>
<h3 id="Linux-shell特殊变量含义"><a href="#Linux-shell特殊变量含义" class="headerlink" title="Linux shell特殊变量含义"></a>Linux shell特殊变量含义</h3><table>
<thead>
<tr>
<th>变量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td style="text-align:center">当前脚本的文件名</td>
</tr>
<tr>
<td>$n</td>
<td style="text-align:center">传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2</td>
</tr>
<tr>
<td>$#</td>
<td style="text-align:center">传递给脚本或函数的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td style="text-align:center">传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td>$@</td>
<td style="text-align:center">传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同</td>
</tr>
<tr>
<td>$?</td>
<td style="text-align:center">上个命令的退出状态，或函数的返回值</td>
</tr>
<tr>
<td>$$</td>
<td style="text-align:center">当前Shell进程ID。对于 Shell 脚本，就是当前脚本所在的进程ID。</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/zgrjkflmkyc/article/details/77645570">Linux内核OOM机制的详细分析和防止进程被OOM杀死的方法</a><br><a href="https://yq.aliyun.com/articles/243807">理解和配置 Linux 下的 OOM Killer</a><br><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650714201&amp;idx=1&amp;sn=c9b42905f936cc53252cf6245a957a00&amp;chksm=bec07e0a89b7f71c6b9380729dad46b278199c2756ec34ace43c69d05df29f95a7c699f4026b&amp;mpshare=1&amp;scene=23&amp;srcid=0606FSpj20L36vDLOA9G1qWj#rd">每个程序员都该了解一点 Linux 内存管理知识</a><br><a href="https://www.cnblogs.com/chjbbs/p/6393805.html">linux bash Shell特殊变量</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>日常积累</tag>
        <tag>OMM</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码阅读--跳跃表</title>
    <url>/2018/06/03/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB--%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<p>本文主要介绍如下内容：</p>
<ul>
<li>跳跃表介绍</li>
<li>Redis中的跳跃表实现及特点</li>
<li>Redis中的跳跃表源码难点分析</li>
<li>Redis中的跳跃表源码部分节选</li>
</ul>
<hr>
<h3 id="跳跃表介绍"><a href="#跳跃表介绍" class="headerlink" title="跳跃表介绍"></a>跳跃表介绍</h3><p>跳跃表是一种随机化数据结构，基于并联的链表，其效率可以比拟平衡二叉树，查找、删除、插入等操作都可以在对数期望时间内完成，对比平衡树，跳跃表的实现要简单直观很多。</p>
<p>以下是一个跳跃表的例图(来自维基百科)：<br><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Skip_list.svg/470px-Skip_list.svg.png" alt=""><br>从图中可以看出跳跃表主要有以下几个部分构成：</p>
<p>1、  表头head：负责维护跳跃表的节点指针</p>
<p>2、  节点node：实际保存元素值，每个节点有一层或多层</p>
<p>3、  层level：保存着指向该层下一个节点的指针</p>
<p>4、  表尾tail：全部由null组成</p>
<p>跳跃表的遍历总是从高层开始，然后随着元素值范围的缩小，慢慢降低到低层。</p>
<h3 id="Redis中的跳跃表实现及特点"><a href="#Redis中的跳跃表实现及特点" class="headerlink" title="Redis中的跳跃表实现及特点"></a>Redis中的跳跃表实现及特点</h3><p>Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构体定义，具体实现在t_zset.c中。</p>
<p><strong>跳跃表节点</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p>
<p><strong>zskiplist 结构体</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。<br>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。<br>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。<br><img src="http://redisbook.com/_images/graphviz-59432127803598137980d030e8e529c5b068bebb.png" alt=""></p>
</blockquote>
<p><strong>特点</strong>  </p>
<ul>
<li>跳跃表是有序集合的底层实现之一</li>
<li>Redis的跳跃表实现由 zskiplist 和 zskiplistNode两个结构组成,其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而zskiplistNode则用于表示跳跃表节点</li>
<li>每个跳跃表节点的层高都是 1 至 32 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
<p>–<br><strong>与通常描述的跳跃表的区别</strong>  </p>
<p>Redis的跳跃表实现跟WilliamPugh在”Skip Lists: A Probabilistic Alternative to Balanced Trees”中描述的跳跃表算法类似，只是有如下不同：</p>
<ul>
<li>允许重复分数</li>
<li>排序不止根据分数，还可能根据成员对象（当分数相同时）</li>
<li>每个跳表节点中有backward指向前驱节点，从而可以方便的从表尾向表头遍历，用于ZREVRANGE命令的实现。</li>
</ul>
<h3 id="Redis中的跳跃表源码难点分析"><a href="#Redis中的跳跃表源码难点分析" class="headerlink" title="Redis中的跳跃表源码难点分析"></a>Redis中的跳跃表源码难点分析</h3><h4 id="随机算法函数"><a href="#随机算法函数" class="headerlink" title="随机算法函数"></a>随机算法函数</h4><p>zslRandomLevel函数为我们要建的新跳表返回一个随机的层数，该数在1~32之间，且越大的数出现的概率越小。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里的ZSKIPLIST_P是0.25。上述代码中，level初始化为1，然后，如果持续满足条件：(random()&amp;0xFFFF)&lt; (ZSKIPLIST_P <em> 0xFFFF)的话，则level+=1。最终调整level的值，使其小于ZSKIPLIST_MAXLEVEL。  理解该算法的核心，就是要理解满足条件：(random()&amp;0xFFFF) &lt; (ZSKIPLIST_P </em> 0xFFFF)的概率是多少？<br>random()&amp;0xFFFF形成的数，均匀分布在区间[0,0xFFFF]上，那么这个数小于(ZSKIPLIST_P <em> 0xFFFF)的概率是多少呢？自然就是ZSKIPLIST_P，也就是0.25了。<br>因此，最终返回level为1的概率是1-0.25=0.75，返回level为2的概率为0.25</em>0.75，返回level为3的概率为0.25<em>0.25</em>0.75……因此，如果返回level为k的概率为x，则返回level为k+1的概率为0.25<em>x，换句话说，如果k层的结点数是x，那么k+1层就是0.25</em>x了。这就是所谓的幂次定律（powerlaw），越大的数出现的概率越小。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//创建一个新的跳跃表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zslFree</span><span class="params">(zskiplist *zsl)</span>;<span class="comment">//释放给定的跳跃表（包括表中所有节点）</span></span><br><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, robj *obj)</span>;<span class="comment">//将包含给定成员和分值的新节点插入到指定的跳跃表中</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">zslFree</span><span class="params">(zskiplist *zsl)</span> &#123;</span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line"></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslFreeNode(node);</span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, robj *obj)</span> &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    redisAssert(!isnan(score));</span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, and the re-insertion of score and redis object should never</span></span><br><span class="line"><span class="comment">     * happen since the caller of zslInsert() should test in the hash table</span></span><br><span class="line"><span class="comment">     * if the element is already inside or not. */</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    x = zslCreateNode(level,score,obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">/*update[i]中记录了在i层插入节点应该插入的位置，所以x的后继节点就应该是当前  </span></span><br><span class="line"><span class="comment">        update[i]-&gt;level[i]的后继节点了*/</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;<span class="comment">//将x插入到update[i]-&gt;level[i]后</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        <span class="comment">/*跨度span用于记录当前节点的forward指针指向的节点和当前节点的距离，</span></span><br><span class="line"><span class="comment">        所以应该等于该节点在第i层上的后继节点(forward指针指向的节点)的排名，  </span></span><br><span class="line"><span class="comment">        减去该节点的排名,新结点在第i层的后继节点，也就是之前update[i]的后继节点，</span></span><br><span class="line"><span class="comment">        它的排名是update[i]-&gt;level[i].span+ rank[i]，插入新结点之后，</span></span><br><span class="line"><span class="comment">        它的排名加1，也就是update[i]-&gt;level[i].span + rank[i] + 1。</span></span><br><span class="line"><span class="comment">        新结点的排名，就是rank[0]+ 1，因此，新结点在第i层的层跨度就是</span></span><br><span class="line"><span class="comment">        (update[i]-&gt;level[i].span + rank[i] + 1) – (rank[0] + 1)，</span></span><br><span class="line"><span class="comment">        也就是update[i]-&gt;level[i].span- (rank[0] - rank[i])。*/</span></span><br><span class="line">        </span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*前驱结点update[i]的层跨度，等于新结点的排名rank[0]+ 1，</span></span><br><span class="line"><span class="comment">        减去update[i]的排名rank[i]，也就是(rank[0] + 1) - rank[i]，</span></span><br><span class="line"><span class="comment">        也就是(rank[0] -rank[i]) + 1*/</span></span><br><span class="line">        </span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于插入节点这个函数的实现，我们需要明白几点，在知道zskiplistNode和zskiplist数据结构的基础上，把以下几点弄明白了，整个函数就好理解了。  </p>
<ol>
<li>辅助数组update的作用是什么  </li>
<li>数组rank的作用是什么  </li>
<li>哪些层需要插入该节点  </li>
<li>结构体zskiplistNode中span的意义是什么  </li>
</ol>
<p>第1个问题：首先我们要插入一个节点，与链表类似，需要找到合适位置插入，而辅助数组update就用来存放待插入节点在每一层应该插入的位置的,即代码开头这一段：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123;</span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>第2个问题，数组rank用来存放的是每层合适的待插入位置的排名，比如在下图的跳跃表中，假设现在要插入的结点分数为17，黄色虚线所标注的，就是插入新结点的位置。下面标注红色的，就是在每层找到的插入结点的前驱结点，记录在update[i]中，而rank[i]记录了update[i]在跳跃表中的排名，因此，rank[4] = 3, rank[3] = 3, rank[2] = 4, rank[1] = 4, rank[0] = 4<br><img src="https://img-blog.csdn.net/20160131084016631" alt=""></p>
<p>第3个问题哪些层需要插入这个节点，这个问题在Redis中是采用了前面说的随机算法，利用随机算法得出一个在1~32之间的level值，第0层到第level-1层都需要插入该节点：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">level = zslRandomLevel();</span><br><span class="line"><span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">        rank[i] = <span class="number">0</span>;</span><br><span class="line">        update[i] = zsl-&gt;header;</span><br><span class="line">        update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;level = level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第4个问题：zskiplistNode中span表示跨度，用于记录当前节点的forward指针指向的节点和当前节点的距离（如果指向 NULL，那么前进指针的跨度都为0，因为它们没有连向任何节点）。此外，由于排名rank是由前面各span累积起来的，比如上面给的图中的值为10的节点的排名就是3，所以我们在计算当前节点的span的时候，可以用后继节点排名减去当前节点节点排名，下面这段代码就用了这个逻辑：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = zslCreateNode(level,score,obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后这段代码就好理解了，只需要看结构图就明白了<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">    x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    zsl-&gt;tail = x;</span><br><span class="line">zsl-&gt;length++;</span><br></pre></td></tr></table></figure><br>结构图：<br><img src="http://redisbook.com/_images/graphviz-e252c0a9575f171b9721162311df23889699cac9.png" alt=""><br>即如果update[0] == zsl-&gt;header，那么根据图，它的backward就应该为NULL；<br>如果x-&gt;level[0].forward为NULL，那表明该节点为尾节点，所以zsl-&gt;tail = x。</p>
<hr>
<h3 id="Redis中的跳跃表源码部分节选"><a href="#Redis中的跳跃表源码部分节选" class="headerlink" title="Redis中的跳跃表源码部分节选"></a>Redis中的跳跃表源码部分节选</h3><p><strong>删除跳表中匹配score和obj的节点</strong><br>理解了上面的插入节点，这个部分是很好看懂的，请看源码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete an element with matching score/object from the skiplist. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslDelete</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, robj *obj)</span> &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123;</span><br><span class="line">        zslDeleteNode(zsl, x, update);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>获取某一score和成员对象o对应的节点的排名</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find the rank for an element by both score and key.</span></span><br><span class="line"><span class="comment"> * Returns 0 when the element cannot be found, rank otherwise.</span></span><br><span class="line"><span class="comment"> * Note that the rank is 1-based due to the span of zsl-&gt;header to the</span></span><br><span class="line"><span class="comment"> * first element. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, robj *o)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要注意的是<strong><em>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的</em></strong>，否则上面的实现是有问题的，如果没有这一限制，如果在该跳表中只有一个大于score，且成员对象也为o的节点，那么此时会返回rank，而这个时候其实是应该返回0，即表示没有找到相应的节点。由于已经限定没有重复o，所以上述实现正确。</p>
<p><strong>根据排名找对应的节点:</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></span><br><span class="line">zskiplistNode* <span class="title function_">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="type">unsigned</span> <span class="type">long</span> rank)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>结构体zrangespec</strong><br>该结构体给出一个score的范围min~max,minex和maxex是用来表示这个范围区间开闭的,为0表示包括，为1表示不包括。如果要表示[10, 15]，那么<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zrangespec.min = <span class="number">10</span>;</span><br><span class="line">zrangespec.max = <span class="number">15</span>;</span><br><span class="line">zrangespec.minex = zrangespec.maxex = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec by score comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> min, max;</span><br><span class="line">    <span class="type">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zrangespec;</span><br></pre></td></tr></table></figure></p>
<p><strong>给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点:</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns if there is a part of the zset is in range. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslIsInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test for ranges that will always be empty. */</span></span><br><span class="line">    <span class="keyword">if</span> (range-&gt;min &gt; range-&gt;max ||</span><br><span class="line">            (range-&gt;min == range-&gt;max &amp;&amp; (range-&gt;minex || range-&gt;maxex)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = zsl-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslValueGteMin(x-&gt;score,range))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslValueLteMax(x-&gt;score,range))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find the first node that is contained in the specified range.</span></span><br><span class="line"><span class="comment"> * Returns NULL when no element is contained in the range. */</span></span><br><span class="line">zskiplistNode *<span class="title function_">zslFirstInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If everything is out of range, return early. */</span></span><br><span class="line">    <span class="keyword">if</span> (!zslIsInRange(zsl,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* Go forward while *OUT* of range. */</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an inner range, so the next node cannot be NULL. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    redisAssert(x != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if score &lt;= max. */</span></span><br><span class="line">    <span class="keyword">if</span> (!zslValueLteMax(x-&gt;score,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>给定一个分值范围， 返回跳跃表中最后一个符合这个范围的节点:</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find the last node that is contained in the specified range.</span></span><br><span class="line"><span class="comment"> * Returns NULL when no element is contained in the range. */</span></span><br><span class="line">zskiplistNode *<span class="title function_">zslLastInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If everything is out of range, return early. */</span></span><br><span class="line">    <span class="keyword">if</span> (!zslIsInRange(zsl,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* Go forward while *IN* range. */</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an inner range, so this node cannot be NULL. */</span></span><br><span class="line">    redisAssert(x != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if score &gt;= min. */</span></span><br><span class="line">    <span class="keyword">if</span> (!zslValueGteMin(x-&gt;score,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete all the elements with score between min and max from the skiplist.</span></span><br><span class="line"><span class="comment"> * Min and max are inclusive, so a score &gt;= min || score &lt;= max is deleted.</span></span><br><span class="line"><span class="comment"> * Note that this function takes the reference to the hash table view of the</span></span><br><span class="line"><span class="comment"> * sorted set, in order to remove the elements from the hash table too. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">zslDeleteRangeByScore</span><span class="params">(zskiplist *zsl, zrangespec *range, dict *dict)</span> &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (range-&gt;minex ?</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt;= range-&gt;min :</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt; range-&gt;min))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Current node is the last with score &lt; or &lt;= min. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete nodes while in range. */</span></span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp;</span><br><span class="line">           (range-&gt;maxex ? x-&gt;score &lt; range-&gt;max : x-&gt;score &lt;= range-&gt;max))</span><br><span class="line">    &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>需要注意的是minex为1表示包括左边是开区间，为0表示闭区间，maxex为1表示右边为开区间，为0表示闭区间。</p>
<p><strong>删除排名在[start, end]之间的所有节点，包含start和end</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete all the elements with rank between start and end from the skiplist.</span></span><br><span class="line"><span class="comment"> * Start and end are inclusive. Note that start and end need to be 1-based */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">zslDeleteRangeByRank</span><span class="params">(zskiplist *zsl, <span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end, dict *dict)</span> &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> traversed = <span class="number">0</span>, removed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt; start) &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traversed++;</span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; traversed &lt;= end) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        traversed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://redisbook.com/preview/skiplist/content.html">Redis设计与实现</a><br><a href="https://github.com/antirez/redis/releases/tag/3.0.6">Redis源码3.0.6</a><br><a href="http://blog.jobbole.com/111731/">漫画算法：什么是跳跃表？</a><br><a href="https://blog.csdn.net/ict2014/article/details/17394259">浅析SkipList跳跃表原理及代码实现</a><br><a href="https://blog.csdn.net/gqtcgq/article/details/50613896">Redis源码解析：05跳跃表</a><br><a href="https://www.aliyun.com/jiaocheng/354425.html">__typeof__() 、 __typeof（） 、 typeof（）的区别</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Key-Value存储系统</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码阅读--整数集合</title>
    <url>/2018/06/05/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB--%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis就会使用整数集合作为集合键的底层实现。本文主要介绍Redis源码中的整数数组。主要内容如下：</p>
<ul>
<li>Redis中的整数集合实现及特点</li>
<li>Redis中的整数集合源码难点分析</li>
<li>Redis中的整数集合源码部分节选</li>
</ul>
<hr>
<h3 id="Redis中的整数集合实现及特点"><a href="#Redis中的整数集合实现及特点" class="headerlink" title="Redis中的整数集合实现及特点"></a>Redis中的整数集合实现及特点</h3><p><strong>整数集合的具体实现</strong><br>在头文件intset.h中，相关API在intset.c中；整数集合的数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;<span class="comment">//保存元素所使用类型的长度</span></span><br><span class="line">    <span class="type">uint32_t</span> length;<span class="comment">//保存元素的个数</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];<span class="comment">//保存元素的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p>
<p><strong>整数集合相关API</strong>  </p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">作用</th>
<th style="text-align:right">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>intsetNew</td>
<td style="text-align:center">创建一个新的整数集合</td>
<td style="text-align:right">O(1)</td>
</tr>
<tr>
<td>intsetAdd</td>
<td style="text-align:center">将指定元素添加到整数集合中</td>
<td style="text-align:right">O(N)</td>
</tr>
<tr>
<td>intsetRemove</td>
<td style="text-align:center">从整数集合中移除指定元素</td>
<td style="text-align:right">O(N)</td>
</tr>
<tr>
<td>intsetFind</td>
<td style="text-align:center">查找指定的值是否在集合中</td>
<td style="text-align:right">因数组有序，可通过二分查找法来进行，故复杂度为O(logN)</td>
</tr>
<tr>
<td>intsetRandom</td>
<td style="text-align:center">从整数集合中随机返回一个元素</td>
<td style="text-align:right">O(1)</td>
</tr>
<tr>
<td>intsetGet</td>
<td style="text-align:center">获取指定索引上的元素</td>
<td style="text-align:right">O(1)</td>
</tr>
<tr>
<td>intsetLen</td>
<td style="text-align:center">返回整数集合包含的元素个数</td>
<td style="text-align:right">O(1)</td>
</tr>
<tr>
<td>intsetBlobLen</td>
<td style="text-align:center">返回整数集合占用的内存字节数</td>
<td style="text-align:right">O(1)</td>
</tr>
</tbody>
</table>
<p><strong>整数集合特点</strong>  </p>
<ul>
<li>新建整数集合时，其encoding是int16_t类型</li>
<li>只支持升级，不支持降级</li>
<li>查找使用二分查找法</li>
<li>整数集合的底层实现为数组，这个数组以<strong>有序、无重复</strong>的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型，改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
</ul>
<p>创建一个空的inset<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an empty intset. */</span></span><br><span class="line">intset *<span class="title function_">intsetNew</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Redis中的整数集合源码难点分析"><a href="#Redis中的整数集合源码难点分析" class="headerlink" title="Redis中的整数集合源码难点分析"></a>Redis中的整数集合源码难点分析</h3><p><strong>小端模式与大端模式</strong><br><strong>小端模式</strong>：按照从低地址到高地址的顺序，依次存放数据的低字节到高字节<br><strong>大端模式</strong>：按照从低地址到高地址的顺序，依次存放数据的高字节到低字节<br>详细介绍可参考<a href="http://blog.163.com/shengrui_step/blog/static/20870918720139103944374/">计算机中的小端模式和大端模式</a><br>比如0x1234abcd，分别用大小端表示如下：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">低地址</th>
<th style="text-align:right">高地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>小端模式</td>
<td style="text-align:center">0xcd  0xab</td>
<td style="text-align:right">0x34  0x12</td>
</tr>
<tr>
<td>大端模式</td>
<td style="text-align:center">0x12  0x34</td>
<td style="text-align:right">0xab  0xcd</td>
</tr>
</tbody>
</table>
<p>Redis中有关大小端的部分代码如下:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Toggle the 16 bit unsigned integer pointed by *p from little endian to</span></span><br><span class="line"><span class="comment"> * big endian */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memrev16</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Toggle the 32 bit unsigned integer pointed by *p from little endian to</span></span><br><span class="line"><span class="comment"> * big endian */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memrev32</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* variants of the function doing the actual convertion only if the target</span></span><br><span class="line"><span class="comment"> * host is big endian */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (BYTE_ORDER == LITTLE_ENDIAN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> memrev16ifbe(p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> memrev32ifbe(p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> memrev64ifbe(p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> intrev16ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> intrev32ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> intrev64ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> memrev16ifbe(p) memrev16(p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> memrev32ifbe(p) memrev32(p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> memrev64ifbe(p) memrev64(p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> intrev16ifbe(v) intrev16(v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> intrev32ifbe(v) intrev32(v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> intrev64ifbe(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="Redis中的整数集合源码部分节选"><a href="#Redis中的整数集合源码部分节选" class="headerlink" title="Redis中的整数集合源码部分节选"></a>Redis中的整数集合源码部分节选</h3><p><strong>在整数集合中查找一个值，利用二分查找</strong><br>如果找到返回1，pos返回该值在整数集合中的位置；如果没有找到返回0，pos值为当前值value应该插入的位置。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets &quot;pos&quot; to the position</span></span><br><span class="line"><span class="comment"> * where &quot;value&quot; can be inserted. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">intsetSearch</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint32_t</span> *pos)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)<span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="type">unsigned</span> <span class="type">int</span>)min + (<span class="type">unsigned</span> <span class="type">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为整数集合是有序的，所以其中数组最后一个元素是最大的，第一个元素是最小的，如果当前value值比最大值还大，那当前插入位置应该是<em>pos = intrev32ifbe(is-&gt;length);如果比最小值还小，那么插入位置就应该是 </em>pos = 0;<br>再下面就是一个二分查找。</p>
<p><strong>升级集合并往整数集合中添加给定的整数</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">	<span class="comment">/*1表示头，0表示尾*/</span></span><br><span class="line">	<span class="comment">/*如果是小于0的数，那自然比所有数都小，所以添加到头部*/</span></span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="comment">/*从后往前，按原来的curenc把值取出来，重新按占newenc大小放到数组中去</span></span><br><span class="line"><span class="comment">    prepend为1，表示添加的元素要放到最前面，所以原来位置的值都往后移动一个位置*/</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>往集合中添加元素</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line">intset *<span class="title function_">intsetAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint8_t</span> *success)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate &quot;pos&quot; with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中intsetMoveTail是将pos位置往后的所有元素移动到pos+1位置，就是为当前要加入的元素挪出一个位置。具体实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">intsetMoveTail</span><span class="params">(intset *is, <span class="type">uint32_t</span> from, <span class="type">uint32_t</span> to)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *src, *dst;</span><br><span class="line">    <span class="type">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    <span class="type">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="type">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="type">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="type">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="type">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="type">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="type">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="type">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="type">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="type">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要说明的是，intsetMoveTail这个函数也可以往前挪动，比如删除元素的时候：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete integer from intset */</span></span><br><span class="line">intset *<span class="title function_">intsetRemove</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">int</span> *success)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> len = intrev32ifbe(is-&gt;length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We know we can delete */</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Overwrite value with tail and update length */</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (len<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</span><br><span class="line">        is = intsetResize(is,len<span class="number">-1</span>);</span><br><span class="line">        is-&gt;length = intrev32ifbe(len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>返回整数集合含有元素个数</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return intset length */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">intsetLen</span><span class="params">(intset *is)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> intrev32ifbe(is-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>返回整数集合占用的内存字节数</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return intset blob size in bytes. */</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">intsetBlobLen</span><span class="params">(intset *is)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(intset)+intrev32ifbe(is-&gt;length)*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>查找指定元素</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">intsetFind</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果查找的元素的类型使用的长度比当前集合的使用的类型长度encoding都还大，肯定就不在集合中咯，intsetSearch参考前面的说明。</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://redisbook.com/preview/skiplist/content.html">Redis设计与实现</a><br><a href="https://github.com/antirez/redis/releases/tag/3.0.6">Redis源码3.0.6</a><br><a href="http://blog.163.com/shengrui_step/blog/static/20870918720139103944374/">计算机中的小端模式和大端模式</a> </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Key-Value存储系统</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码阅读--压缩列表</title>
    <url>/2018/06/06/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB--%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>压缩列表（ziplist）</p>
<ul>
<li>Redis中的压缩列表实现及特点</li>
<li>Redis中的压缩列表源码难点分析</li>
<li>Redis中的压缩列表源码部分节选</li>
</ul>
<hr>
<h3 id="一、Redis中的压缩列表实现及特点"><a href="#一、Redis中的压缩列表实现及特点" class="headerlink" title="一、Redis中的压缩列表实现及特点"></a>一、Redis中的压缩列表实现及特点</h3><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。</p>
<p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。如下图（摘自《Redis设计与实现》）：</p>
<p><img src="http://redisbook.com/_images/graphviz-fe42f343a3f32f477efb5e895da547d476a7c97d.png" alt=""></p>
<p>其中字段含义如下：</p>
<ul>
<li>zlbytes：占4个字节，记录整个压缩列表占用的内存字节数</li>
<li>zltail_offset：占4个字节，记录压缩列表尾节点entryN距离压缩列表的起始地址的字节数</li>
<li>zllength：占2个字节，记录了压缩列表的节点数量</li>
<li>entry[1-N]：长度不定，保存数据</li>
<li>zlend：占1个字节，保存一个常数255(0xFF)，标记压缩列表的末端。</li>
</ul>
<h4 id="1-创建一个空的压缩列表"><a href="#1-创建一个空的压缩列表" class="headerlink" title="1. 创建一个空的压缩列表"></a>1. 创建一个空的压缩列表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNew</span><span class="params">(<span class="type">void</span>)</span> &#123;   <span class="comment">//创建并返回一个新的且空的压缩列表</span></span><br><span class="line">    <span class="comment">//ZIPLIST_HEADER_SIZE是压缩列表的表头大小，1字节是末端的end大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = zmalloc(bytes); <span class="comment">//为表头和表尾end成员分配空间</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes); <span class="comment">//将bytes成员初始化为bytes=11字节</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);  <span class="comment">//空列表的tail_offset成员为表头大小为10</span></span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;     <span class="comment">//节点数量为0</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;      <span class="comment">//将表尾end成员设置成默认的0xFF</span></span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关的宏定义<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span></span><br></pre></td></tr></table></figure></p>
<p>一个空的压缩列表：<br><img src="https://img-blog.csdn.net/20170414230708914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWVuX3dlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h4 id="2-压缩列表节点结构"><a href="#2-压缩列表节点结构" class="headerlink" title="2. 压缩列表节点结构"></a>2. 压缩列表节点结构</h4><p><img src="http://redisbook.com/_images/graphviz-cc6b40e182bfc142c12ac0518819a2d949eafa4a.png" alt=""></p>
<p><strong>压缩列表节点中的previous_entry_length</strong></p>
<p>previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度<strong><em>小于254字节</em></strong>， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面</li>
<li>如果前一节点的长度<strong><em>大于等于254字节</em></strong>， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>因此可以看到这段获取前一个节点长度的宏定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Decode the length of the previous element, from the perspective of the entry</span></span><br><span class="line"><span class="comment"> * pointed to by &#x27;ptr&#x27;. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do &#123;                     \</span></span><br><span class="line"><span class="meta">    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((prevlensize) == 1) &#123;                                                  \</span></span><br><span class="line"><span class="meta">        (prevlen) = (ptr)[0];                                                  \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((prevlensize) == 5) &#123;                                           \</span></span><br><span class="line"><span class="meta">        assert(sizeof((prevlensize)) == 4);                                    \</span></span><br><span class="line"><span class="meta">        memcpy(&amp;(prevlen), ((char*)(ptr)) + 1, 4);                             \</span></span><br><span class="line"><span class="meta">        memrev32ifbe(&amp;prevlen);                                                \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0);</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p>
</blockquote>
<h3 id="二、Redis中的压缩列表源码难点分析"><a href="#二、Redis中的压缩列表源码难点分析" class="headerlink" title="二、Redis中的压缩列表源码难点分析"></a>二、Redis中的压缩列表源码难点分析</h3><h4 id="1-压缩列表节点中的encoding"><a href="#1-压缩列表节点中的encoding" class="headerlink" title="1. 压缩列表节点中的encoding"></a>1. 压缩列表节点中的encoding</h4><p>压缩列表节点的 encoding属性记录了节点的 content 属性所保存数据的类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<p>表格中的下划线 _ 表示留空， 而 b 、 x 等变量则代表实际的二进制数据， 为了方便阅读， 多个字节之间用空格隔开。</p>
<p>字节数组编码：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th style="text-align:center">编码长度</th>
<th style="text-align:right">content保存的值长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>00bbbbbb</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:right">长度小于等于 2^6 −1 字节</td>
</tr>
<tr>
<td>01bbbbbb xxxxxxxx</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:right">长度小于等于 2^14 −1 字节</td>
</tr>
<tr>
<td>10______ aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td style="text-align:center">5 字节</td>
<td style="text-align:right">长度小于等于2^32 −1字节</td>
</tr>
</tbody>
</table>
<p>整数编码：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th style="text-align:center">编码长度</th>
<th style="text-align:right">content保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1100 0000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:right">16位有符号整数（int16_t 类型的整数）</td>
</tr>
<tr>
<td>1101 0000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:right">int32_t 类型的整数</td>
</tr>
<tr>
<td>1110 0000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:right">int64_t 类型的整数表示的范围</td>
</tr>
<tr>
<td>1111 0000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:right">24位有符号整数表示的范围</td>
</tr>
<tr>
<td>1111 1110（0xfe）</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:right">8位有符号整数表示的范围</td>
</tr>
<tr>
<td>1111 xxxx</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:right">4位立即数介于0-12之间，无对应value，保存在encoding</td>
</tr>
</tbody>
</table>
<p>关于1111 xxxx编码：1111 xxxx 首先最小值应该是1111 0001（1111 0000已经被占用），最大值应该是1111 1101（1111 1110与1111 1111均已经被占用），因此可用的编码值只能是 1 至 13，由于还需要减1，所以实际只能编码[0,12]</p>
<p>Redis提供的有关字节数组和整数编码的宏定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_MASK 0xc0               <span class="comment">//1100 0000    字节数组的掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)            <span class="comment">//0000 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)            <span class="comment">//0100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)            <span class="comment">//1000 0000</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_MASK 0x30               <span class="comment">//0011 0000     整数的掩码</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)       <span class="comment">//1100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)       <span class="comment">//1101 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)       <span class="comment">//1110 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)       <span class="comment">//1111 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_8B 0xfe                 <span class="comment">//1111 1110</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//掩码个功能就是区分一个encoding是字节数组编码还是整数编码</span></span><br><span class="line"><span class="comment">//如果这个宏返回 1 就代表该enc是字节数组，如果是 0 就代表是整数的编码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)</span></span><br></pre></td></tr></table></figure></p>
<p>下面这段代码主要是为了获取一个压缩列表节点所占用的长度。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Extract the encoding from the byte pointed by &#x27;ptr&#x27; and set it into</span></span><br><span class="line"><span class="comment"> * &#x27;encoding&#x27;. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \</span></span><br><span class="line"><span class="meta">    (encoding) = (ptr[0]); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the length encoded in &#x27;ptr&#x27;. The &#x27;encoding&#x27; variable will hold the</span></span><br><span class="line"><span class="comment"> * entries encoding, the &#x27;lensize&#x27; variable will hold the number of bytes</span></span><br><span class="line"><span class="comment"> * required to encode the entries length, and the &#x27;len&#x27; variable will hold the</span></span><br><span class="line"><span class="comment"> * entries length. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do &#123;                    \</span></span><br><span class="line"><span class="meta">    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) &#123;                                           \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((encoding) == ZIP_STR_06B) &#123;                                       \</span></span><br><span class="line"><span class="meta">            (lensize) = 1;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = (ptr)[0] &amp; 0x3f;                                           \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((encoding) == ZIP_STR_14B) &#123;                                \</span></span><br><span class="line"><span class="meta">            (lensize) = 2;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1];                       \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_STR_32B) &#123;                                  \</span></span><br><span class="line"><span class="meta">            (lensize) = 5;                                                     \</span></span><br><span class="line"><span class="meta">            (len) = ((ptr)[1] &lt;&lt; 24) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[2] &lt;&lt; 16) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[3] &lt;&lt;  8) |                                         \</span></span><br><span class="line"><span class="meta">                    ((ptr)[4]);                                                \</span></span><br><span class="line"><span class="meta">        &#125; <span class="keyword">else</span> &#123;                                                               \</span></span><br><span class="line"><span class="meta">            assert(NULL);                                                      \</span></span><br><span class="line"><span class="meta">        &#125;                                                                      \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        (lensize) = 1;                                                         \</span></span><br><span class="line"><span class="meta">        (len) = zipIntSize(encoding);                                          \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the number of bytes required to store the length of the previous</span></span><br><span class="line"><span class="comment"> * element, from the perspective of the entry pointed to by &#x27;ptr&#x27;. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do &#123;                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((ptr)[0] &lt; ZIP_BIGLEN) &#123;                                               \</span></span><br><span class="line"><span class="meta">        (prevlensize) = 1;                                                     \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span></span><br><span class="line"><span class="meta">        (prevlensize) = 5;                                                     \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the total number of bytes used by the entry pointed to by &#x27;p&#x27;. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">zipRawEntryLength</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevlensize, encoding, lensize, len;</span><br><span class="line">    ZIP_DECODE_PREVLENSIZE(p, prevlensize);</span><br><span class="line">    ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</span><br><span class="line">    <span class="keyword">return</span> prevlensize + lensize + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ZIP_ENTRY_ENCODING中ZIP_STR_MASK为0xc0对应（1100 0000），小于0xc0的就表示编码为字节数组，大于0xc0的就表示编码为整数数组。需要注意的是，当encoding长度为5个字节时，表示的字节数组的长度由低32位表示，所以其长度为(len) = ((ptr)[1] &lt;&lt; 24) |  ((ptr)[2] &lt;&lt; 16) | ((ptr)[3] &lt;&lt;  8) | (ptr)[4])</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://redisbook.com/preview/skiplist/content.html">Redis设计与实现</a><br><a href="https://github.com/antirez/redis/releases/tag/3.0.6">Redis源码3.0.6</a><br><a href="https://blog.csdn.net/men_wen/article/details/70176753">Redis源码剖析和注释（六）— 压缩列表(ziplist)</a> </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Key-Value存储系统</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下so动态链接库使用总结</title>
    <url>/2018/06/13/%E8%A6%86%E7%9B%96so%E5%AF%BC%E8%87%B4coredump%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文主要总结在Linux环境下，使用so动态链接库经常遇到的问题，包括使用cp命令覆盖so导致进程coredump之类的问题。<br>主要有以下内容：</p>
<ul>
<li>Linux下so动态链接库介绍</li>
<li>ldconfig命令的使用</li>
<li>so动态库使用的常见问题</li>
</ul>
<hr>
<h3 id="一、Linux下so动态链接库介绍"><a href="#一、Linux下so动态链接库介绍" class="headerlink" title="一、Linux下so动态链接库介绍"></a>一、Linux下so动态链接库介绍</h3><p>在介绍动态库前，提一个问题：到底什么是库呢？</p>
<p>库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。</p>
<p>静态库：这类库的名字一般是libxxx.a，xxx为库的名字。利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。</p>
<p>动态库：这类库的名字一般是libxxx.M.N.so，同样的xxx为库的名字，M是库的主版本号，N是库的副版本号。当然也可以不要版本号，但名字必须有。相对于静态函数库，动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。linux系统有几个重要的目录存放相应的函数库，如/lib和/usr/lib。</p>
<p>本文主要介绍动态库。</p>
<p>Linux下动态库文件的文件名形如 <strong>libxxx.so</strong>，其中so是 <strong>Shared Object</strong> 的缩写，即可以共享的目标文件。</p>
<p>共享文件（*.so）也称为动态库文件，它包含了代码和数据（这些数据是在连接时候被连接器ld和运行时动态连接器使用的）。动态连接器可能称为ld.so.1，libc.so.1或者 ld-linux.so.1。我的CentOS6.0系统中该文件为：/lib/ld-2.12.so</p>
<p>在链接动态库生成可执行文件时，并不会把动态库的代码复制到执行文件中，而是在执行文件中记录对动态库的引用。<br>程序执行时，再去加载动态库文件。如果动态库已经加载，则不必重复加载，从而能节省内存空间。<br><strong>程序动态链接的优点</strong>是</p>
<ol>
<li>减少依赖相同动态库的多个进程同时运行时的内存的占用（不用每一个进程都加载一份动态库</li>
<li>可扩展性在程序不用重启的情况下，动态的加载所需要的动态库，可实现对程序的扩展</li>
<li>程序版本更新与动态链接库的分离  </li>
</ol>
<p><strong><em>Linux下生成和使用动态库的步骤如下：</em></strong></p>
<ol>
<li>编写源文件</li>
<li>使用命令： gcc -fPIC -shared -o libxxx.so xxx.c，将一个或几个源文件编译链接，生成共享库</li>
<li>通过 -L<path> -lxxx 的gcc选项链接生成的libxxx.so。</li>
<li>把libxxx.so放入链接库的标准路径，或指定 LD_LIBRARY_PATH，才能运行链接了libxxx.so的程序。</li>
</ol>
<p>具体示例请参考：<a href="https://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html">Linux动态库生成与使用指南</a></p>
<p><strong>查看程序使用的动态库</strong><br>基本上每一个linux 程序都会使用动态库，查看某个程序使用了那些动态库，可以使用ldd命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ldd /bin/ls</span></span><br><span class="line">linux-vdso.so.1 =&gt; (0x00007fff597ff000)</span><br><span class="line">libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00000036c2e00000)</span><br><span class="line">librt.so.1 =&gt; /lib64/librt.so.1 (0x00000036c2200000)</span><br><span class="line">libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00000036c4a00000)</span><br><span class="line">libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00000036d0600000)</span><br><span class="line">libc.so.6 =&gt; /lib64/libc.so.6 (0x00000036c1200000)</span><br><span class="line">libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00000036c1600000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00000036c0e00000)</span><br><span class="line">libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00000036c1a00000)</span><br><span class="line">libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00000036cf600000)</span><br></pre></td></tr></table></figure></p>
<h3 id="二、ldconfig命令的使用"><a href="#二、ldconfig命令的使用" class="headerlink" title="二、ldconfig命令的使用"></a>二、ldconfig命令的使用</h3><p>ldconfig命令是在Linux环境下使用so动态链接库时，经常会用到的命令，是Linux下动态链接库的管理命令，<strong>该命令位于/sbin目录下</strong>。  </p>
<p>ldconfig命令的用途主要是在默认搜寻目录/lib和/usr/lib以及动态库配置文件/etc/ld.so.conf内所列的目录下，搜索出可共享的动态链接库（格式如lib<em>.so</em>）,进而创建出动态装入程序(ld.so)所需的连接和缓存文件。缓存文件默认为/etc/ld.so.cache，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令ldconfig，此执行程序存放在/sbin目录下。</p>
<blockquote>
<p>ldconfig通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。</p>
</blockquote>
<p><strong>使用ldconfig几个需要注意的地方：</strong></p>
<ol>
<li>往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但是完了之后要调一下ldconfig，不然这个library会找不到。</li>
<li>想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，然后再调用ldconfig，不然也会找不到。</li>
<li>比如安装了一个mysql到/usr/local/mysql，mysql有一大堆library在/usr/local/mysql/lib下面，这时就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存过后ldconfig一下，新的library才能在程序运行时被找到。</li>
<li>如果想在这两个目录以外放lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。那也可以，就是export一个全局变量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用,因为这样的export 只对当前shell有效，当另开一个shell时候，又要重新设置，当然可以把export LD_LIBRARY_PATH=xxx 语句写到 ~/.bashrc中，这样就对当前用户有效了，写到/etc/bashrc中就对所有用户有效了。</li>
</ol>
<p><strong>程序执行时的搜索顺序</strong><br>程序执行时按照下列顺序依次装载或者查找共享对象:<br>0）最优先的是，如果在编译时通过-rpath选项指定了路径，便会优先搜索这个路径<br>1）由环境变量 LD_LIBRARY_PATH指定的路径<br>2）由路径缓存文件/etc/ld.so.cache指定的路径<br>3）默认共享目录 /lib和/usr/lib<br>其中LD_LIBRARY_PATH是一个环境变量，当指定某个程序的LD_LIBRARY_PATH时<br>动态链接器在查找共享库的时候，<strong>会首先从指定的路径开始查找</strong></p>
<h3 id="三、so动态库使用的常见问题"><a href="#三、so动态库使用的常见问题" class="headerlink" title="三、so动态库使用的常见问题"></a>三、so动态库使用的常见问题</h3><p>介绍完so动态链接库的常见使用之后，下面介绍两个常见的问题：<br>一个是cp命令拷贝一个新的so去覆盖旧的so时，如果有进程或者程序正常使用这个so，那么该操作极有可能导致该进程coredump或者程序崩溃；<br>另一个问题是多个进程或程序都在使用同一个so，但是这个so的路径和版本均不同，那么使用ldconfig命令可能导致另一个进程或者程序出错。</p>
<h4 id="1-覆盖so导致coredump问题总结"><a href="#1-覆盖so导致coredump问题总结" class="headerlink" title="1. 覆盖so导致coredump问题总结"></a>1. 覆盖so导致coredump问题总结</h4><p>出现问题的场景是升级，在升级流程的脚本中需要升级各个业务进程使用的so，但是有一个so文件是两个业务进程都在同时使用。比如有业务进程A、B、C，升级的过程是:A-&gt;B-&gt;C。其中有so是A和B都依赖，在升级A的过程中，先停掉A进程，升级其需要的so，这个时候升级so，使用的命令是cp，升级完so后，升级A进程使用的二进制，然后拉起A进程。在这一系列的过程中发现B进程coredump了，主要是没有考虑到B进程也在使用那个so。</p>
<p><strong>cp与mv/rm的区别：</strong></p>
<p>cp from to，则被覆盖文件 to的inode依旧不变（属性也不变），内容变为from的；</p>
<p>mv from to，则to的inode变为from的，相应的，to的属性也成了from的；rm类似；</p>
<p>关于为什么会coredump可参考：<a href="https://www.cnblogs.com/zhaoyl/p/4964811.html">关于so文件cp覆盖导致调用者core的研究</a></p>
<p><strong>解决方法</strong></p>
<blockquote>
<p>方法一：<br>先删除旧的so，然后再把新的so拷贝过去，即：<br>rm oldlib.so 然后 cp newlib.so oldlib.so</p>
</blockquote>
<blockquote>
<p>方法二：<br>mv oldlib.so oldlib.so_bak 然后 cp newlib.so oldlib.so</p>
</blockquote>
<h4 id="2-一次执行ldconfig导致别的模块进程挂掉的经历"><a href="#2-一次执行ldconfig导致别的模块进程挂掉的经历" class="headerlink" title="2. 一次执行ldconfig导致别的模块进程挂掉的经历"></a>2. 一次执行ldconfig导致别的模块进程挂掉的经历</h4><p><strong>问题原因是：</strong><br>与我们服务共同部署在同一个Linux服务器的其他服务也使用了zk服务，需要用到zk的动态链接库，我们的业务进程也需要用到zk的动态链接库。本来最初相安无事，但是在执行一个脚本之后，发现他们的服务挂了，经定位发现是因为so使用有问题，用到了我们服务进程的路径下的zk的动态链接库。在那个shell脚本中，直接用了“ldconfig + 路径”的方式搜索指定路径的so，随后导致他们的服务链接到我们的zk动态链接库了，而这动态链接库是有区别的，最终导致他们的服务挂掉。</p>
<p><strong>解决方法</strong></p>
<p>方法一：检查使用ldconfig的地方，在多种服务共同使用的服务器上，不能直接用“ldconfig + 路径”的方式随意添加一些常用的so路径（诸如zk这样常用的服务），诸如多种服务共同部署的时候，要注意避免这种情况；如果要调用脚本使用，可以通过export LD_LIBRARY_PATH的方式临时添加。</p>
<p>方法二（推荐）：在编译的时候通过gcc -rpath 就指定动态库路径，这样就可以避免被其他路径下的不同的版本的so干扰。可以参考：<a href="https://blog.csdn.net/v6543210/article/details/44809405">gcc -rpath 指定动态库路径</a></p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/poetic_vienna/article/details/51249660">有关Linux下库的概念、生成和升级和使用等</a><br><a href="http://blog.chinaunix.net/uid-27105712-id-3313293.html">linux下so动态库一些不为人知的秘密（上）</a><br><a href="http://blog.chinaunix.net/uid-27105712-id-3313327.html">linux下so动态库一些不为人知的秘密（中）</a><br><a href="https://blog.csdn.net/aganlengzi/article/details/44088239">Linux共享库.so文件的命名和动态链接</a><br><a href="https://www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html">Linux动态库生成与使用指南</a><br><a href="http://man.linuxde.net/ldconfig">ldconfig命令</a><br><a href="https://www.cnblogs.com/cnland/archive/2013/03/19/2969337.html">Linux共享库(so)动态加载和升级</a><br><a href="https://blog.csdn.net/v6543210/article/details/44809405">gcc -rpath 指定动态库路径</a><br><a href="http://blog.jobbole.com/107977/">Linux系统中“动态库”和“静态库”那点事儿</a><br><a href="https://www.cnblogs.com/zhaoyl/p/4964811.html">关于so文件cp覆盖导致调用者core的研究</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>日常积累</tag>
        <tag>so</tag>
        <tag>coredump</tag>
      </tags>
  </entry>
  <entry>
    <title>实际项目中对Linux的profile.d目录的使用</title>
    <url>/2018/06/21/Linux%E9%85%8D%E7%BD%AE%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%8Cprofile.d%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在Linux环境下，/etc/profile文件中/etc/profile.d目录下均可以设置环境变量，本文主要介绍/etc/profile文件中/etc/profile.d目录；并举一个示例，展示在实际项目中如何使用的/etc/profile.d目录。<br>主要有以下内容：</p>
<ul>
<li>/etc/profile 文件</li>
<li>/etc/profile.d 目录中的脚本文件</li>
<li>/etc/profile和/etc/profile.d 的区别和用法</li>
<li>项目中使用的实例</li>
</ul>
<hr>
<h2 id="一、-etc-profile-文件"><a href="#一、-etc-profile-文件" class="headerlink" title="一、/etc/profile 文件"></a>一、/etc/profile 文件</h2><p>当一个用户登录Linux系统或使用su -命令切换到另一个用户时，也就是Login shell 启动时，首先要确保执行的启动脚本就是 /etc/profile 。<br>关于linux下 /etc/profile、~/.bash_profile ~/.profile的执行过程，请参考：<a href="https://blog.csdn.net/caiwenfeng_for_23/article/details/44242961">linux下 /etc/profile、~/.bash_profile ~/.profile的执行过程</a>  </p>
<p><strong>注意：只有Login shell 启动时才会运行 /etc/profile 这个脚本，而Non-login shell 不会调用这个脚本。</strong><br>如何区分Login shell 与Non-login shell，可以在shell下运行echo $0:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$0</span></span></span><br></pre></td></tr></table></figure><br>假设输出为该shell名字，加上一个<strong>‘-‘</strong>前缀。则说明该shell为login shell。<br>详细介绍请参考：<a href="https://www.cnblogs.com/wzzkaifa/p/7169640.html">/etc/profile与/etc/bashrc、交互式与非交互式、login与non-login shell的差别</a></p>
<p>一些重要的变量就是在这个脚本文件中设置的，含义如下：</p>
<p>PATH： 预设可执行文件或命令的搜索路径。</p>
<p>USER: 用户登录时使用的用户名。</p>
<p>LOGNAME: 其值为$USER。</p>
<p>HOSTNAME: 所使用的主机名。</p>
<p>MAIL： 存放用户电子邮件的邮箱（实际上是一个ASCII码文件）。</p>
<p>HISTSIZE： 历史记录的行数。</p>
<p>INPUTRC: 存放的是针对键盘热键的信息（也是一个ASCII码文件）。</p>
<p>要注意的是<strong>在/etc/profile 文件中设置的变量是全局变量</strong>。</p>
<h2 id="二、-etc-profile-d-目录中的脚本文件"><a href="#二、-etc-profile-d-目录中的脚本文件" class="headerlink" title="二、/etc/profile.d 目录中的脚本文件"></a>二、/etc/profile.d 目录中的脚本文件</h2><p>在/etc/profile.d 目录中存放的是一些应用程序所需的启动脚本，其中包括了颜色、语言、less、vim及which等命令的一些附加设置。</p>
<p>这些脚本文件之所以能够 被自动执行，是因为<strong>在/etc/profile 中使用一个for循环语句来调用这些脚本</strong>。而这些脚本文件是用来设置一些变量和运行一些初始化过程的。<br>/etc/profile中循环调用/etc/profile.d/目录下脚本的代码片段：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -d /etc/profile.d ]; then</span><br><span class="line">  for i in /etc/profile.d/*.sh; do</span><br><span class="line">    if [ -r $i ]; then</span><br><span class="line">      . $i</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">  unset i</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<h2 id="三、-etc-profile和-etc-profile-d-的区别和用法"><a href="#三、-etc-profile和-etc-profile-d-的区别和用法" class="headerlink" title="三、/etc/profile和/etc/profile.d 的区别和用法"></a>三、/etc/profile和/etc/profile.d 的区别和用法</h2><p><strong>区别</strong>：  </p>
<ol>
<li>两个文件都是设置环境变量文件的，/etc/profile是永久性的环境变量,是全局变量，/etc/profile.d/设置所有用户生效  </li>
<li>/etc/profile.d/比/etc/profile好维护，不想要什么变量直接删除/etc/profile.d/下对应的shell脚本即可，不用像/etc/profile需要改动此文件  </li>
</ol>
<p><strong>用法</strong><br>Linux每个用户都要指定各自的环境变量，其中包括可执行的path路径，这些路径决定了每个用户在执行时的命令工具。 </p>
<p>一般情况下，可以在每个用户的环境变量里设定各自的PATH变量值，然后再执行export PATH使其生效，但如果用户比较多，安装命令工具也原来越多，且除了本身用户可以执行这些工具，root用户或其他用户也可以执行命令，这时在每个用户环境变量里添加就比较复杂了。</p>
<p>所以可以用另外一种方法：</p>
<p>可以在/etc/profile.d/ 目录下创建一个 path.sh 脚本，脚本内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /etc/profile.d/path.sh</span></span><br><span class="line"></span><br><span class="line">export PATH=&quot;/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/sbin&quot;</span><br></pre></td></tr></table></figure>
<p>可以将需要各个用户需要执行的命令路径都写在该命令中，这样每次操作系统启动后，会自动执行path.sh脚本，将所有的环境变量生效，让各个用户都可以直接执行各自的命令。</p>
<p>以后安装了新软件后，只需要将软件相关路径加入 /etc/profile.d/path.sh 脚本中，不需要再多个地方重复添加，使脚本生效后，各个用户都可以使用了。</p>
<p>后面实际项目的示例也是采用的这种方法。</p>
<h2 id="四、项目中使用的实例"><a href="#四、项目中使用的实例" class="headerlink" title="四、项目中使用的实例"></a>四、项目中使用的实例</h2><p><strong>背景</strong> ：一个整体的服务内部分为A、B、C三个微服务，其中B和C都需要调用微服务A提供的接口，其接口以so的形式提供。那就需要我们在安装好微服务A时，就能告诉B和C，我们提供的so路径在哪。这种情况该如何做呢？</p>
<p><strong>实际做法</strong>：<br>参考上面说的/etc/profile.d/的用法，比如我们提供的so路径在/opt/new_test/lib/目录下，还有可执行工具在/opt/new_test/tool下；那么在我们安装部署微服务A的时候就需要指定这两个路径。</p>
<p>安装的脚本,比如叫install_A.sh就需要包含如下类似的内容来设置环境变量：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">do</span> something install A</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">env_file=&quot;/etc/profile.d/set_A_env.sh&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/new_test/lib/&#x27; &gt; $env_file</span><br><span class="line"></span><br><span class="line">echo &#x27;export PATH=$PATH:/opt/new_test/tool&#x27; &gt;&gt; $env_file</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><br>通过如上设定，微服务A安装完成之后，环境变量已经设置OK，等微服务B和C安装起来之后就能从环境变量中找到我们指定的so的路径。</p>
<p>卸载时的脚本中比如叫uninstall_A.sh中需要包含如下类似的内容来清除环境变量：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">do</span> something <span class="keyword">for</span> uninstall...</span></span><br><span class="line">...</span><br><span class="line">env_file=&quot;/etc/profile.d/set_A_env.sh&quot;</span><br><span class="line"></span><br><span class="line">rm -f $&#123;env_file&#125;</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/u011277123/article/details/72864826">etc/profile 文件和/etc/profile.d</a><br><a href="https://blog.csdn.net/efine_dxq/article/details/54601117">Linux 环境下/etc/profile和/etc/profile.d 的区别和用法</a><br><a href="https://blog.csdn.net/justweb/article/details/61221567">linux 配置全用户的环境变量，profile.d文件夹的作用</a><br><a href="https://blog.csdn.net/caiwenfeng_for_23/article/details/44242961">linux下 /etc/profile、~/.bash_profile ~/.profile的执行过程</a><br><a href="https://www.cnblogs.com/wzzkaifa/p/7169640.html">/etc/profile与/etc/bashrc、交互式与非交互式、login与non-login shell的差别</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>日常积累</tag>
        <tag>环境变量</tag>
        <tag>profile profile.d</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab基本用法及常见问题定位</title>
    <url>/2018/12/17/crontab%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>本文主要介绍crontab的基本用法及常见问题定位。</p>
<hr>
<h2 id="一、crontab的基本用法"><a href="#一、crontab的基本用法" class="headerlink" title="一、crontab的基本用法"></a>一、crontab的基本用法</h2><p>我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。<br>/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名<br>/etc/crontab 这个文件负责调度各种管理和维护任务。<br>/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。<br>我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次</p>
<h3 id="使用者权限文件："><a href="#使用者权限文件：" class="headerlink" title="使用者权限文件："></a>使用者权限文件：</h3><p>文件：/etc/cron.deny<br>说明：<br>该文件中所列用户不允许使用crontab命令<br>文件：/etc/cron.allow<br>说明：<br>该文件中所列用户允许使用crontab命令<br>文件：/var/spool/cron/<br>说明：<br>所有用户crontab文件存放的目录,以用户名命名</p>
<h3 id="crontab的文件格式"><a href="#crontab的文件格式" class="headerlink" title="crontab的文件格式"></a>crontab的文件格式</h3><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br>minute   hour   day   month   week   command<br>其中：<br>minute： 表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。<br><img src="http://wx1.sinaimg.cn/mw690/71c65545gy1fya3vscqjrj20ey0cewes.jpg" alt=""></p>
<h2 id="crontab的两种配置方式"><a href="#crontab的两种配置方式" class="headerlink" title="crontab的两种配置方式"></a>crontab的两种配置方式</h2><p><strong>第一种：在/etc/crontab下设置，指定用户名的</strong><br>1、vim命令进入/etc/crontab<br>2、在最后一行加上<br>59 23 <em> </em> * root /root/catalina.out.rm/rm_8080_8081_catalina.sh<br>如下图：<br><img src="http://wx4.sinaimg.cn/mw690/71c65545gy1fya41yxhz1j20f708gwel.jpg" alt=""><br>3、重启crontab，使配置生效<br><img src="http://wx3.sinaimg.cn/mw690/71c65545gy1fya41y4jm2j20dj01kdfm.jpg" alt=""></p>
<p><strong>第二种：直接用crontab -e，不需要指定用户</strong><br>1、crontab -e进入<br><img src="http://wx1.sinaimg.cn/mw690/71c65545gy1fya41x37s6j20fk010743.jpg" alt=""><br>2、：wq退出保存<br>3、查看上面那个脚本是否有执行权限<br><img src="http://wx2.sinaimg.cn/mw690/71c65545gy1fya41wpjjaj20890233ya.jpg" alt=""><br>4、还要看脚本里面的涉及的操作文件是否有权限<br>5、重启crontab，使配置生效<br><img src="http://wx4.sinaimg.cn/mw690/71c65545gy1fya41wd8waj20dj01kdfm.jpg" alt=""></p>
<blockquote>
<p><strong>crontab命令参数：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。<br>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。<br>&nbsp;&nbsp;&nbsp;&nbsp;-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;-i：在删除用户的crontab文件时给确认提示。</p>
</blockquote>
<h3 id="二、使用实例"><a href="#二、使用实例" class="headerlink" title="二、使用实例"></a>二、使用实例</h3><p><strong>实例1：每1分钟执行一次myCommand</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * myCommand</span><br></pre></td></tr></table></figure><br><strong>实例2：每小时的第3和第15分钟执行</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3,15 * * * * myCommand</span><br></pre></td></tr></table></figure><br><strong>实例3：在上午8点到11点的第3和第15分钟执行</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3,15 8-11 * * * myCommand</span><br></pre></td></tr></table></figure><br><strong>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3,15 8-11 */2  *  * myCommand</span><br></pre></td></tr></table></figure><br><strong>实例5：每周一上午8点到11点的第3和第15分钟执行</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3,15 8-11 * * 1 myCommand</span><br></pre></td></tr></table></figure><br><strong>实例6：每晚的21:30重启smb</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><br><strong>实例7：每月1、10、22日的4 : 45重启smb</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><br><strong>实例8：每周六、周日的1 : 10重启smb</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><br><strong>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><br><strong>实例10：每星期六的晚上11 : 00 pm重启smb</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><br><strong>实例11：每一小时重启smb</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><br><strong>实例12：晚上11点到早上7点之间，每隔一小时重启smb</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 23-7 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure></p>
<h2 id="三、crontab常见问题定位"><a href="#三、crontab常见问题定位" class="headerlink" title="三、crontab常见问题定位"></a>三、crontab常见问题定位</h2><p><strong>crontab日志：/var/log/cron</strong><br><strong>crontab与环境变量：</strong>  </p>
<p><strong>常见问题1： 单独在命令行执行就没有问题，放到crontab 任务没有反应！！！</strong><br>不要假定cron知道所需要的特殊环境，它其实并不知道。<br>bash 的用户环境，是当用户在登录的时候，bash 读取多个配置文件（/etc/profile, ~/.bash_profile, ~/.bashrc …），从而为我们设定了很多环境变量。<br>但是，cron 不同，它并不知道用户的环境，所以你要保证在shell脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。<br>那么问题来了： crontab 任务没有反应！！！ 单独在命令行执行就没有问题，放到crontab中就不行！！！ 典型的问题，根据经验，这就是<strong>crontab的环境变量跟用户的环境变量不同</strong>导致的。</p>
<p><strong>常见问题2：路径问题</strong><br>其实路径是个非常容易出问题的地方，假设在/home/目录下有一个脚本文件test1.sh，然后在该目录下还有一个脚本文件test2.sh</p>
<p>在test1.sh中执行了test2.sh，而且用的是相对路径，即相对test1.sh所在的路径。</p>
<p>如果在crontab -e中编辑的时候，执行的方式是<br>sh /home/test1.sh，当执行到调用sh test2.sh的时候，系统会认为是从crontab文件所在的目录去找test2.sh，但是其实是找不到的，造成执行失败</p>
<p>所以另外一个解决方法就是在执行脚本之前先通过 cd   /home/命令进入到脚本所在目录</p>
<p><strong>总结</strong><br>注意如下几点：</p>
<ul>
<li>脚本中涉及文件路径时全部写绝对路径；</li>
<li>crontab中涉及路径时全部写绝对路径</li>
<li><p>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：<br>$ cat start_cbp.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">source /etc/profile        # 引入 profile环境变量</span><br><span class="line">export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</span><br><span class="line">/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 * * * * . /etc/profile; /bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</span><br></pre></td></tr></table></figure></li>
<li>新创建的cron job，可能不会马上执行，至少要过2分钟才执行。如果需要，请重启crond这个服务。  </li>
<li>每条 JOB 执行完毕之后，如果有输出，那么系统会自动将输出发送邮件给当前系统用户。日积月累，非常的多，甚至会撑爆整个系统。所以每条 JOB 命令后面进行重定向处理是非常必要的： &gt;/dev/null 2&gt;&amp;1 。前提是对 Job 中的命令需要正常输出已经作了一定的处理, 比如追加到某个特定日志文件。  </li>
<li>当crontab突然失效时，可以尝试 /etc/init.d/crond restart 解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</li>
<li>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab 记录都没了。</li>
<li>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\%Y\%m\%d’`。</li>
<li>工作中遇到比较多的是root密码过期，导致它的cronjob无法正常执行。</li>
<li>周与日月不可同时并存。 要么指定周， 要么指定日月</li>
</ul>
<p>其他不执行的原因可以参考：<a href="https://blog.csdn.net/u011734144/article/details/54576469">crontab定时任务不执行的原因</a>  </p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/catoop/article/details/41821395">Linux配置定时，使用 crontab -e 与 直接编辑 /etc/crontab 的区别</a><br><a href="http://blog.51cto.com/skypegnu1/1428632">Linux基础：crontab 与 环境变量，以及应该注意的问题</a><br><a href="https://www.cnblogs.com/zishengY/p/6805316.html">crontab的两种配置方式</a><br><a href="https://blog.csdn.net/u011734144/article/details/54576469">crontab定时任务不执行的原因</a><br><a href="http://blog.51cto.com/jiemian/1852092">crontab与环境变量，以及应该注意的一些问题</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>日常积累</tag>
        <tag>crontab</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>CRLF line terminators的问题</title>
    <url>/2018/06/20/CRLF%20line%20terminators%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在定位一个问题时，发现问题是由于配置文件格式不对导致的。本文简单介绍下CRLF line terminators的问题的解决方法。<br>CRLF line terminators的问题导致的问题：</p>
<ul>
<li>shell脚本报错：command not found</li>
<li>如果是配置文件，由于格式是windows格式的，可能会导致解析配置参数错误</li>
</ul>
<hr>
<h3 id="CRLF-line-terminators的问题的根源"><a href="#CRLF-line-terminators的问题的根源" class="headerlink" title="CRLF line terminators的问题的根源"></a>CRLF line terminators的问题的根源</h3><p>Linux和Windows文本文件的行结束标志不同。在Linux中，文本文件用”/n”表示回车换行，而Windows用”/r/n”表示回车换行。有时候在Windows编写shell脚本时需要注意这个，否则shell脚本会报”No such file or directory”或”command not found line x”之类的错误，如果不知晓前因后果，肯定会被这个折腾得相当郁闷。<br><strong>区别方法</strong> ： 用file命令或者“cat -v”命令查看文件，显示如下面示例的，则表示该文件是使用windows格式的换行符。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@DB-Server myscript]# file test.sh </span><br><span class="line">test.sh: ASCII text, with CRLF line terminators</span><br><span class="line">[root@DB-Server myscript]# cat -v test.sh </span><br><span class="line">. /home/oracle/.bash_profile^M</span><br><span class="line">echo &#x27; &#x27;^M</span><br><span class="line">date^M</span><br><span class="line">echo &#x27; &#x27;^M</span><br><span class="line">^M</span><br><span class="line">sqlplus test/test @/home/oracle/scripts/test.sql^M</span><br><span class="line">^M</span><br><span class="line">echo &#x27; &#x27;^M</span><br><span class="line">date^M</span><br><span class="line">echo &#x27; &#x27;^M</span><br></pre></td></tr></table></figure></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>三种解决方法：</p>
<ul>
<li>直接在Linux环境上使用vi编辑器编写shell脚本，避免在windows下开发shell脚本</li>
<li>如果是在windows上开发的shell脚本，可以在Linux环境上创建shell脚本，然后从Windows的脚本里面拷贝内容过来；</li>
<li>最简单方便的是使用dos2unix将DOS格式文本文件转换成Unix格式或Linux格式。</li>
</ul>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.hao32.com/unix-linux/565.html">处理文件CRLF line terminators的问题</a><br><a href="https://www.cnblogs.com/kerrycode/archive/2015/12/22/5065356.html">CRLF line terminators导致shell脚本报错：command not found</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>问题定位</tag>
        <tag>日常积累</tag>
        <tag>CRLF</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统下一个实现开机启动并将进程加入监控的简单方案</title>
    <url>/2018/12/20/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%B9%B6%E5%B0%86%E8%BF%9B%E7%A8%8B%E5%8A%A0%E5%85%A5%E7%9B%91%E6%8E%A7%E7%9A%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>本文主要介绍Linux系统下，一个实现开机启动并将进程加入监控的简单方案。<br>主要完成两个shell脚本，会涉及到crontab的使用。<br>crontab的相关知识可以参考这篇文章：<a href="https://ahnselina.github.io/crontab%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/">crontab基本用法及常见问题定位</a></p>
<hr>
<h2 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h2><p>简单方案就是使用两个shell脚本，一个脚本实现开机启动功能，另外一个脚本实现加入crontab监控的功能。<br>废话不多说，直接上代码</p>
<h3 id="实现开机启动功能的脚本"><a href="#实现开机启动功能的脚本" class="headerlink" title="实现开机启动功能的脚本"></a>实现开机启动功能的脚本</h3><p>Linux下实现开机启动的方法很多，本人采用将脚本放入/etc/init.d/目录下的办法。<br>脚本如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">description: add xxx to crontab and start process along with power on</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">load system <span class="built_in">functions</span></span></span><br><span class="line">source /etc/init.d/functions</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">your application name</span></span><br><span class="line">appname=cmd_python.py</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">your application path</span></span><br><span class="line">apphome=/opt/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">your <span class="built_in">log</span> path</span></span><br><span class="line">logpath=/var/log/task_test.log</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">search process.</span></span><br><span class="line">pid=$( ps -ef | grep $&#123;appname&#125; | grep -v grep | grep -v vi | grep -v dbx | grep -v tail | grep -v start | grep -v stop| sed -n 1p | awk &#x27;&#123;print $2&#125;&#x27; )</span><br><span class="line"></span><br><span class="line">if [ &quot;a$&#123;pid&#125;b&quot; != &quot;ab&quot; ]; then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">exist process pid</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;servcie <span class="variable">$&#123;appname&#125;</span> was started.&quot;</span></span></span><br><span class="line">	exit 0</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">start your services or missions</span></span><br><span class="line">	cd $&#123;apphome&#125;</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">start python task, you can use your app task here!!!</span></span><br><span class="line">	python ./$&#123;appname&#125;$&#123;appcomm&#125; &amp;</span><br><span class="line">	echo &quot;servcie $&#123;appname&#125; was started.&quot; &gt;&gt; $&#123;logpath&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">crontab -l | grep &quot;$&#123;appname&#125;&quot;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">	exit 0</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">add to crontab</span></span><br><span class="line">	sh monitor.sh start</span><br><span class="line">	curTime=`date`</span><br><span class="line">	echo &quot;$&#123;curTime&#125;:add $&#123;appname&#125; to crontab.&quot; &gt;&gt; $&#123;logpath&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<h3 id="实现加入crontab监控的脚本"><a href="#实现加入crontab监控的脚本" class="headerlink" title="实现加入crontab监控的脚本"></a>实现加入crontab监控的脚本</h3><p>监控脚本:monitor.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">监控任务：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">CUR_PATH=$(cd &quot;$(dirname &quot;$0&quot;)&quot;; pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要定时执行的任务</span></span><br><span class="line">TASK_COMMAND=&quot;echo &#x27;aaa&#x27; &gt;&gt; /var/log/cron_test&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要添加的crontab任务</span></span><br><span class="line">CRONTAB_TASK=&quot;* * * * * $&#123;TASK_COMMAND&#125;&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份原始crontab记录文件</span></span><br><span class="line">CRONTAB_BAK_FILE=&quot;$&#123;CUR_PATH&#125;/crontab_bak&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建crontab任务函数</span></span><br><span class="line">function create_crontab()</span><br><span class="line">&#123;</span><br><span class="line">    echo &#x27;Create crontab task...&#x27;</span><br><span class="line">    crontab -l &gt; $&#123;CRONTAB_BAK_FILE&#125; 2&gt;/dev/null</span><br><span class="line">    sed -i &quot;/.*$&#123;TASK_COMMAND&#125;/d&quot; $&#123;CRONTAB_BAK_FILE&#125;  # 已存在任务时会被sed删除，防止重复添加</span><br><span class="line">    echo &quot;$&#123;CRONTAB_TASK&#125;&quot; &gt;&gt; $&#123;CRONTAB_BAK_FILE&#125;</span><br><span class="line">    crontab $&#123;CRONTAB_BAK_FILE&#125;</span><br><span class="line"></span><br><span class="line">    echo &#x27;Complete&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除crontab任务函数</span></span><br><span class="line">function clear_crontab()&#123;</span><br><span class="line">    echo &#x27;Delete crontab task...&#x27;</span><br><span class="line">    crontab -l &gt; $&#123;CRONTAB_BAK_FILE&#125; 2&gt;/dev/null</span><br><span class="line">    sed -i &quot;/.*$&#123;SCRIPT_NAME&#125;/d&quot; $&#123;CRONTAB_BAK_FILE&#125;</span><br><span class="line">    crontab $&#123;CRONTAB_BAK_FILE&#125;</span><br><span class="line"></span><br><span class="line">    echo &#x27;Complete&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ $# -lt 1 ]; then</span><br><span class="line">    echo &quot;Usage: $0 [start | stop]&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">    &#x27;start&#x27; )</span><br><span class="line">        create_crontab</span><br><span class="line">        ;;</span><br><span class="line">    &#x27;stop&#x27; )</span><br><span class="line">        clear_crontab</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wanghaoxi3000/article/details/78927578">shell编辑crontab任务</a><br><a href="https://blog.csdn.net/learic/article/details/83340312">linux bash shell 制作脚本开机启动linux服务</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>日常积累</tag>
        <tag>crontab</tag>
        <tag>开机启动</tag>
        <tag>监控</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>博客从Jekyll迁移Hexo</title>
    <url>/2019/01/06/%E5%8D%9A%E5%AE%A2%E4%BB%8EJekyll%E8%BF%81%E7%A7%BBHexo/</url>
    <content><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>搭建教程参考：<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a>   </p>
<h4 id="npm-install-g-hexo-没有反应"><a href="#npm-install-g-hexo-没有反应" class="headerlink" title="npm install g hexo 没有反应"></a>npm install g hexo 没有反应</h4><p>执行 npm config set registry “<a href="https://registry.npm.taobao.org&quot;">https://registry.npm.taobao.org&quot;</a> 将npm包源指向淘宝，就不需要翻墙安包了：<a href="https://www.oschina.net/question/2443995_2155065">npm install g hexo 总是失败</a> </p>
<p>可供参考的资料：<br><a href="https://www.cnblogs.com/fengxiongZz/p/7707568.html">使用Hexo+Github一步步搭建属于自己的博客（进阶）</a></p>
<p><a href="https://blog.csdn.net/xr469786706/article/details/78166227">Hexo+Next主题 文章添加阅读次数，访问量等</a></p>
<p><a href="https://lruihao.cn/hexo%20+%20github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html">hexo+github 搭建个人博客及美化</a></p>
<p><a href="https://blog.csdn.net/hhgggggg/article/details/77853665">设置 SSH 使用 hexo deploy 时免输用户名密码</a></p>
<p><a href="https://yeyouluo.github.io/2017/10/16/%E7%BB%86%E6%95%B0%E7%94%A8hexo%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/">细数用hexo搭建github博客踩过的坑（windows版）</a></p>
<p><a href="https://lruihao.cn/hexo-d-error.html">hexo d 出错</a></p>
<p><a href="https://blog.csdn.net/ddydavie/article/details/83020549">Busuanzi 统计浏览失效解决方法点这</a></p>
<p><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo使用攻略-添加分类及标签</a></p>
<p><a href="https://blog.csdn.net/qq_32454537/article/details/79482879">添加评论方法</a></p>
<p>本来想用来必力，但是网页打开很慢，遂放弃。<br><a href="https://www.bluelzy.com/articles/use_valine_for_your_blog.html">为你的Hexo加上评论系统-Valine</a></p>
<p><a href="http://stevenshi.me/2017/05/26/hexo-add-copyright/">Hexo Next下添加版权声明模块</a></p>
<p>下面文章含有“提交百度谷歌站点验证出错”的解决方法：<br><a href="https://www.huangzz.xyz/how-to-avoid-hexo-compiling-html-files.html">如何避免 Hexo 编译 HTML 文件</a><br>由于hexo会在生成编译文件的过程中，修改html文件内容，导致百度验证失败，因此，不建议再踩一遍这个坑。可参考下文：<br><a href="http://www.dadroid.cn/posts/undefined/">Hexo：Github部署站点的SEO优化教程</a><br><a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html">Hexo博客Next主题SEO优化方法</a></p>
<p>另外一个错误是不要私自去往自己的博客仓库里面添加文件，导致hexo本地的库和远程库内容不一致，这样在新推送日志或其他东西时，会推送失败。</p>
<p><a href="https://wuchenxu.com/2015/12/13/Static-Blog-hexo-github-7-display-updated-date/">显示每篇文章的更新时间</a></p>
<h3 id="修改头像实现旋转"><a href="#修改头像实现旋转" class="headerlink" title="修改头像实现旋转"></a>修改头像实现旋转</h3><p>更换头像，打开站点配置文件,找到avatar字段，可以使用网络路径，也可以将头像存放在source/images/中。如果头像是椭圆的，是因为图片不是一个正方形的图片，找到一个宽高像素一样的的图片即可。</p>
<p>avatar: /images/head.jpg<br>打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  /* 头像圆形 */</span><br><span class="line">  border-radius: 80px;</span><br><span class="line">  -webkit-border-radius: 80px;</span><br><span class="line">  -moz-border-radius: 80px;</span><br><span class="line">  box-shadow: inset 0 -1px 0 #333sf;</span><br><span class="line">  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束</span><br><span class="line">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span><br><span class="line"></span><br><span class="line">  /* 鼠标经过头像旋转360度 */</span><br><span class="line">  -webkit-transition: -webkit-transform 1.0s ease-out;</span><br><span class="line">  -moz-transition: -moz-transform 1.0s ease-out;</span><br><span class="line">  transition: transform 1.0s ease-out;</span><br><span class="line">&#125;</span><br><span class="line">img:hover &#123;</span><br><span class="line">  /* 鼠标经过停止头像旋转</span><br><span class="line">  -webkit-animation-play-state:paused;</span><br><span class="line">  animation-play-state:paused;*/</span><br><span class="line">  /* 鼠标经过头像旋转360度 */</span><br><span class="line">  -webkit-transform: rotateZ(360deg);</span><br><span class="line">  -moz-transform: rotateZ(360deg);</span><br><span class="line">  transform: rotateZ(360deg);</span><br><span class="line">&#125;</span><br><span class="line">/* Z 轴旋转动画 */</span><br><span class="line">@-webkit-keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-moz-keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -moz-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    -moz-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.shaoyance.com/2018/01/26/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/">参考该文</a></p>
<h3 id="hexo-d-卡住半天没反应"><a href="#hexo-d-卡住半天没反应" class="headerlink" title="hexo d 卡住半天没反应"></a>hexo d 卡住半天没反应</h3><p>首先不要作死，私自去往自己的博客仓库里面添加文件，这样会导致hexo本地的库和远程库内容不一致，这样再hexo d新推送日志或其他东西时，会失败。<br>如果没有作死，可以参考下文：<br><a href="http://blog.2hao.cc/2018/07/29/question/">hexo d 卡住问题</a></p>
<p>如果使用hexo s都能正常预览网页,这种情况可能是网络问题，ping一下github.com如果超时，那就要用到下面的方法了。  </p>
<p>路径 C:\Windows\System32\drivers\etc\hosts</p>
<p>用记事本打开，在末尾添加内容：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.30.253.113    github.com</span><br><span class="line">192.30.252.131 github.com</span><br><span class="line">185.31.16.185 github.global.ssl.fastly.net</span><br><span class="line">74.125.237.1 dl-ssl.google.com</span><br><span class="line">173.194.127.200 groups.google.com</span><br><span class="line">192.30.252.131 github.com</span><br><span class="line">185.31.16.185 github.global.ssl.fastly.net</span><br><span class="line">74.125.128.95 ajax.googleapis.com</span><br></pre></td></tr></table></figure><br>保存（以管理员身份），重新运行 cmd 再ping，可以通。</p>
<p>其他问题待续…</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a><br><a href="https://www.oschina.net/question/2443995_2155065">npm install g hexo 总是失败</a><br><a href="https://hexo.io/zh-cn/docs/migration">迁移</a><br><a href="https://www.jianshu.com/p/0886c99f826a">Github绑定域名</a><br><a href="https://blog.csdn.net/qq_29232943/article/details/52786603">GitHub Pages 绑定来自阿里云的域名</a></p>
]]></content>
      <tags>
        <tag>总结</tag>
        <tag>问题定位</tag>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>LizardFS介绍</title>
    <url>/2019/01/15/LizardFS%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="http://wx2.sinaimg.cn/mw690/71c65545gy1fz7o12ow54j20fo08iwet.jpg" alt=""><br><span id="more"></span></p>
<h2 id="LizardFS特点"><a href="#LizardFS特点" class="headerlink" title="LizardFS特点"></a>LizardFS特点</h2><ul>
<li>support for many data centers and media types,支持多数据中心和多种介质</li>
<li>fast snapshots, 快速快照</li>
<li>transparent trash bin,透明的垃圾处理</li>
<li>QoS mechanisms,Quality of Service (QoS)服务质量机制</li>
<li>quotas,支持配额</li>
<li>一系列方便运维的监控工具</li>
</ul>
<p><strong>Lizardfs功能列表</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th style="text-align:center">举例或说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>支持多种磁盘介质</td>
<td style="text-align:center">HDD或SSD</td>
</tr>
<tr>
<td>快照</td>
<td style="text-align:center">基于COW的快照</td>
</tr>
<tr>
<td>QOS</td>
<td style="text-align:center">利用带宽限制或流量限制保证服务质量</td>
</tr>
<tr>
<td>冗余策略</td>
<td style="text-align:center">标准副本、XOR副本、EC</td>
</tr>
<tr>
<td>异地副本</td>
<td style="text-align:center">支持跨数据中心数据副本</td>
</tr>
<tr>
<td>支持LTO库</td>
<td style="text-align:center">支持后端为LTO存储</td>
</tr>
<tr>
<td>配额</td>
<td style="text-align:center">提供告警信息值和严格限制值，当用户达到严格限制值便不能写新数据</td>
</tr>
<tr>
<td>兼容POSIX</td>
<td style="text-align:center">提供了POSIX文件系统的所有特性</td>
</tr>
<tr>
<td>垃圾处理机制</td>
<td style="text-align:center">提供类似Windows回收站的垃圾处理机制</td>
</tr>
<tr>
<td>监控</td>
<td style="text-align:center">提供命令行接口和基于网页的图形化的监控</td>
</tr>
<tr>
<td>支持Hadoop</td>
<td style="text-align:center">可用Hadoop任务直接访问Lizardfs集群上的数据</td>
</tr>
<tr>
<td>丰富的访问控制列表</td>
<td style="text-align:center">支持Linux、MacOSX、Windows的ACLs</td>
</tr>
</tbody>
</table>
<p><strong><em>垃圾处理机制，提供类似Windows回收站的垃圾处理机制，并可对单个文件或文件夹设置一个单独的垃圾时间，在达到这个垃圾时间之前均可恢复文件或文件夹</em></strong></p>
<h2 id="Lizardfs架构"><a href="#Lizardfs架构" class="headerlink" title="Lizardfs架构"></a>Lizardfs架构</h2><p><img src="http://wx3.sinaimg.cn/mw690/71c65545gy1fz7o104cn2j20pe0i6q43.jpg" alt=""><br>lizardfs将元数据（比如文件名、修改时间戳、文件目录树等）和数据分开保存。元数据保存在元数据服务器上（meta data server），数据保存在chunk server上。<br>典型的安装包含：<br>（1）至少2个元数据服务器，这两个服务器是主备模式以方便故障恢复。他们的角色任务是管理整个集群，所以活动的元数据服务器经常被叫做master server，备服务器则保持和主服务器同步，因此又叫shadow master servers。备服务器是随时准备好接替主服务器的。<br>元数据服务器推荐配置：<br>快速的CPU、至少32GB内存、至少一个SSD盘用于存元数据（几个G的盘就OK）。<br>（2）一定数量的chunk servers则用于存数据。每个文件被切分成64M的块，被称为chunk，这些chunk被存放在chunk servers上。推荐chunk server配置是要有大容量的JBOD或者RAID配置。CPU和RAM不是十分重要。至少要有2个chunk servers，也可以多达几百个。<br>（3）Client是使用存在Lizardfs上数据的机器。这些机器使用lizardfs mount（mfsmount）来访问集群上的文件和处理这些数据就像使用本地硬盘里的数据一样。存储在lizardfs上的文件可以被大量的client看到和访问，如果有这个需要的话。</p>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>如果存储需要增加，现有的lizardfs集群可以通过添加新的chunk servers的方式扩展。可以在任何时间添加新的服务器，并且基本不会导致停服务，也就是说，这一切对client来说都是透明的。新加的chunk server的磁盘空间是没有限制的，也就是说，一个24TB的chunkserver添加到含有8TBchunkserver的集群中是完全没有问题的。</p>
<p>系统的性能是随磁盘的数量线性增加的，所以添加一个chunkserver并不仅仅是存储容量的增加而且使得整个存储系统整体的性能增加。Lizardfs自动分布数据到所有的chunkservers上，包括那些刚刚添加进来的chunkserver，因为lizardfs会平衡所有连接进来节点的磁盘利用率。去除服务器跟添加一样的容易。</p>
<h2 id="硬件推荐"><a href="#硬件推荐" class="headerlink" title="硬件推荐"></a>硬件推荐</h2><p>Lizardfs是完全硬件无关的。商业硬件可以被用来获取高效率。最低要求是有两个带有一些硬盘的专用节点，但为了获取高可用的集群，应该配置至少三个节点。这也可以让你用上erasure coding特性。</p>
<p>我们推荐每个节点之间至少由1Gbps的网卡连接。因为大多数商业硬盘都有一个100MB/s的吞吐量，所以你的网卡应该能够处理你的chunkservers的流量。</p>
<ul>
<li>Master/Shadow ： 至少2GHz CPU，64位</li>
<li>RAM：取决于文件的数量（4GB对于小集群来说已经够了）</li>
<li>Disk: 128G，HDD就可以，不过SSD可以改善性能</li>
<li>Chunkserver：推荐最少2GB RAM</li>
<li>Metalogger：推荐最少2GB RAM</li>
</ul>
<h2 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h2><p>Lizardfs提供各种实际和稳定的特性使得其成为了一个成熟的企业解决方案。你可以将lizardfs用于层级存储管理(HSM),也可以用于带有异步副本的灾难恢复中心，还可以用于减少副本需要的硬盘空间，也可以用于有效管理存储池（QOS，配额）等等。</p>
<p>Lizardfs是非常灵活的。如果你有其他的需要额外功能的使用场景，可以通过开发来满足你的特定需求。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>拷贝大文件和目录（比如虚拟机）通过快照特性是非常有效率的。当创建一个快照的时候，为了加快该操作，只复制了目标文件的元数据。原始的chunks和复制的文件是共享的，除非他们被修改。<br><img src="http://wx2.sinaimg.cn/mw690/71c65545gy1fz7o10mpqxj20po0bf3yx.jpg" alt=""></p>
<p>例子：<br>比如/mnt/lizardfs/huge_vm里面包含了几个大文件，有512GB。使用一个拷贝备份命令” cp -r huge_vm huge_vm_backup”会花费一段比较长的时间并且会再占用512GB空间。</p>
<p>我们推荐使用” mfsmakesnapshot huge_vm huge_ vm_backup”命令来创建副本。相比之下，这个命令会立即执行完毕，并且仅另外占用少量空间。</p>
<p>现在考虑修改/mnt/lizardfs/huge_vm里面的一个文件的场景，该场景只会影响到2个chunks。当使用”mfsmakesnapshot”命令，只有修改了的chunk会被复制，影响到了2个chunk，那这个操作只会使用128MB，这跟使用”cp -r”消耗的512GB比较起来是微乎其微的。</p>
<h3 id="QOS服务质量"><a href="#QOS服务质量" class="headerlink" title="QOS服务质量"></a>QOS服务质量</h3><p>Lizardfs为管理员提供设置读写带宽的机制，以限制由特定挂载点产生的流量，或者是多个client机器和多个挂载点的特定进程组产生的流量。这使得Lizardfs适合那些需要保证合适服务质量的关键应用。</p>
<p>例子：<br>假设一个集群有300个硬盘并且是根据我们的推荐配置的。一个人期望该集群对所有的client都可以达到20GB/s。想象一个包含了许多虚拟机的产品系统，使用了lizardfs作为他们的存储。如果一个管理员已经访问了主机并且在上面开始维护工作，那是可能使用带宽限制来确保系统运行流畅。</p>
<h3 id="数据副本"><a href="#数据副本" class="headerlink" title="数据副本"></a>数据副本</h3><p>存在LizardFS上的文件被切分成一块块的，这些块又被叫做chunks，每一个chunk 64MB。每一个chunk被保存在chunkservers上，并且管理员可以选择每一个文件保存多少个副本。<br>比如，选择保存为三副本（configuration goal=3）, 在故障2个盘或者2个chunkservers的情况下，所有的数据都不会丢，因为LizardFS不会将同一个chunk的2份副本保存在同一个节点上面。</p>
<p>安全级别（副本数量）可以对单个文件和某个目录独立设置。当一个chunk失效，比如说由于磁盘故障，系统就会从该chunk剩余的副本复制出一个chunk以维持设置的副本数量。</p>
<p>数据均分分布在所有节点上。没有专用的镜像服务器，也就是说在副本数量为3的情况下，每一个chunk有三个副本，这三个副本是随机的分布在三个服务器上的。</p>
<p>这种独特的设计使得故障恢复非常快。如果一个盘失效了，由于备份的副本是均匀地分布在所有其他盘上的，所以集群中所有的盘都可以参与到复制的过程中来。因此，恢复丢失数据的速度随着系统中盘的数量增加而增加。</p>
<h3 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h3><p>LizardFS实现了2种副本机制：标准的和XOR 副本。</p>
<h4 id="标准副本"><a href="#标准副本" class="headerlink" title="标准副本"></a>标准副本</h4><p>这种副本机制运行设置每一个chunk所拥有的副本数量。注意既然不可能将同一个chunk的2个副本存储在同一个chunkserver上，这就意味着标准副本的目标应该与chunkservers的数量以及他们的标签符合（顺应，comply with）。</p>
<p>例子：标准的三副本表示每一个chunk应该被放在三个不同的chunkservers上的。这些chunk具体的位置由master服务器根据空间使用均衡来决定。</p>
<h4 id="XOR-副本"><a href="#XOR-副本" class="headerlink" title="XOR 副本"></a>XOR 副本</h4><p>这种副本机制根据“XOR 等级”参数把chunks分成更小的部分。一个文件带有XOR等级N就会被保存为N+1个chunks(N代表数据，1代表校验块)。XOR等级从2到10。</p>
<p>例子：全局的“xor3”意味着一个文件的每一个chunk将会被分为4个部分，并且分布在chunkservers上。如果有任何单个chunkserver故障了，那是可能从剩余的3 XOR chunks重构出该文件的。<br><img src="http://wx3.sinaimg.cn/mw690/71c65545gy1fz7o110micj20y106kdgf.jpg" alt=""></p>
<h4 id="EC–-Erasure-Coding-replica-从-3-10-0版本开始有的特性"><a href="#EC–-Erasure-Coding-replica-从-3-10-0版本开始有的特性" class="headerlink" title="EC– Erasure Coding replica (从 3.10.0版本开始有的特性)"></a>EC– Erasure Coding replica (从 3.10.0版本开始有的特性)</h4><p>对于每一个使用EC(K+M)的文件，系统会把文件切分成K个部分，并且生成M个校验块。K个部分是可以用来重现文件内容的。如果指定了标签，带标签的部分将会被存储在chunkservers上，否则，会使用默认的通配符标签。</p>
<p>EC（K+M）这种机制的目标允许K+M中的M份数据丢失，并且文件是仍然可以访问的。使用EC（K+M）额外占用M/K的空间，比如EC5+1额外占用20%的空间，然后EC 3+2额外占用66.6%的空间。</p>
<p>注意：最小的K是2，并且最小的M是1。EC的M为1时，等价于XOR 副本K。<br><img src="http://wx4.sinaimg.cn/mw690/71c65545gy1fz7o11htgsj20xj0jcgmy.jpg" alt=""></p>
<h3 id="地理副本（异地副本Georeplication-aka-custom-goals-）"><a href="#地理副本（异地副本Georeplication-aka-custom-goals-）" class="headerlink" title="地理副本（异地副本Georeplication (aka custom goals)）"></a>地理副本（异地副本Georeplication (aka custom goals)）</h3><p>通过异地副本，你可以决定chunks存储在哪。这种拓扑特性允许当多于一个副本可用时，可以用于建议client读取哪个副本。当集群中有多个地域和多种介质类型的盘（比如有SSD，也有HDD）时，这种客户定制的特性使得LizardFS更有用。</p>
<p>管理员能够通过给chunkservers添加标签来使用该特性，以便系统决定怎样将chunks分布到可用的服务器上。这使得LizardFS能够承受整个数据中心的故障（灾难恢复），如下面的例子所示。<br>例子：当lizardfs部署在两个数据中心上，也就是说一个数据中心位于伦敦，一个位于巴黎，可以给伦敦的每一个服务器打上“london”的标签，并且给巴黎的服务器打上”paris”的标签。此外，还可以创建一个用户定义的目标，命名为2_locations，定义为”2_locations:paris and london”。每一个在带有2_locations定义的目录中创建文件将都会是2副本，一个副本在”london”标签的服务器上，另一个副本在”paris”标签的服务器上。这样就能保证当一个数据中心完全不可用的时候，文件在另一个数据中心的副本仍然可以正常提供读写功能。</p>
<h3 id="支持LTO库"><a href="#支持LTO库" class="headerlink" title="支持LTO库"></a>支持LTO库</h3><p>LizardFS提供对LTO库的原生支持。存储文档备份会耗费大量内存，即使这样的文件几乎不会被读到，这就意味着这种类型的数据存储在磁带上会更有效率。</p>
<p>Lizardfs提供了同LTO后端存储兼容的方式。通过设定一个磁带’goal’，文件可以被指定有一个备份副本在磁带上。从磁带存储上读数据是相当耗时的，所以存储在磁带上的数据应该很少有读取操作。</p>
<p>如果一个文件仍然有正常的副本（此处正常的副本指不位于磁带上的副本），那该副本将会用于读取操作。如果一个文件只存在于磁带上，那么首先是要恢复到Lizardfs上。为了达到这一点，必须使用lizardfs-restore-tape-copy工具:<br>$ lizardfs-restore-tape-copy 文件_路径<br>在运行这个命令之后，所有需要的数据将会从磁带中读取出来并加载到文件系统中，这样就可以让client端访问到这个文件了。</p>
<h3 id="配额"><a href="#配额" class="headerlink" title="配额"></a>配额</h3><p>Lizardfs支持类似POSIX系统的磁盘配额机制。它对文件和指定用户或指定用户组提供一个告警信息值和严格限制值。当一个用户达到严格限制值后就不能写往LizardFS写新数据了。<br>从3.10.0版本开始，LizardFS支持每一个文件夹的配额。</p>
<h3 id="兼容POSIX"><a href="#兼容POSIX" class="headerlink" title="兼容POSIX"></a>兼容POSIX</h3><p>LizardFS提供了POSIX文件系统的所有特性，比如：</p>
<ol>
<li>文件和目录的层级结构</li>
<li>文件属性，比如uid,gid,access mask, access time, modification time, change time</li>
<li>支持软链接硬链接以及其他特殊文件(unix sockets, devices)</li>
<li>访问控制列表（ACL）</li>
<li>扩展属性  </li>
</ol>
<p>Lizardfs访问权限的语义与POSIX文件系统（比如ext或者xfs）是完全一样的。因此使得Lizardfs兼容使用本地磁盘作为存储的所有应用。</p>
<h3 id="垃圾处理机制"><a href="#垃圾处理机制" class="headerlink" title="垃圾处理机制"></a>垃圾处理机制</h3><p>Lizardfs另一个特性是透明的和完全自动化的垃圾回收站。删除文件之后，文件会被放到仅对管理员可见的垃圾回收站。在垃圾回收站中文件可以被恢复或者永久删除。因此lizardfs上存储的数据比存放到硬件RAID上的更安全。</p>
<p>垃圾处理是自动清理的：在一定时间（trash time）后，系统会将文件从垃圾回收站中永久删除。任何文件或者目录的trash time随机可以调整。</p>
<p>提供类似Windows回收站的垃圾处理机制，并可对单个文件或文件夹设置一个单独的垃圾时间，在达到这个垃圾时间之前均可恢复文件或文件夹。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>提供命令行接口和基于网页的图形化的监控<br><img src="http://wx3.sinaimg.cn/mw690/71c65545gy1fz7o129h61j213v0s4gsx.jpg" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://lizardfs.com/">LizardFS官网</a><br><a href="https://lizardfs.com/wp-content/uploads/2018/06/whitepaper_lizard_v3.12_web.pdf">LizardFS白皮书</a></p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>LizardFS</tag>
        <tag>分布式存储</tag>
        <tag>文件存储</tag>
        <tag>lizardfs</tag>
      </tags>
  </entry>
  <entry>
    <title>python登录服务器并执行命令</title>
    <url>/2019/01/20/python%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文主要介绍在Windows上利用python登录远程服务器并执行命令的操作。<br>遇到的问题部分主要讲在运行python程序时遇到的问题及解决办法。<br>此外本文还介绍利用paramiko实现ssh的交互式连接，这样执行效果就像我们平时直接使用ssh登录一样。</p>
<h3 id="python登录服务器并执行命令"><a href="#python登录服务器并执行命令" class="headerlink" title="python登录服务器并执行命令"></a>python登录服务器并执行命令</h3><p>利用paramiko模块，简单实现如下，在执行的时候可能会遇到缺少各种依赖的情况，解决方法参考第二部分“遇到的问题”<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ssh2</span>(<span class="params">ip,username,passwd,cmd</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ssh = paramiko.SSHClient()</span><br><span class="line">        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        ssh.connect(ip,<span class="number">22</span>,username,passwd,timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> cmd:</span><br><span class="line">            stdin, stdout, stderr = ssh.exec_command(m)</span><br><span class="line"><span class="comment">#           stdin.write(&quot;Y&quot;)   #简单交互，输入 ‘Y’ </span></span><br><span class="line">            out = stdout.readlines()</span><br><span class="line">            <span class="comment">#屏幕输出</span></span><br><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> out:</span><br><span class="line">                <span class="built_in">print</span> o,</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;%s\tOK\n&#x27;</span>%(ip)</span><br><span class="line">        ssh.close()</span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;%s\tError\n&#x27;</span>%(ip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cmd = [<span class="string">&#x27;cal&#x27;</span>,<span class="string">&#x27;echo hello!&#x27;</span>]<span class="comment">#你要执行的命令列表</span></span><br><span class="line">    username = <span class="string">&quot;&quot;</span>  <span class="comment">#用户名</span></span><br><span class="line">    passwd = <span class="string">&quot;&quot;</span>    <span class="comment">#密码</span></span><br><span class="line"></span><br><span class="line">    ip = <span class="string">&quot;192.168.0.1&quot;</span></span><br><span class="line">    ssh2(ip,username,passwd,cmd)</span><br></pre></td></tr></table></figure></p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="ImportError-No-module-named-paramiko"><a href="#ImportError-No-module-named-paramiko" class="headerlink" title="ImportError: No module named paramiko"></a>ImportError: No module named paramiko</h4><p>解决方法：</p>
<p>Python中使用SSH需要用到OpenSSH，而OpenSSH依赖于paramiko模块，而paramiko模块又依赖于pycrypto模块，因此要在Python中使用SSH，需要先安装pycrypto工具，然后再安装paramiko模块才能使用。</p>
<p>首先要确保python安装好，且环境变量设置好。</p>
<p>参考文章:<a href="https://blog.csdn.net/xiezuoyong/article/details/78050067">Windows下解决python - ImportError: No module named paramiko</a></p>
<h4 id="ImportError-No-module-named-Crypto"><a href="#ImportError-No-module-named-Crypto" class="headerlink" title="ImportError: No module named Crypto"></a>ImportError: No module named Crypto</h4><p>安装pycrypto：<br>到下面这个网站下载编译好的pycrypto<br><a href="http://www.voidspace.org.uk/python/modules.shtml#pycrypto">http://www.voidspace.org.uk/python/modules.shtml#pycrypto</a></p>
<p>安装完成后import Crypto成功则表示安装成功<br>参考文章：<a href="https://blog.csdn.net/fo11ower/article/details/53012830">python安装Pycrypto（win10 64 python27）</a></p>
<h4 id="importerror-no-module-named-cryptography-hazmat-backends"><a href="#importerror-no-module-named-cryptography-hazmat-backends" class="headerlink" title="importerror no module named cryptography.hazmat.backends"></a>importerror no module named cryptography.hazmat.backends</h4><p>pip install  cryptography（记得要退出python之后执行）</p>
<h4 id="Command-“python-setup-py-egg-info”-failed-with-error-code-1"><a href="#Command-“python-setup-py-egg-info”-failed-with-error-code-1" class="headerlink" title="Command “python setup.py egg_info” failed with error code 1"></a>Command “python setup.py egg_info” failed with error code 1</h4><p>安装第三方包的时候报错“Command “python setup.py egg_info” failed with error code 1”</p>
<p>解决方法：</p>
<p>更新pip</p>
<p>pip install –upgrade pip</p>
<p>再安装需要安装的第三方扩展包</p>
<h4 id="importerror-no-module-named-bcrypt"><a href="#importerror-no-module-named-bcrypt" class="headerlink" title="importerror no module named bcrypt"></a>importerror no module named bcrypt</h4><p>pip install py-bcrypt</p>
<p>如果使用pip无法直接安装，另外一个办法就是直接下载源码安装<br>到<a href="https://pypi.org/project/bcrypt/3.1.0/#files下载源码，然后">https://pypi.org/project/bcrypt/3.1.0/#files下载源码，然后</a><br>python setup.py build<br>python setup.py install</p>
<h4 id="error-Microsoft-Visual-C-9-0-is-required-Unable-to-find-vcvarsall-bat"><a href="#error-Microsoft-Visual-C-9-0-is-required-Unable-to-find-vcvarsall-bat" class="headerlink" title="error: Microsoft Visual C++ 9.0 is required (Unable to find vcvarsall.bat)"></a>error: Microsoft Visual C++ 9.0 is required (Unable to find vcvarsall.bat)</h4><p>请参考:<a href="https://www.cnblogs.com/yyds/p/7065637.html">Windows下安装Python扩展模块提示“Unable to find vcvarsall.bat”的问题</a></p>
<h4 id="importerror-no-module-named-nacl-signing"><a href="#importerror-no-module-named-nacl-signing" class="headerlink" title="importerror no module named nacl.signing"></a>importerror no module named nacl.signing</h4><p>pip install pynacl</p>
<h3 id="利用paramiko实现ssh的交互式连接"><a href="#利用paramiko实现ssh的交互式连接" class="headerlink" title="利用paramiko实现ssh的交互式连接"></a>利用paramiko实现ssh的交互式连接</h3><p>以下是通过paramiko模块直接用ssh协议登陆到远程服务器的操作代码，这里先定义一个interactive模块，其文件名就叫interactive.py，代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># windows does not have termios...</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"> <span class="keyword">import</span> termios</span><br><span class="line"> <span class="keyword">import</span> tty</span><br><span class="line"> has_termios = <span class="literal">True</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line"> has_termios = <span class="literal">False</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">interactive_shell</span>(<span class="params">chan</span>):</span><br><span class="line"> <span class="keyword">if</span> has_termios:</span><br><span class="line"> posix_shell(chan)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line"> windows_shell(chan)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posix_shell</span>(<span class="params">chan</span>):</span><br><span class="line"> <span class="keyword">import</span> select</span><br><span class="line"> oldtty = termios.tcgetattr(sys.stdin)</span><br><span class="line"> <span class="keyword">try</span>:</span><br><span class="line"> tty.setraw(sys.stdin.fileno())</span><br><span class="line"> tty.setcbreak(sys.stdin.fileno())</span><br><span class="line"> chan.settimeout(<span class="number">0.0</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> r, w, e = select.select([chan, sys.stdin], [], [])</span><br><span class="line"> <span class="keyword">if</span> chan <span class="keyword">in</span> r:</span><br><span class="line"> <span class="keyword">try</span>:</span><br><span class="line"> x = chan.recv(<span class="number">1024</span>)</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(x) == <span class="number">0</span>:</span><br><span class="line"> <span class="built_in">print</span> <span class="string">&#x27;rn*** EOFrn&#x27;</span>,</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> sys.stdout.write(x)</span><br><span class="line"> sys.stdout.flush()</span><br><span class="line"> <span class="keyword">except</span> socket.timeout:</span><br><span class="line"> <span class="keyword">pass</span></span><br><span class="line"> <span class="keyword">if</span> sys.stdin <span class="keyword">in</span> r:</span><br><span class="line"> x = sys.stdin.read(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(x) == <span class="number">0</span>:</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> chan.send(x)</span><br><span class="line"> <span class="keyword">finally</span>:</span><br><span class="line"> termios.tcsetattr(sys.stdin, termios.TCSADRAIN, oldtty)</span><br><span class="line"><span class="comment"># thanks to Mike Looijmans for this code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">windows_shell</span>(<span class="params">chan</span>):</span><br><span class="line"> <span class="keyword">import</span> threading</span><br><span class="line"> sys.stdout.write(<span class="string">&quot;Line-buffered terminal emulation. Press F6 or ^Z to send EOF.rnrn&quot;</span>)</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">writeall</span>(<span class="params">sock</span>):</span><br><span class="line"> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> data = sock.recv(<span class="number">256</span>)</span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line"> sys.stdout.write(<span class="string">&#x27;rn*** EOF ***rnrn&#x27;</span>)</span><br><span class="line"> sys.stdout.flush()</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> sys.stdout.write(data)</span><br><span class="line"> sys.stdout.flush()</span><br><span class="line"> writer = threading.Thread(target=writeall, args=(chan,))</span><br><span class="line"> writer.start()</span><br><span class="line"> <span class="keyword">try</span>:</span><br><span class="line"> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"> d = sys.stdin.read(<span class="number">1</span>)</span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line"> <span class="keyword">break</span></span><br><span class="line"> chan.send(d)</span><br><span class="line"> <span class="keyword">except</span> EOFError:</span><br><span class="line"> <span class="comment"># user hit ^Z or F6</span></span><br><span class="line"> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>再另外写一个ssh_inter.py的交互主程序，内容如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">import</span> interactive</span><br><span class="line"></span><br><span class="line"><span class="comment">#记录日志</span></span><br><span class="line">paramiko.util.log_to_file(<span class="string">&#x27;/tmp/test&#x27;</span>)</span><br><span class="line"><span class="comment">#建立ssh连接</span></span><br><span class="line">ssh=paramiko.SSHClient()</span><br><span class="line">ssh.load_system_host_keys()</span><br><span class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">ssh.connect(<span class="string">&#x27;192.168.0.102&#x27;</span>,port=<span class="number">22</span>,username=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;xxxxxx&#x27;</span>,compress=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#建立交互式shell连接</span></span><br><span class="line">channel=ssh.invoke_shell()</span><br><span class="line"><span class="comment">#建立交互式管道</span></span><br><span class="line">interactive.interactive_shell(channel)</span><br><span class="line"><span class="comment">#关闭连接</span></span><br><span class="line">channel.close()</span><br><span class="line">ssh.close()</span><br></pre></td></tr></table></figure><br>运行上述代码会报“SyntaxError: Non-ASCII character ‘\xbc’ in file ssh_inter.py on line 4, but…”的错误<br>解决办法：<br>在第一行加入：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/python </span></span><br></pre></td></tr></table></figure><br>之后执行python ssh_inter.py, 执行效果就像我们平时直接使用ssh登录一样。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/xiezuoyong/article/details/78050067">Windows下解决python - ImportError: No module named paramiko</a><br><a href="https://blog.csdn.net/fo11ower/article/details/53012830">python安装Pycrypto（win10 64 python27）</a><br><a href="https://www.cnblogs.com/yyds/p/7065637.html">Windows下安装Python扩展模块提示“Unable to find vcvarsall.bat”的问题</a><br><a href="https://www.cnblogs.com/ma6174/archive/2012/05/25/2508378.html">ssh批量登录并执行命令（python实现）</a><br><a href="http://www.361way.com/python-paramiko-ssh/3984.html">python模块paramiko与ssh</a></p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>paramiko</tag>
      </tags>
  </entry>
  <entry>
    <title>LizardFS安装指南</title>
    <url>/2019/01/17/LizardFS%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="http://wx3.sinaimg.cn/mw690/71c65545gy1fz9y83nq22j20pr0bqabx.jpg" alt=""><br><span id="more"></span><br>本文主要介绍下载安装包安装的方式，其他安装方式请参考官方文档：<br><a href="https://docs.lizardfs.com/adminguide/installation.html">Installing LizardFS</a>。<br>并且本文介绍的安装仅限于master-shadowmaster模式，笔者理解为主备模式，当然备可以有多个。<br>HA集群模式的安装方法改天详细介绍下，这个里面还有蛮多坑。<br>关于lizardfs的特性可参考<a href="http://www.a-programmer.top/2019/01/15/LizardFS%E4%BB%8B%E7%BB%8D/">LizardFS介绍</a>一文。</p>
<p>PS:本文主要记录安装使用的命令，具体切换目录这些本文就省略了</p>
<h2 id="安装规划准备环境"><a href="#安装规划准备环境" class="headerlink" title="安装规划准备环境"></a>安装规划准备环境</h2><p>主要准备环境，规划好各节点用于什么角色<br>比如笔者有三个节点，规划反映到/etc/hosts里面：<br>192.168.0.1  mfsmaster chunkserver1 metalogger<br>192.168.0.2  shadowmaster chunkserver2<br>192.168.0.3  chunkserver3 cgiserver</p>
<p><strong><em>注:每个节点的/etc/hosts都要修改哦</em></strong></p>
<h2 id="master-shadowmaster模式安装步骤"><a href="#master-shadowmaster模式安装步骤" class="headerlink" title="master-shadowmaster模式安装步骤"></a>master-shadowmaster模式安装步骤</h2><p>参考上一节将各节点角色配置到各个节点的/etc/hosts文件中<br>到<a href="https://lizardfs.com/download/#toggle-id-2">https://lizardfs.com/download/#toggle-id-2</a><br>下载对应系统的安装包<br><img src="http://wx3.sinaimg.cn/mw690/71c65545gy1fz9y81dg0xj20i70eewei.jpg" alt=""><br>笔者是CentOS 7.5，所以下了对应的包，解开里面包含文件如下：<br><img src="http://wx4.sinaimg.cn/mw690/71c65545gy1fz9y81s7u8j20gn0aq0t3.jpg" alt=""></p>
<h3 id="mfsmaster节点安装"><a href="#mfsmaster节点安装" class="headerlink" title="mfsmaster节点安装"></a>mfsmaster节点安装</h3><p>主要用如下命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm –ivh lizardfs-master-3.13.0-0el7.x86_64.rpm</span><br><span class="line">rpm –ivh lizardfs-adm-3.13.0-0el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">cp /var/lib/mfs/metadata.mfs.empty  /var/lib/mfs/metadata.mfs</span><br><span class="line">cp /etc/mfs/mfsexports.cfg.dist  /etc/mfs/mfsexports.cfg</span><br><span class="line"></span><br><span class="line">vi /etc/mfs/mfsmaster.cfg</span><br><span class="line">PERSONALITY = master</span><br><span class="line"></span><br><span class="line">service lizardfs-master start</span><br></pre></td></tr></table></figure></p>
<h3 id="shadowmaster节点安装"><a href="#shadowmaster节点安装" class="headerlink" title="shadowmaster节点安装"></a>shadowmaster节点安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm –ivh lizardfs-master-3.13.0-0el7.x86_64.rpm</span><br><span class="line">rpm –ivh lizardfs-adm-3.13.0-0el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">cp /var/lib/mfs/metadata.mfs.empty  /var/lib/mfs/metadata.mfs</span><br><span class="line">cp /etc/mfs/mfsexports.cfg.dist  /etc/mfs/mfsexports.cfg</span><br><span class="line"></span><br><span class="line">vi /etc/mfs/mfsmaster.cfg</span><br><span class="line">PERSONALITY = shadow</span><br><span class="line"></span><br><span class="line">service lizardfs-master start</span><br></pre></td></tr></table></figure>
<p> shadowmaster节点与master节点的区别其实就是配置文件/etc/mfs/mfsmaster.cfg里面的PERSONALITY值不同。</p>
<h3 id="chunkserver与metalogger节点"><a href="#chunkserver与metalogger节点" class="headerlink" title="chunkserver与metalogger节点"></a>chunkserver与metalogger节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm –ivh lizardfs-chunkserver-3.13.0-0el7.x86_64.rpm</span><br><span class="line">rpm –ivh lizardfs-metalogger-3.13.0-0el7.x86_64.rpm</span><br><span class="line">vi /etc/default/lizardfs-chunkserver</span><br><span class="line">LIZARDFSCHUNKSERVER_ENABLE=true</span><br><span class="line">vi /etc/default/lizardfs-metalogger</span><br><span class="line">LIZARDFSMETALOGGER_ENABLE=true</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：下面的盘符需要根据实际环境上的做相应的修改：</em></strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.ext3 /dev/sdd</span><br><span class="line">mkdir /mnt/chunk1</span><br><span class="line">mount /dev/sdd /mnt/chunk1</span><br><span class="line">vi /etc/mfs/mfshdd.cfg</span><br><span class="line">/mnt/chunk1</span><br><span class="line"></span><br><span class="line">chown -R mfs:mfs /mnt/chunk1</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>如果需要多个盘，多次重复上面类似操作，可以mount到/mnt/chunk2，/mnt/chunk3…</li>
<li>chown -R mfs:mfs **,这个操作忘了会报权限错误</li>
</ul>
<p>启动metalogger<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service lizardfs-metalogger start</span><br></pre></td></tr></table></figure></p>
<p>启动chunkserver<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mfschunkserver start</span><br></pre></td></tr></table></figure></p>
<h3 id="cgiserver-节点"><a href="#cgiserver-节点" class="headerlink" title="cgiserver 节点"></a>cgiserver 节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm –ivh lizardfs-cgi-3.13.0-0el7.x86_64.rpm</span><br><span class="line">rpm –ivh lizardfs-cgiserv-3.13.0-0el7.x86_64.rpm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动cgiserver</span></span><br><span class="line">mfscgiserv start</span><br></pre></td></tr></table></figure>
<p>启动cgiserver后，便可以通过网页<a href="http://192.168.0.3:9425/mfs.cgi">http://192.168.0.3:9425/mfs.cgi</a> 查看目前集群的状态信息，包括master信息，chunkservers信息等等。</p>
<h3 id="client节点"><a href="#client节点" class="headerlink" title="client节点"></a>client节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install fuse</span><br><span class="line">yum install fuse-libs</span><br><span class="line">yum install bash-completion</span><br><span class="line">rpm –ivh lizardfs-client-3.13.0-0el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">mfsmount /mnt/lizardfs –H 192.168.0.1</span><br></pre></td></tr></table></figure>
<p>执行mfsmount之后，就可以像操作本地文件夹一样操作/mnt/lizardfs，非常方便，还可以设置副本策略等等。  </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://lizardfs.com/">LizardFS官网</a><br><a href="https://docs.lizardfs.com/adminguide/installation.html">Installing LizardFS</a></p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>LizardFS</tag>
        <tag>lizardfs</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>保险基本知识介绍</title>
    <url>/2019/01/18/%E4%BF%9D%E9%99%A9%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="http://wx3.sinaimg.cn/mw690/71c65545gy1fzb4u6idwij20i90c0td0.jpg" alt=""><br><span id="more"></span></p>
<p>本文是笔者对保险知识学习的基本总结，同时作为记录。两年前我曾为父母购买过返还型重疾险，现在看来这个保险是买的不合适的。在刚接触时，很多推销人员也很推荐这种类型的保险，听起来也很划算，叫“有病赔钱，没病返钱”。希望本文能你对保险有个基本认识，也能避开常见的误区，也就达到本文的目的了:)<br>本文主要把各项总结为各种原则。</p>
<p>原则一：保险越早买越好</p>
<h2 id="保险的分类"><a href="#保险的分类" class="headerlink" title="保险的分类"></a>保险的分类</h2><p><img src="http://wx2.sinaimg.cn/mw690/71c65545gy1fzb6r3whh3j21hc0u0408.jpg" alt=""><br>保险主要分为保障型和理财型<br><img src="http://wx1.sinaimg.cn/mw690/71c65545gy1fzb6r4cpcnj21hc0u0dht.jpg" alt=""><br>原则二：优先购买保障型保险，别买那种“有病赔钱，没病返钱”的返还型保险</p>
<p><img src="http://wx2.sinaimg.cn/mw690/71c65545gy1fzb76ifyynj21hc0u0gnn.jpg" alt=""><br>原则三：寿险和重疾险优先配置家里的经济支柱</p>
<h2 id="重疾险"><a href="#重疾险" class="headerlink" title="重疾险"></a>重疾险</h2><p>重疾险作为重中之重，是最应该配置的，关于重疾险一定要注意保额，否则丧失其意义<br>原则四：重疾险保额最重要，最好能包含基本医疗费用和经济损失<br>解释：一个人患了重疾之后，据统计平均医疗费用是30万左右，除医疗费用之外，重疾病人也丧失了经济收入且还有其他费用消耗，所以重疾的保额建议最少是30万<br>另外需要注意：</p>
<ul>
<li>是否包含轻症赔付很重要</li>
<li>小心多次赔付的噱头</li>
</ul>
<h2 id="意外险"><a href="#意外险" class="headerlink" title="意外险"></a>意外险</h2><p>该险种主要是针对发生意外，造成身故或者身残进行赔付，因为此类保险并不贵，一般一百多一年，保额建议是5 X 年收入（建议最低50万）</p>
<h2 id="寿险"><a href="#寿险" class="headerlink" title="寿险"></a>寿险</h2><ul>
<li>该险种是身故时赔付一笔钱</li>
<li>主要给家里经济支柱配置</li>
</ul>
<p>主要是家里经济支柱承担了家庭责任，如果这样的人一旦离去，那么对于家人来说，生活必然遭受很大的影响，所以寿险主要配置这类人，以减小对整个家庭的影响，因为小孩并不承担这类责任，所以可以不用给小孩配置寿险</p>
<p><strong>注意不用给小孩配置寿险，当然如果荷包饱满就随意啦(<em>￣︶￣)</em></strong><br><img src="http://wx2.sinaimg.cn/mw690/71c65545gy1fzb74q7703j21hc0u0acp.jpg" alt=""></p>
<h2 id="医疗险"><a href="#医疗险" class="headerlink" title="医疗险"></a>医疗险</h2><p>有人问有医保为啥还要医疗险，这个主要用于弥补医保的不足，因为医保也不是全额报销。</p>
<h2 id="给小孩配置保险的注意事项"><a href="#给小孩配置保险的注意事项" class="headerlink" title="给小孩配置保险的注意事项"></a>给小孩配置保险的注意事项</h2><ul>
<li>小孩子不用配置寿险，前面讲过原因了</li>
<li>切勿给小孩一堆保险，父母却在裸奔，在小孩完全没有经济能力的情况下，只有父母OK了，小孩才能OK</li>
<li>先给小孩上医保，而且有了医保后买保险通常也会更便宜</li>
<li>挑选儿童专属的重疾，保障到成年后，再配置其他险种，这样会更划算</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>理财和保障分开，不要买返还型保险</li>
<li>优先给家庭经济支柱配置保险</li>
<li>考虑到性价比，不要给小孩买捆绑了寿险的重疾险</li>
<li>预算再有限，都不要妥协保障额度，尤其是重疾险</li>
<li>不能人云亦云，要根据自己家庭情况进行合理规划和配置</li>
</ul>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>本文主要由参考小帮规划的公开课总结而成，如果侵权请联系我删除，谢谢: )</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>保险</tag>
      </tags>
  </entry>
  <entry>
    <title>lizardfs在同一个服务器上运行多个chunkserver的方法</title>
    <url>/2019/01/27/lizardfs%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AAchunkserver%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>有时候设备不够，需要在一台服务器上运行多个chunkserver，本文介绍这种场景下如何用LizardFS在同一个服务器上运行多个chunkserver。</p>
<h3 id="运行多个chunkserver的方法"><a href="#运行多个chunkserver的方法" class="headerlink" title="运行多个chunkserver的方法"></a>运行多个chunkserver的方法</h3><ol>
<li>为新增的chunkserver准备一个新的 mfschunkserver.cfg配置文件，比如/etc/chunkserver2.cfg</li>
<li>为新增的chunkserver准备一个新的mfshdd.cfg 配置文件，比如/etc/hdd2.cfg</li>
<li>把  /etc/chunkserver2.cfg  文件中的HDD_CONF_FILENAME值 设置为新添加的mfshdd.cfg配置文件路径，在本例中HDD_CONF_FILENAME值为 /etc/hdd2.cfg</li>
<li>把/etc/chunkserver2.cfg文件中的CSSERV_LISTEN_PORT项的值改为非默认值，设置为未被使用的端口（比如9522）</li>
<li>运行第二个chunkserver用如下命令：<br>mfschunkserver -c /etc/chunkserver2.cfg  </li>
<li>如果你需要在同一个服务器上创建更多的chunkservers可以重复上述步骤（然而并不推荐这样做）</li>
</ol>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="按照上面的操作执行之后没有看到多个chunkserver进程"><a href="#按照上面的操作执行之后没有看到多个chunkserver进程" class="headerlink" title="按照上面的操作执行之后没有看到多个chunkserver进程"></a>按照上面的操作执行之后没有看到多个chunkserver进程</h4><p>按照上面方法操作遇到一个常见的问题是，启动一个新的chunkserver进程后，原有的chunkserver进程就自动退出了，也就是说，通过ps -ef | grep mfschunkserver查看进程，始终只有一个chunkserver进程并且就是刚刚启动的那个！</p>
<p>经过多方尝试找到原因为：<br>配置文件中/etc/chunkserver2.cfg与/etc/mfs/mfschunkserver.cfg的<strong>DATA_PATH项</strong>的值相同，而DATA_PATH是表示存使用统计文件和锁文件的目录，所以要启动多个chunkserver进程，除上述操作外，需要确保chunkserver配置文件中的DATA_PATH项的值是不相同，以免起冲突。<br><strong>解决方法：</strong><br>为每个chunkserver的配置文件中<strong>DATA_PATH项</strong>都配置一个不同的值。</p>
<h4 id="权限错误"><a href="#权限错误" class="headerlink" title="权限错误"></a>权限错误</h4><p>除上述问题外，还需要注意 DATA_PATH项的值的目录需要是属于mfs:mfs的，否则会报权限错误<br>如果不是，可以使用“chown -R mfs:mfs 目录” 更改其用户组使得有权限</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://lizardfs.com/running-multiple-chunkservers-on-the-same-machine/">Running multiple chunkservers on the same machine.</a></p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>LizardFS</tag>
        <tag>分布式存储</tag>
        <tag>文件存储</tag>
        <tag>lizardfs</tag>
      </tags>
  </entry>
  <entry>
    <title>重置lizardfs的方法</title>
    <url>/2019/01/29/%E9%87%8D%E7%BD%AElizardfs%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>最近一直在使用lizardfs这个开源的分布式文件系统，经常会遇到各种问题，打算先遇到一个问题开一篇文章解决，后面再总结，来个使用lizardfs的常见问题。<br>本文介绍一种场景，我们希望清空目前lizardfs集群里面的所有东西，但是又不想重装lizardfs。  </p>
<h3 id="不用重装便能重置lizardfs的方法"><a href="#不用重装便能重置lizardfs的方法" class="headerlink" title="不用重装便能重置lizardfs的方法"></a>不用重装便能重置lizardfs的方法</h3><p>最简单的办法就是重新创建一个新的metadata文件<br>在你当前环境的master服务器的元数据目录下（查看mfsmaster.cfg文件的DATA_PATH字段），然后停止master并且创建一个新的空metadata文件通过执行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -n &quot;MFSM NEW&quot; &gt; metadata.mfs </span><br></pre></td></tr></table></figure><br>随后启动master，这样你的集群就被重置了，所有的chunks都会删除。</p>
<p>注： metadata.mfs默认在/var/lib/mfs/目录下</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://github.com/lizardfs/lizardfs/issues/465">How do I completely reset a cluster?</a> </p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>问题定位</tag>
        <tag>LizardFS</tag>
        <tag>lizardfs</tag>
        <tag>重置</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础技术介绍</title>
    <url>/2019/02/21/docker%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="http://wx4.sinaimg.cn/mw690/71c65545gy1g0e45m264hj20ic096q30.jpg" alt=""><br><span id="more"></span><br>本文主要介绍docker及其相关的技术，力求让大家读了此文和相关的参考资料之后就对docker技术有一个整体上的掌握，既可以作为入门阅读资料，又可以作为自己复习的资料 : )</p>
<h3 id="docker基础技术简介"><a href="#docker基础技术简介" class="headerlink" title="docker基础技术简介"></a>docker基础技术简介</h3><p>Docker是近些年云计算领域非常热门的技术，可能很多人认为该技术非常新颖，但其实除了其编程语言用go比较新外，其实它还真不是个新东西，其中用到了许多linux的一些老的技术，下面就分别对用的技术做一个简介，目的是让大家对docker基础技术有一个了解，如果想深入研究请查阅相关的参考资料和源码。</p>
<p>容器技术使用了一系列的系统级别的机制诸如利用Linux namespaces来进行空间隔离，通过文件系统的挂载点来决定容器可以访问哪些文件，通过cgroups来确定每个容器可以利用多少资源。此外容器之间共享同一个系统内核，这样当同一个库被多个容器使用时，内存的使用效率会得到提升。<br>Docker 包括三个基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）  </li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。<br>这三个概念更多信息请参考：<br><a href="https://yeasy.gitbooks.io/docker_practice/basic_concept/">基本概念</a></p>
<h4 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h4><p>Linux Namespace是Linux提供的一种内核级别环境隔离的方法 </p>
<p>Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步,我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因。<br>更多详细信息请参考：<br><a href="https://coolshell.cn/articles/17010.html">DOCKER基础技术：LINUX NAMESPACE（上）</a><br><a href="https://coolshell.cn/articles/17029.html">DOCKER基础技术：LINUX NAMESPACE（下）</a>  </p>
<h4 id="Linux-CGroup"><a href="#Linux-CGroup" class="headerlink" title="Linux CGroup"></a>Linux CGroup</h4><p> Linux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。<br>更多信息请参考：<br><a href="https://coolshell.cn/articles/17049.html">DOCKER基础技术：LINUX CGROUP</a> </p>
<h3 id="诞生背景"><a href="#诞生背景" class="headerlink" title="诞生背景"></a>诞生背景</h3><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？<br>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。<br>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。<br>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>
<h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。<br>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。<br>（1）资源占用多<br>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。<br>（2）冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。<br>（3）启动慢<br>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>
<h4 id="Linux-容器"><a href="#Linux-容器" class="headerlink" title="Linux 容器"></a>Linux 容器</h4><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。<br>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。<br>由于容器是进程级别的，相比虚拟机有很多优势。  </p>
<ul>
<li>启动快</li>
</ul>
<p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>
<ul>
<li>资源占用少</li>
</ul>
<p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
<ul>
<li>体积小</li>
</ul>
<p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。<br>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>
<h3 id="docker与虚拟化的区别"><a href="#docker与虚拟化的区别" class="headerlink" title="docker与虚拟化的区别"></a>docker与虚拟化的区别</h3><p><img src="http://wx1.sinaimg.cn/mw690/71c65545gy1g0e45katj0j20j8079q33.jpg" alt=""><br><img src="http://wx2.sinaimg.cn/mw690/71c65545gy1g0e45l99msj20j505ft8t.jpg" alt=""><br>上面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。  </p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。  </p>
<p>对于系统虚拟化技术来说，虚拟层为用户提供了一个完整的虚拟机：包括内核在内的一个完整的系统镜像。CPU虚拟化技术可以为每个用户提供一个独享且和其他用户隔离的系统环境，虚拟层可以为每个用户分配虚拟化后的CPU、内存和IO设备资源。<br>当然由上所述，可以知道虚拟机的隔离性还是要优于容器的。</p>
<p>更多docker相关的信息请查阅文末的参考资料。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a><br><a href="https://yeasy.gitbooks.io/docker_practice/">Docker — 从入门到实践</a><br><a href="https://coolshell.cn/articles/17010.html">DOCKER基础技术：LINUX NAMESPACE（上）</a><br><a href="https://coolshell.cn/articles/17029.html">DOCKER基础技术：LINUX NAMESPACE（下）</a><br><a href="https://coolshell.cn/articles/17049.html">DOCKER基础技术：LINUX CGROUP</a><br><a href="https://coolshell.cn/articles/17061.html">DOCKER基础技术：AUFS</a><br><a href="https://coolshell.cn/articles/17200.html">DOCKER基础技术：DEVICEMAPPER</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
        <tag>namespace</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>从Habor源码进行安装及打包</title>
    <url>/2019/03/27/%E4%BB%8EHabor%E6%BA%90%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E5%8F%8A%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/04/gmxK7F.jpg" alt=""><br><span id="more"></span><br>   本文将介绍从Habor的源码进行安装部署和从源码打包的方法。由于笔者在近期的项目过程中会需要修改Habor源码，所以必须要从源码开始编译打包并进行安装部署，本文也是记录这个过程中踩过的坑。</p>
<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><table>
<thead>
<tr>
<th>资源</th>
<th>容量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU</td>
<td>minimal 2 CPU</td>
<td>4 CPU is prefered</td>
</tr>
<tr>
<td>Mem</td>
<td>minimal 4GB</td>
<td>8GB is prefered</td>
</tr>
<tr>
<td>Disk</td>
<td>minimal 40GB</td>
<td>160GB is prefered</td>
</tr>
</tbody>
</table>
<h3 id="软件要求"><a href="#软件要求" class="headerlink" title="软件要求"></a>软件要求</h3><table>
<thead>
<tr>
<th>Software</th>
<th>Version</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python</td>
<td>version 2.7 or higher</td>
<td>Note that you may have to install Python on Linux distributions (Gentoo, Arch) that do not come with a Python interpreter installed by default</td>
</tr>
<tr>
<td>Docker engine</td>
<td>version 1.10 or higher</td>
<td>For installation instructions, please refer to: <a href="https://docs.docker.com/engine/installation/">https://docs.docker.com/engine/installation/</a></td>
</tr>
<tr>
<td>Docker Compose</td>
<td>version 1.6.0 or higher</td>
<td>For installation instructions, please refer to: <a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a></td>
</tr>
<tr>
<td>Openssl</td>
<td>latest is prefered</td>
<td>Generate certificate and keys for Harbor</td>
</tr>
</tbody>
</table>
<h2 id="官方的从源码编译安装的指导文档"><a href="#官方的从源码编译安装的指导文档" class="headerlink" title="官方的从源码编译安装的指导文档"></a>官方的从源码编译安装的指导文档</h2><h3 id="Step-1-为Habor准备编构建环境"><a href="#Step-1-为Habor准备编构建环境" class="headerlink" title="Step 1: 为Habor准备编构建环境"></a>Step 1: 为Habor准备编构建环境</h3><p>Habor是部署为几个docker容器，并且其大部分代码均采用GO语言编写。编译环境需要 Python, Docker, Docker Compose 和 GO语言的开发环境。请安装下面必须预先安装的软件:</p>
<table>
<thead>
<tr>
<th>Software</th>
<th>Required Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>docker</td>
<td>1.12.0 +</td>
</tr>
<tr>
<td>docker-compose</td>
<td>1.11.0 +</td>
</tr>
<tr>
<td>python</td>
<td>2.7 +</td>
</tr>
<tr>
<td>git</td>
<td>1.9.1 +</td>
</tr>
<tr>
<td>make</td>
<td>3.81 +</td>
</tr>
<tr>
<td>golang*</td>
<td>1.7.3 +</td>
</tr>
</tbody>
</table>
<p>*optional, required only if you use your own Golang environment.</p>
<p><strong>用自己go环境才需要预先安装GO环境</strong></p>
<h3 id="Step-2-获取源代码"><a href="#Step-2-获取源代码" class="headerlink" title="Step 2: 获取源代码"></a>Step 2: 获取源代码</h3>   <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/vmware/harbor</span><br></pre></td></tr></table></figure>
<p>   也可以到发布页面<a href="https://github.com/goharbor/harbor/releases">habor release</a>下载自己需要的版本</p>
<h3 id="Step-3-构建安装habor"><a href="#Step-3-构建安装habor" class="headerlink" title="Step 3: 构建安装habor"></a>Step 3: 构建安装habor</h3><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>编辑 <strong>make/harbor.cfg</strong> ，主要做必要的配置修改，比如 hostname, admin password and mail server等，详细信息可以参考官方的<strong><a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md">Installation and Configuration Guide</a></strong> 。</p>
   <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> harbor</span><br><span class="line">$ vi make/harbor.cfg</span><br></pre></td></tr></table></figure>
<h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><p>你可以用下面的三种方法之一来编译habor源码：</p>
<h5 id="I-用官方的-Golang-image来编译构建"><a href="#I-用官方的-Golang-image来编译构建" class="headerlink" title="I. 用官方的 Golang image来编译构建"></a>I. 用官方的 Golang image来编译构建</h5><ul>
<li><p>从docker hub获取 Golang image:</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker pull golang:1.9.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译构建，安装启动Habor不带Notary:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make install GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译构建，安装启动Habor带Notary:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make install GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0 NOTARYFLAG=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译构建，安装启动Habor带 Clair:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make install GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0 CLAIRFLAG=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="II-用自己的GO开发环境来编译Habor，然后构建-Harbor"><a href="#II-用自己的GO开发环境来编译Habor，然后构建-Harbor" class="headerlink" title="II. 用自己的GO开发环境来编译Habor，然后构建 Harbor"></a>II. 用自己的GO开发环境来编译Habor，然后构建 Harbor</h4><ul>
<li><p>把源码放到 $GOPATH</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="variable">$GOPATH</span>/src/github.com/vmware/</span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ <span class="built_in">mv</span> harbor <span class="variable">$GOPATH</span>/src/github.com/vmware/.</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译构建，安装启动Habor不带Notary Notary 和 Clair:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/vmware/harbor</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译构建，安装启动Habor带  Notary 和 Clair:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">      $ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/vmware/harbor</span><br><span class="line">      $ make install -e NOTARYFLAG=<span class="literal">true</span> CLAIRFLAG=<span class="literal">true</span></span><br><span class="line">   ```   </span><br><span class="line"> </span><br><span class="line"><span class="comment">### 验证你的安装</span></span><br><span class="line"></span><br><span class="line">If everything worked properly, you can get the below message:</span><br><span class="line"></span><br><span class="line">   ```sh</span><br><span class="line">      ...</span><br><span class="line">      Start complete. You can visit harbor now.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Refer to <a href="installation_guide.md#managing-harbors-lifecycle">Installation and Configuration Guide</a> for more information about managing your Harbor instance.   </p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>使用 Makefile</li>
</ul>
<p>The <code>Makefile</code> contains these configurable parameters:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BASEIMAGE</td>
<td>Container base image, default: photon</td>
</tr>
<tr>
<td>CLARITYIMAGE</td>
<td>Clarity UI builder image, default: harbor-clarity-ui-builder</td>
</tr>
<tr>
<td>DEVFLAG</td>
<td>Build model flag, default: dev</td>
</tr>
<tr>
<td>COMPILETAG</td>
<td>Compile model flag, default: compile_normal (local golang build)</td>
</tr>
<tr>
<td>NOTARYFLAG</td>
<td>Notary mode flag, default: false</td>
</tr>
<tr>
<td>CLAIRFLAG</td>
<td>Clair mode flag, default: false</td>
</tr>
<tr>
<td>HTTPPROXY</td>
<td>NPM http proxy for Clarity UI builder</td>
</tr>
<tr>
<td>REGISTRYSERVER</td>
<td>Remote registry server IP address</td>
</tr>
<tr>
<td>REGISTRYUSER</td>
<td>Remote registry server user name</td>
</tr>
<tr>
<td>REGISTRYPASSWORD</td>
<td>Remote registry server user password</td>
</tr>
<tr>
<td>REGISTRYPROJECTNAME</td>
<td>Project name on remote registry server</td>
</tr>
<tr>
<td>VERSIONTAG</td>
<td>Harbor images tag, default: dev</td>
</tr>
<tr>
<td>PKGVERSIONTAG</td>
<td>Harbor online and offline version tag, default:dev</td>
</tr>
</tbody>
</table>
<ul>
<li>Predefined targets:</li>
</ul>
<table>
<thead>
<tr>
<th>Target</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>all</td>
<td>prepare env, compile binaries, build images and install images</td>
</tr>
<tr>
<td>prepare</td>
<td>prepare env</td>
</tr>
<tr>
<td>compile</td>
<td>compile ui and jobservice code</td>
</tr>
<tr>
<td>compile_ui</td>
<td>compile ui binary</td>
</tr>
<tr>
<td>compile_jobservice</td>
<td>compile jobservice binary</td>
</tr>
<tr>
<td>compile_clarity</td>
<td>compile Clarity binary</td>
</tr>
<tr>
<td>build</td>
<td>build Harbor docker images (default: using build_photon)</td>
</tr>
<tr>
<td>build_photon</td>
<td>build Harbor docker images from Photon OS base image</td>
</tr>
<tr>
<td>install</td>
<td>compile binaries, build images, prepare specific version of compose file and startup Harbor instance</td>
</tr>
<tr>
<td>start</td>
<td>startup Harbor instance (set NOTARYFLAG=true when with Notary)</td>
</tr>
<tr>
<td>down</td>
<td>shutdown Harbor instance (set NOTARYFLAG=true when with Notary)</td>
</tr>
<tr>
<td>package_online</td>
<td>prepare online install package</td>
</tr>
<tr>
<td>package_offline</td>
<td>prepare offline install package</td>
</tr>
<tr>
<td>pushimage</td>
<td>push Harbor images to specific registry server</td>
</tr>
<tr>
<td>clean all</td>
<td>remove binary, Harbor images, specific version docker-compose file, specific version tag and online/offline install package</td>
</tr>
<tr>
<td>cleanbinary</td>
<td>remove ui and jobservice binary</td>
</tr>
<tr>
<td>cleanimage</td>
<td>remove Harbor images</td>
</tr>
<tr>
<td>cleandockercomposefile</td>
<td>remove specific version docker-compose</td>
</tr>
<tr>
<td>cleanversiontag</td>
<td>remove specific version tag</td>
</tr>
<tr>
<td>cleanpackage</td>
<td>remove online/offline install package</td>
</tr>
</tbody>
</table>
<p>好了，看了官方的指引，感觉还好挺简单的嘛，然后就开始踩坑旅程。</p>
<h2 id="在windows版本下踩过的坑（最终放弃在windows下安装，坑太多了）"><a href="#在windows版本下踩过的坑（最终放弃在windows下安装，坑太多了）" class="headerlink" title="在windows版本下踩过的坑（最终放弃在windows下安装，坑太多了）"></a>在windows版本下踩过的坑（最终放弃在windows下安装，坑太多了）</h2><p>python安装（略）</p>
<h3 id="windows下docker安装"><a href="#windows下docker安装" class="headerlink" title="windows下docker安装"></a>windows下docker安装</h3><p>到docker官网下载windows版本<a href="https://docs.docker-cn.com/docker-for-windows/install/">Install Docker for Windows</a><br>Docker发布了Docker for Windows的正式版，于是就可以在Windows下运行Docker容器了。要在Windows下运行Docker，需要满足以下先决条件：</p>
<ul>
<li>64位Windows 10 Pro、Enterprise或者Education版本（Build 10586以上版本，需要安装1511 November更新）</li>
<li>在系统中启用Hyper-V。如果没有启用，Docker for Windows在安装过程中会自动启用Hyper-V（这个过程需要重启系统）</li>
</ul>
<p>由于本人电脑是win10家庭版系统，并没有仔细看说明，安装好Docker for Windows之后运行报错：<strong>Docker for Windows requires Windows 10 Pro or Enterprise version 10586, or Windows server 2016 RTM to run</strong><br><img src="https://z3.ax1x.com/2021/05/04/gmx1h9.jpg" alt=""><br>也就是说docker要求win10用户是pro版的，那普通版用户就没法用docker了呢，不过，如果不是使用的Windows 10，也没有关系，可以使用Docker Toolbox作为替代方案。Docker Toolbox on Windows安装步骤参考：<br><a href="https://docs.docker-cn.com/toolbox/toolbox_install_windows/">Install Docker Toolbox on Windows</a></p>
<h3 id="Windows下make安装"><a href="#Windows下make安装" class="headerlink" title="Windows下make安装"></a>Windows下make安装</h3><p>先安装MinGW官网下载地址：<a href="https://sourceforge.net/projects/mingw/files/latest/download?source=files">https://sourceforge.net/projects/mingw/files/latest/download?source=files</a></p>
<p>环境变量：F:\MINGW\bin</p>
<p>在cmd里面输入命令：mingw-get install gcc g++ mingw32-make</p>
<h3 id="检查环境报错check-env-failed-CreateProcess-give-error-193"><a href="#检查环境报错check-env-failed-CreateProcess-give-error-193" class="headerlink" title="检查环境报错check env failed (CreateProcess give error 193)"></a>检查环境报错check env failed (CreateProcess give error 193)</h3><p>安装好需要的软件之后，运行<br>  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ make install GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0</span><br></pre></td></tr></table></figure><br>   报如下错误：<br><img src="https://z3.ax1x.com/2021/05/04/gmx8pR.jpg" alt=""><br>参考<a href="https://stackoverflow.com/questions/12637203/why-does-createprocess-give-error-193-1-is-not-a-valid-win32-app"> CreateProcess give error 193 </a>：</p>
<blockquote>
<p>The file you are attempting to load is not an executable file. CreateProcess requires you to provide an executable file. If you wish to be able to open any file with its associated application then you need ShellExecute rather than CreateProcess</p>
</blockquote>
<p><img src="https://z3.ax1x.com/2021/05/04/gmxG11.jpg" alt=""><br>查看源码是在执行checkenv.sh脚本，看该脚本权限，确实没有可执行权限<br><img src="https://z3.ax1x.com/2021/05/04/gmxJ6x.jpg" alt=""><br>因此将脚本修改为<br><img src="https://z3.ax1x.com/2021/05/04/gmxYX6.jpg" alt=""></p>
<h3 id="“sh-C-Program-No-such-file-or-directory”"><a href="#“sh-C-Program-No-such-file-or-directory”" class="headerlink" title="“sh: C:\Program: No such file or directory”"></a>“sh: C:\Program: No such file or directory”</h3><p>改掉这之后，继续又遇到“sh: C:\Program: No such file or directory”错误，查阅资料发现可能是windows里面make版本可能存在bug，遂放弃在windows尝试的念头了。有兴趣的童鞋可以查看：<a href="https://github.com/STAT545-UBC/Discussion/issues/54">sh: C:\Program: No such file or directory</a></p>
<h2 id="在Linux下面的安装（CentOS-7）"><a href="#在Linux下面的安装（CentOS-7）" class="headerlink" title="在Linux下面的安装（CentOS 7）"></a>在Linux下面的安装（CentOS 7）</h2><p>下面的安装步骤都是针对CentOS 7,其他版本系统请参考各软件官方的安装方法。</p>
<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>移除旧的版本：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> yum remove docker \</span></span><br><span class="line"><span class="language-bash">                  docker-client \</span></span><br><span class="line"><span class="language-bash">                  docker-client-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-common \</span></span><br><span class="line"><span class="language-bash">                  docker-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-latest-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-selinux \</span></span><br><span class="line"><span class="language-bash">                  docker-engine-selinux \</span></span><br><span class="line"><span class="language-bash">                  docker-engine</span></span><br></pre></td></tr></table></figure><br>安装一些必要的系统工具：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></p>
<p>添加软件源信息：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><br>更新 yum 缓存：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><br>安装 Docker-ce：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum -y install docker-ce</span><br></pre></td></tr></table></figure><br>启动 Docker 后台服务<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><br>测试运行 hello-world<br><img src="https://z3.ax1x.com/2021/05/04/gmxNnK.md.jpg" alt=""></p>
<h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><p>步骤1：把下面命令中版本1.23.2换成你需要的版本<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></p>
<p>步骤2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></p>
<p>步骤3：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure></p>
<p>步骤4：验证安装是否成功<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.23.2, build 1110ad01</span><br></pre></td></tr></table></figure></p>
<h4 id="安装docker-compose遇到的问题"><a href="#安装docker-compose遇到的问题" class="headerlink" title="安装docker-compose遇到的问题"></a>安装docker-compose遇到的问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>出现<strong>curl:(6) Could not resovle host: github.com</strong>之类的错误<br><strong>解决办法</strong>：</p>
<ul>
<li>Linux在/etc/hosts文件中添加：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.30.253.113    github.com  </span><br><span class="line">192.30.252.131 github.com  </span><br><span class="line">185.31.16.185 github.global.ssl.fastly.net  </span><br><span class="line">74.125.237.1 dl-ssl.google.com  </span><br><span class="line">173.194.127.200 groups.google.com  </span><br><span class="line">192.30.252.131 github.com  </span><br><span class="line">185.31.16.185 github.global.ssl.fastly.net  </span><br><span class="line">74.125.128.95 ajax.googleapis.com  </span><br></pre></td></tr></table></figure>
<ul>
<li>Windows：<br>在路径C:\Windows\System32\drivers\etc<br>找到host文件，右键-属性-安全-编辑，选中当前电脑登录的用户，给自己最高权限，确认。<br>然后用记事本打开，将</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.30.253.113    github.com</span><br><span class="line">192.30.252.131 github.com</span><br><span class="line">185.31.16.185 github.global.ssl.fastly.net</span><br><span class="line">74.125.237.1 dl-ssl.google.com</span><br><span class="line">173.194.127.200 groups.google.com</span><br><span class="line">192.30.252.131 github.com</span><br><span class="line">185.31.16.185 github.global.ssl.fastly.net</span><br><span class="line">74.125.128.95 ajax.googleapis.com</span><br></pre></td></tr></table></figure>
<p>添加到最后即可。</p>
<h2 id="编译打包Habor离线包出现”invalid-reference-format”错误"><a href="#编译打包Habor离线包出现”invalid-reference-format”错误" class="headerlink" title="编译打包Habor离线包出现”invalid reference format”错误"></a>编译打包Habor离线包出现”invalid reference format”错误</h2><p>错误如图<br><img src="https://z3.ax1x.com/2021/05/04/gmxU0O.jpg" alt=""><br>解决办法：<br><a href="https://github.com/goharbor/harbor/issues/5316">https://github.com/goharbor/harbor/issues/5316</a></p>
<p>使用正确的编译打包命令,如下的命令打包不包括NOTARY，CLAIR，MIGRATOR，CHART等：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make package_offline GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0</span><br></pre></td></tr></table></figure></p>
<p>如果需要签名工具和漏洞扫描工具则用如下命令打包：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make package_offline GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0 NOTARYFLAG=true CLAIRFLAG=true MIGRATORFLAG=true CHARTFLAG=true HTTPPROXY=</span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>vmware/harbor-clarity-ui-builder:后面那个版本号请根据实际填写</li>
<li>如未有特别说明，其余步骤按照官方指导操作即可</li>
<li>在线安装包直接执行make package_online即可</li>
</ul>
<p>成功打出了离线安装包<br><img src="https://z3.ax1x.com/2021/05/04/gmxa7D.jpg" alt=""></p>
<h2 id="Harbor的启动和停止"><a href="#Harbor的启动和停止" class="headerlink" title="Harbor的启动和停止"></a>Harbor的启动和停止</h2><p>Harbor 的日常运维管理是通过docker-compose来完成的，Harbor本身有多个服务进程，都放在docker容器之中运行，我们可以通过docker ps命令查看:<br><img src="https://z3.ax1x.com/2021/05/04/gmxwAe.jpg" alt=""></p>
<p>或者docker-compose ps来查看：<br><img src="https://z3.ax1x.com/2021/05/04/gmx0tH.jpg" alt=""></p>
<p><strong>注意</strong>:使用docker-compose ps来查看habor，路径要正确，否则会报<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:</span><br><span class="line">        Can&#x27;t find a suitable configuration file in this directory or any</span><br><span class="line">        parent. Are you in the right directory?</span><br><span class="line"></span><br><span class="line">        Supported filenames: docker-compose.yml, docker-compose.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>启动Harbor<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker-compose start</span><br></pre></td></tr></table></figure><br>停止Harbor<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker-comose stop</span><br></pre></td></tr></table></figure><br>重启Harbor<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker-compose restart</span><br></pre></td></tr></table></figure></p>
<h2 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h2><p>根据自己的配置情况输入访问的域名；<br>默认账号密码： admin / Harbor12345 登录后可修改密码<br>登录成功后如下图：<br><img src="https://z3.ax1x.com/2021/05/04/gmxBhd.jpg" alt=""></p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md">Habor Installation and Configuration Guide</a><br><a href="https://github.com/goharbor/harbor/issues/5316">Is COMPILETAG still in use? </a><br><a href="https://stackoverflow.com/questions/12637203/why-does-createprocess-give-error-193-1-is-not-a-valid-win32-app"> CreateProcess give error 193 </a><br><a href="https://github.com/STAT545-UBC/Discussion/issues/54">sh: C:\Program: No such file or directory</a><br><a href="http://www.runoob.com/docker/centos-docker-install.html">CentOS Docker 安装</a><br><a href="https://www.cnblogs.com/pangguoping/p/7650014.html">搭建Harbor企业级docker仓库</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>habor</tag>
        <tag>habor安装</tag>
        <tag>habor打包</tag>
      </tags>
  </entry>
  <entry>
    <title>解决git push 报错ERROR “Permission to xxx.git denied to deploy key”</title>
    <url>/2019/04/03/%E8%A7%A3%E5%86%B3git%20push%20%E6%8A%A5%E9%94%99ERROR%20%E2%80%9CPermission%20to%20xxx.git%20denied%20to%20deploy%20key%E2%80%9D/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/04/gmxCTg.jpg" alt=""><br><span id="more"></span><br>   本文记录解决git push 报错ERROR “Permission to xxx.git denied to deploy key”的过程和方法。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> git push -u origin master</span><br><span class="line">ERROR: Permission to ahnselina/data-structure.git denied to deploy key</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br></pre></td></tr></table></figure>
<p><img src="https://z3.ax1x.com/2021/05/04/gmxEpn.jpg" alt=""><br>还遇到过：<br><img src="https://z3.ax1x.com/2021/05/04/gmxZ60.jpg" alt=""></p>
<h2 id="查阅资料和解决办法"><a href="#查阅资料和解决办法" class="headerlink" title="查阅资料和解决办法"></a>查阅资料和解决办法</h2><h3 id="deploy-key"><a href="#deploy-key" class="headerlink" title="deploy key"></a>deploy key</h3><p>deploy key 每个 Repository 都有一个，主要用于 push 代码时使用。每个 Repo 的 deploy key 都是单独设置的，不能多个 Repo 使用相同的 deploy key。如果 Repository 没有添加 deploy key 时直接 push 代码，会出现权限错误：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not write to remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><br>生成 deploy key</p>
<p>deploy key 和 ssh key 本质是一样的，都可以用 ssh-keygen 命令生成。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -f ~/.ssh/deploy_key_repo1</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /Users/kang/.ssh/test.</span><br><span class="line">Your public key has been saved in /Users/kang/.ssh/test.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:Z//9gcDS40LheYjxpZOuDgbG5wRQ9X7O7BTXfo134es kang@ruikye</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">| .....           |</span><br><span class="line">|  .   .          |</span><br><span class="line">|   .   o . .     |</span><br><span class="line">|  . . . = X .    |</span><br><span class="line">|   + o oS&amp;oB . . |</span><br><span class="line">|  . =   BoB.+ o.o|</span><br><span class="line">|     +   B ..o.++|</span><br><span class="line">|    . . + .  ..o+|</span><br><span class="line">|      .o .    oE+|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意： 因为在生成 ssh-key 使用了默认 id_rsa.pub 文件存储，所以 deploy key 要放在其他的文件中。</p>
</blockquote>
<p>由于 deploy key 不是放在默认文件，所以 deploy key 不能直接使用，需要添加到SSL的认证列表中：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加默认的 id_rsa</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line"># 添加 deploy key</span><br><span class="line">$ ssh-add ~/.ssh/deploy_key_repo1</span><br><span class="line"># 查看所有 add 的 keys</span><br><span class="line">$ ssh-add -l</span><br><span class="line">2048 SHA256:kqQTYy......dsp+8 /Users/your/.ssh/id_rsa (RSA)</span><br><span class="line">2048 SHA256:0b/vdS......62tok /Users/your/.ssh/deploy_key_repo1 (RSA)</span><br></pre></td></tr></table></figure><br>执行ssh-add时出现Could not open a connection to your authentication agent</p>
<p><img src="https://z3.ax1x.com/2021/05/04/gmxeXV.jpg" alt=""><br>若执行ssh-add /path/to/xxx.pem是出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　ssh-agent bash</span><br></pre></td></tr></table></figure><br>更多关于ssh-agent的细节，可以用 man ssh-agent 来查看</p>
<p>添加 deploy key<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复制 deploy key</span><br><span class="line">$ cat ~/.ssh/deploy_key_repo1.pub | pbcopy</span><br></pre></td></tr></table></figure><br>打开 Repository 的设置页，在 Deploy keys -&gt; Add deploy key 添加公钥并勾选 Allow write access。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>试了多种方法未果，最终发现用如下方法有效：<br>第一步：将ssh改为https，打开对应项目目录的 .git/config文件<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim .git/config</span><br></pre></td></tr></table></figure><br>改之后如下图：<br><img src="https://z3.ax1x.com/2021/05/04/gmxnmT.jpg" alt=""></p>
<p>第二步：修改之后会让输入github的用户名密码，输入之后可以采用如下命令来缓存，以免每次都输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper wincred</span><br></pre></td></tr></table></figure></p>
<p>第三步：解决遇到的新错误<br>修改之后继续git push，遇到如下的错误<br><img src="https://z3.ax1x.com/2021/05/04/gmxu0U.md.jpg" alt=""><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push</span><br><span class="line">Fatal: HttpRequestException encountered.</span><br><span class="line">fatal: Out of memory, malloc failed (tried to allocate 2813163520 bytes)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/ahnselina/data-structure.git&#x27;</span><br></pre></td></tr></table></figure><br>然后继续解决该问题：<br>在对应项目目录的 .git/config文件中加入如下内容<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[http]</span><br><span class="line">  postbuffer = 1024m</span><br></pre></td></tr></table></figure><br>然后git push发现问题解决:)</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://stackoverflow.com/questions/41120920/git-fatal-out-of-memory-malloc-failed-tried-to-allocate-889192448-bytes">GIT: fatal: Out of memory, malloc failed (tried to allocate 889192448 bytes)</a>  </p>
<p><a href="https://help.github.com/en/articles/error-permission-denied-publickey">Error: Permission denied (publickey)</a>  </p>
<p><a href="https://stackoverflow.com/questions/8855317/git-push-out-of-memory-malloc-failed">git push Out of memory, malloc failed</a>  </p>
<p><a href="https://help.github.com/en/articles/caching-your-github-password-in-git">Caching your GitHub password in Git</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git使用</tag>
        <tag>git push error</tag>
        <tag>git报错</tag>
      </tags>
  </entry>
  <entry>
    <title>Habor初印象</title>
    <url>/2019/03/26/Habor%E5%88%9D%E5%8D%B0%E8%B1%A1/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/04/gmxr9A.jpg" alt=""><br><span id="more"></span><br>部署企业私有镜像仓库往往是很有必要的, 它可以帮助你管理企业的一些敏感镜像, 同时由于Docker Hub的下载速度和GFW的原因, 往往需要将一些无法直接下载的镜像导入本地私有仓库。 而Harbor就是部署<strong>企业级镜像仓库</strong>的一个不二之选，本文主要对Habor做一个简要介绍。</p>
<h3 id="Habor简介"><a href="#Habor简介" class="headerlink" title="Habor简介"></a>Habor简介</h3><p>Harbor是vmware开源的企业级registry，可以让你迅速的搭建自己的私有registry，harbor扩展的docker的registry，使harbor支持以下特性：</p>
<ul>
<li>RBAC 基于角色的权限控制: 用户与Docker镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限</li>
<li>基于策略的镜像复制: 镜像可以在多个Registry实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。</li>
<li>漏洞扫描</li>
<li>LDAP/AD支持:  Harbor可以集成企业内部已有的AD/LDAP，用于鉴权认证管理</li>
<li>镜像删除和垃圾清理</li>
<li>Notary 镜像签名</li>
<li>用户界面: 用户可以通过浏览器来浏览，检索当前Docker镜像仓库，管理项目和命名空间。</li>
<li>审计日志: 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。</li>
<li>RESTful api</li>
<li>安装简单:提供在线和离线两种安装工具  </li>
</ul>
<p>Harbor是container镜像仓库，其主要作用是为管理和服务container镜像提供一个安全的环境，用户可以用habor打造一个私有的镜像仓库；这对一些想管理自己的镜像又不想开源的企业来说是有用的。Habor既然是container镜像仓库，那么就应当是存储镜像的，这个可能是大多数接触harbor的人的一个误区，当深入了解以后才发现，镜像的存储harbor使用的是官方的docker registry服务去完成，至于registry是用本地存储或者s3都是可以的，harbor的功能是在此之上提供用户权限管理、镜像复制等功能，提高使用的registry的效率。</p>
<h3 id="Habor架构"><a href="#Habor架构" class="headerlink" title="Habor架构"></a>Habor架构</h3><p>Habor发展至今，架构肯定有一些变化，下面的图是参考网上的，不是最新的架构，不过应该变化不大，可以参考一下：<br><img src="https://z3.ax1x.com/2021/05/04/gmxTcq.jpg" alt=""><br><img src="https://z3.ax1x.com/2021/05/04/gmx7j0.jpg" alt=""></p>
<ul>
<li>harbor-adminserver：harbor系统管理接口，可以修改系统配置以及获取系统信息</li>
<li>harbor-db：存储项目的元数据、用户、规则、复制策略等信息</li>
<li>harbor-jobservice：harbor里面主要是为了镜像仓库之前同步使用的</li>
<li>harbor-log：收集其他harbor的日志信息。rsyslogd</li>
<li>harbor-ui：一个用户界面模块，用来管理registry。主要是前端的页面和后端CURD的接口</li>
<li>nginx：harbor的一个反向代理组件，代理registry、ui、token等服务。这个代理会转发harbor web<br>和 docker client的各种请求到后端服务上。nginx负责流量转发和安全验证，对外提供的流量都是从nginx中转，它将流量分发到后端的ui和正在docker镜像存储的docker registry</li>
<li>registry：存储docker images的服务，并且提供pull/push服务。harbor需要对image的访问进行访问控制，当client每次进行pull、push的时候，registry都需要client去token服务获取一个可用的token。</li>
<li>redis：存储缓存信息</li>
<li>webhook：当registry中的image状态发生变化的时候去记录更新日志、复制等操作。</li>
<li>token service：在docker client进行pull/push的时候今天token的发放。</li>
</ul>
<h3 id="Registry相关概念"><a href="#Registry相关概念" class="headerlink" title="Registry相关概念"></a>Registry相关概念</h3><p>我们一般在使用Docker的过程中更为常用的是pull image、run image、build image和push image。主要是围绕image展开的。</p>
<p>image和Registry的关系可以想象成自己机器上的源码和远端SVN或者Git服务的关系。Registry是一个几种存放image并对外提供上传下载以及一系列API的服务。可以很容易和本地源代码以及远端Git服务的关系相对应。</p>
<p>Docker hub是Docker公司提供的一些存储镜像的空间，这部分空间是有限的。我们一般会自主建设Docker私有仓库Registry。</p>
<h3 id="Repository和Registry区别"><a href="#Repository和Registry区别" class="headerlink" title="Repository和Registry区别"></a>Repository和Registry区别</h3><p>Repository：本身是一个仓库，这个仓库里面可以放具体的镜像，是指具体的某个镜像的仓库，比如Tomcat下面有很多个版本的镜像，它们共同组成了Tomcat的Repository。</p>
<p>Registry：镜像的仓库，比如官方的是Docker Hub，它是开源的，也可以自己部署一个，Registry上有很多的Repository，Redis、Tomcat、MySQL等等Repository组成了Registry。</p>
<h3 id="clair"><a href="#clair" class="headerlink" title="clair"></a>clair</h3><p>clair是 coreos 开源的容器漏洞扫描工具，在容器逐渐普及的今天，容器镜像安全问题日益严重。clair 是目前少数的开源安全扫描工具，主要提供OS（centos，debian，ubuntu等）的软件包脆弱性扫描。clair既可以单机部署也可以部署到k8s上，并可以与现有的registry集成。harbor 很好的整合了 clair ，通过简单的UI就可以对上传的镜像扫描，还可以通过每天的定时扫描对所有镜像进行统一扫描，架构如下：<br><img src="https://z3.ax1x.com/2021/05/04/gmxqBT.jpg" alt=""></p>
<blockquote>
<p>注意不要混淆Clair 和 clarity，Clair is not clarity, clarity is the UI library we used, while clair is the docker image scanner.<br><a href="https://github.com/goharbor/harbor/issues/3464">按照 docs/compile_guide.md 进行源码编译出错</a></p>
</blockquote>
<h3 id="Notary"><a href="#Notary" class="headerlink" title="Notary"></a>Notary</h3><p>Notary是一套docker镜像的签名工具， 用来保证镜像在pull，push和传输工程中的一致性和完整性。避免中间人攻击，避免非法的镜像更新和运行。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://github.com/goharbor/harbor">Harbor github</a><br><a href="https://github.com/goharbor/harbor/issues/3464">按照 docs/compile_guide.md 进行源码编译出错</a><br><a href="https://blog.csdn.net/u010278923/article/details/77941995">谈谈我对Harbor认识</a><br><a href="http://www.cnblogs.com/zhaojiankai/p/7813969.html">Registry私有仓库搭建及认证</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>habor简介</tag>
        <tag>habor介绍</tag>
        <tag>私有仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>docker registry 后端存储分析</title>
    <url>/2019/04/16/docker%20registry%20%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/04/gmv7wD.png" alt=""><br><span id="more"></span><br>Docker 的核心组件包括：</p>
<ul>
<li>Docker 客户端 - Client</li>
<li>Docker 服务器 - Docker daemon</li>
<li>Docker 镜像 - Image</li>
<li>Registry</li>
<li>Docker 容器 - Container:Docker 容器就是 Docker 镜像的运行实例。<br>本文主要介绍docker Registry及其后端存储</li>
</ul>
<h2 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h2><p><img src="https://z3.ax1x.com/2021/05/04/gmvOfA.jpg" alt=""></p>
<h2 id="docker-registry简介"><a href="#docker-registry简介" class="headerlink" title="docker registry简介"></a>docker registry简介</h2><p>docker registry 用于存储和分发docker镜像（images）。<br>当前主要使用Docker Registry 2.0，又叫Distribution，其github库为：<a href="https://github.com/docker/distribution">https://github.com/docker/distribution</a><br>原先的1.0版本使用python实现，已经停止更新和维护<br>目前的2.0版本使用GO语言实现，新版实现有如下特性：</p>
<ul>
<li>push 和 pull更快</li>
<li>实现效率更高</li>
<li>简化部署</li>
<li>可插拔的存储后端</li>
<li>webhook 通知</li>
</ul>
<h3 id="为什么需要私有的registry"><a href="#为什么需要私有的registry" class="headerlink" title="为什么需要私有的registry"></a>为什么需要私有的registry</h3><p>Registry 是存放 Docker 镜像的仓库，Registry 分私有和公有两种。<br>Docker Hub（<a href="https://hub.docker.com/）">https://hub.docker.com/）</a> 是默认的 Registry，由 Docker 公司维护，上面有数以万计的镜像，用户可以自由下载和使用。<br>出于对速度或安全的考虑，用户也可以创建自己的私有 Registry。  </p>
<p>通常，使用docker拉取镜像是从docker的公共仓库（Docker Hub）中，安装docker之后就可以实现这点。用户如果有Docker Hub的账号，也可以push 镜像到Docker Hub.</p>
<p>对于有的用户或者企业，使用Docker Hub就够用了，但对另一部分则不够用，比如用户想为自己的软件产品维护一个私有的registry。此外，用户可能想部署自己的镜像仓库用于持续集成和测试。对于这类用户，部署自己的私有的registry实例是更好的选择。</p>
<h2 id="docker-registry-存储"><a href="#docker-registry-存储" class="headerlink" title="docker registry 存储"></a>docker registry 存储</h2><p>前面提到docker registry新版特性有可插拔的存储后端，也就是Docker 镜像仓库后端支持多种储存类型，如文件系统，s3-aws，azure，oss，swift等，主要分为两大类</p>
<ul>
<li>本地储存</li>
<li>远程储存</li>
</ul>
<blockquote>
<p>Registry 做的事情大致可分为：  </p>
<ol>
<li>加载读配置  </li>
<li>注册handler  </li>
<li>监听  </li>
</ol>
</blockquote>
<p>本质上 Registry 是个 HTTP 服务，启动后，监听在配置文件设定的某端口上。当 http 请求过来后，便会触发之前注册过的 handler。<br>Handler 包含 manifest、tag、blob、blob-upload、blob-upload-chunk、catalog 等六类，具体请可参考 registry 源码：/registry/handlers/app.go。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">app.register(v2.RouteNameManifest, manifestDispatcher)</span><br><span class="line">app.register(v2.RouteNameCatalog, catalogDispatcher)</span><br><span class="line">app.register(v2.RouteNameTags, tagsDispatcher)</span><br><span class="line">app.register(v2.RouteNameBlob, blobDispatcher)</span><br><span class="line">app.register(v2.RouteNameBlobUpload, blobUploadDispatcher)</span><br><span class="line">app.register(v2.RouteNameBlobUploadChunk, blobUploadDispatcher)</span><br></pre></td></tr></table></figure><br>配置文件包含监听端口、auth 地址、存储驱动信息、回调通知等。</p>
<p>Docker engine 与 registry （即：远程镜像仓库）的通信也有一套完整的 API，大致包含 pull、push 镜像所涉及的认证、授权、镜像存储等相关流程，具体请参考：<a href="https://github.com/docker/distribution/blob/master/docs/spec/api.md">Registry API</a>。目前常用 registry 版本为 v2，registry v2 拥有断点续传、并发拉取镜像多层等特点。能并发拉取多层是因为镜像的元信息与镜像层数据分开存储，当 pull 一个镜像时，先进行认证获取到 token 并授权通过，然后获取镜像的 manifest 文件，进行 signature 校验。校验完成后，依据 manifest 里的层信息并发拉取各层。其中 manifest 包含的信息有：仓库名称、tag、镜像层 digest 等， 更多，请参考：<a href="https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-1.md">manifest 格式文档</a>。</p>
<p>各层拉下来后，也会先在本地进行校验，校验算法采用 sha256。Push 过程则先将镜像各层并发推至 Registry，推送完成后，再将镜像的 manifest 推至 Registry。<br><strong>Registry 其实并不负责具体的存储工作，具体存储介质根据使用方来定，Registry 只是提供一套标准的存储驱动接口，具体存储驱动实现由使用方实现。</strong></p>
<p>目前官方 Registry 默认提供的存储驱动包括：微软 Azure、Google GCS、Amazon S3、Openstack Swift、本地存储等。若需要使用自己的对象存储服务，则需要自行实现 Registry 存储驱动。</p>
<p>当然还可以支持自定义的存储，只需要实现distribution/registry/storage/driver/storagedriver.go中如下接口即可：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StorageDriver <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// Name returns the human-readable &quot;name&quot; of the driver, useful in error</span></span><br><span class="line">   <span class="comment">// messages and logging. By convention, this will just be the registration</span></span><br><span class="line">   <span class="comment">// name, but drivers may provide other information here.</span></span><br><span class="line">   Name() <span class="type">string</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// GetContent retrieves the content stored at &quot;path&quot; as a []byte.</span></span><br><span class="line">   <span class="comment">// This should primarily be used for small objects.</span></span><br><span class="line">   GetContent(ctx context.Context, path <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// PutContent stores the []byte content at a location designated by &quot;path&quot;.</span></span><br><span class="line">   <span class="comment">// This should primarily be used for small objects.</span></span><br><span class="line">   PutContent(ctx context.Context, path <span class="type">string</span>, content []<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Reader retrieves an io.ReadCloser for the content stored at &quot;path&quot;</span></span><br><span class="line">   <span class="comment">// with a given byte offset.</span></span><br><span class="line">   <span class="comment">// May be used to resume reading a stream by providing a nonzero offset.</span></span><br><span class="line">   Reader(ctx context.Context, path <span class="type">string</span>, offset <span class="type">int64</span>) (io.ReadCloser, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Writer returns a FileWriter which will store the content written to it</span></span><br><span class="line">   <span class="comment">// at the location designated by &quot;path&quot; after the call to Commit.</span></span><br><span class="line">   Writer(ctx context.Context, path <span class="type">string</span>, <span class="built_in">append</span> <span class="type">bool</span>) (FileWriter, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stat retrieves the FileInfo for the given path, including the current</span></span><br><span class="line">   <span class="comment">// size in bytes and the creation time.</span></span><br><span class="line">   Stat(ctx context.Context, path <span class="type">string</span>) (FileInfo, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// List returns a list of the objects that are direct descendants of the</span></span><br><span class="line">   <span class="comment">//given path.</span></span><br><span class="line">   List(ctx context.Context, path <span class="type">string</span>) ([]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Move moves an object stored at sourcePath to destPath, removing the</span></span><br><span class="line">   <span class="comment">// original object.</span></span><br><span class="line">   <span class="comment">// Note: This may be no more efficient than a copy followed by a delete for</span></span><br><span class="line">   <span class="comment">// many implementations.</span></span><br><span class="line">   Move(ctx context.Context, sourcePath <span class="type">string</span>, destPath <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Delete recursively deletes all objects stored at &quot;path&quot; and its subpaths.</span></span><br><span class="line">   Delete(ctx context.Context, path <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// URLFor returns a URL which may be used to retrieve the content stored at</span></span><br><span class="line">   <span class="comment">// the given path, possibly using the given options.</span></span><br><span class="line">   <span class="comment">// May return an ErrUnsupportedMethod in certain StorageDriver</span></span><br><span class="line">   <span class="comment">// implementations.</span></span><br><span class="line">   URLFor(ctx context.Context, path <span class="type">string</span>, options <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;) (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Walk traverses a filesystem defined within driver, starting</span></span><br><span class="line">   <span class="comment">// from the given path, calling f on each file.</span></span><br><span class="line">   <span class="comment">// If the returned error from the WalkFn is ErrSkipDir and fileInfo refers</span></span><br><span class="line">   <span class="comment">// to a directory, the directory will not be entered and Walk</span></span><br><span class="line">   <span class="comment">// will continue the traversal.  If fileInfo refers to a normal file, processing stops</span></span><br><span class="line">   Walk(ctx context.Context, path <span class="type">string</span>, f WalkFn) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileWriter provides an abstraction for an opened writable file-like object in</span></span><br><span class="line"><span class="comment">// the storage backend. The FileWriter must flush all content written to it on</span></span><br><span class="line"><span class="comment">// the call to Close, but is only required to make its content readable on a</span></span><br><span class="line"><span class="comment">// call to Commit.</span></span><br><span class="line"><span class="keyword">type</span> FileWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   io.WriteCloser</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Size returns the number of bytes written to this FileWriter.</span></span><br><span class="line">   Size() <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Cancel removes any written content from this FileWriter.</span></span><br><span class="line">   Cancel() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Commit flushes all content written to this FileWriter and makes it</span></span><br><span class="line">   <span class="comment">// available for future calls to StorageDriver.GetContent and</span></span><br><span class="line">   <span class="comment">// StorageDriver.Reader.</span></span><br><span class="line">   Commit() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以参考如下文章进行实现<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-docker-registry/index.html">https://www.ibm.com/developerworks/cn/opensource/os-cn-docker-registry/index.html</a></p>
<h3 id="存储的文件结构"><a href="#存储的文件结构" class="headerlink" title="存储的文件结构"></a>存储的文件结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── docker</span><br><span class="line">    └── registry</span><br><span class="line">        └── v2</span><br><span class="line">            ├── blobs</span><br><span class="line">            │   └── sha256</span><br><span class="line">            │       ├── 07</span><br><span class="line">            │       │   └── 0766572b4bacfaee9a8eb6bae79e6f6dbcdfac0805c7c6ec8b6c2c0ef097317a</span><br><span class="line">            │       ├── 9a</span><br><span class="line">            │       │   └── 9a597e826a59709a4af34279f496c323d496a79e4c998ee5249a738e391192bb</span><br><span class="line">            │       └── 9c</span><br><span class="line">            │           └── 9ca846b27f6e92f0739af5bba5509357b52be0ce0dd02d216f4dccdacd695a8a</span><br><span class="line">            └── repositories</span><br><span class="line">                ├── alpine</span><br><span class="line">                │   ├── _layers</span><br><span class="line">                │   │   └── sha256</span><br><span class="line">                │   │       ├── 0766572b4bacfaee9a8eb6bae79e6f6dbcdfac0805c7c6ec8b6c2c0ef097317a</span><br><span class="line">                │   │       └── 9ca846b27f6e92f0739af5bba5509357b52be0ce0dd02d216f4dccdacd695a8a</span><br><span class="line">                │   ├── _manifests</span><br><span class="line">                │   │   ├── revisions</span><br><span class="line">                │   │   │   └── sha256</span><br><span class="line">                │   │   │       └── 9a597e826a59709a4af34279f496c323d496a79e4c998ee5249a738e391192bb</span><br><span class="line">                │   │   └── tags</span><br><span class="line">                │   │       └── 3.4</span><br><span class="line">                │   │           ├── current</span><br><span class="line">                │   │           └── index</span><br><span class="line">                │   │               └── sha256</span><br><span class="line">                │   │                   └── 9a597e826a59709a4af34279f496c323d496a79e4c998ee5249a738e391192bb</span><br><span class="line">                │   └── _uploads</span><br><span class="line">                └── library</span><br><span class="line">                    └── alpine</span><br><span class="line">                        ├── _layers</span><br><span class="line">                        │   └── sha256</span><br><span class="line">                        │       ├── 0766572b4bacfaee9a8eb6bae79e6f6dbcdfac0805c7c6ec8b6c2c0ef097317a</span><br><span class="line">                        │       └── 9ca846b27f6e92f0739af5bba5509357b52be0ce0dd02d216f4dccdacd695a8a</span><br><span class="line">                        ├── _manifests</span><br><span class="line">                        │   ├── revisions</span><br><span class="line">                        │   │   └── sha256</span><br><span class="line">                        │   │       └── 9a597e826a59709a4af34279f496c323d496a79e4c998ee5249a738e391192bb</span><br><span class="line">                        │   └── tags</span><br><span class="line">                        │       └── 3.4</span><br><span class="line">                        │           ├── current</span><br><span class="line">                        │           └── index</span><br><span class="line">                        │               └── sha256</span><br><span class="line">                        │                   └── 9a597e826a59709a4af34279f496c323d496a79e4c998ee5249a738e391192bb</span><br><span class="line">                        └── _uploads</span><br></pre></td></tr></table></figure>
<h3 id="代码流程："><a href="#代码流程：" class="headerlink" title="代码流程："></a>代码流程：</h3><p>代码前面流程都一样，注册handler之后，HTTP服务起来之后，来一个请求就走对应请求的handler。<br>流程示意图：<br><img src="https://z3.ax1x.com/2021/05/04/gmvzOf.jpg" alt=""></p>
<p>代码流程：/cmd/registry/main.go:registry.RootCmd.Execute()<br>–&gt;/registry/root.go:RootCmd.AddCommand(ServeCmd)注册命令–&gt;ServeCmd–&gt;/registry/registry.go:NewRegistry()<br>–&gt;/registry/registry.go:加载配置文件（默认在/etc/docker/registry/config.yml）–&gt;/registry/handler/app.go:NewApp()中注册handler–&gt;/registry/registry.go:registry.ListenAndServe()监听</p>
<p>注册命令：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	RootCmd.AddCommand(ServeCmd)</span><br><span class="line">	RootCmd.AddCommand(GCCmd)</span><br><span class="line">	GCCmd.Flags().BoolVarP(&amp;dryRun, <span class="string">&quot;dry-run&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;do everything except remove the blobs&quot;</span>)</span><br><span class="line">	GCCmd.Flags().BoolVarP(&amp;removeUntagged, <span class="string">&quot;delete-untagged&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;delete manifests that are not currently referenced via tag&quot;</span>)</span><br><span class="line">	RootCmd.Flags().BoolVarP(&amp;showVersion, <span class="string">&quot;version&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;show the version and exit&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RootCmd is the main command for the &#x27;registry&#x27; binary.</span></span><br><span class="line"><span class="keyword">var</span> RootCmd = &amp;cobra.Command&#123;</span><br><span class="line">   Use:   <span class="string">&quot;registry&quot;</span>,</span><br><span class="line">   Short: <span class="string">&quot;`registry`&quot;</span>,</span><br><span class="line">   Long:  <span class="string">&quot;`registry`&quot;</span>,</span><br><span class="line">   Run: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> showVersion &#123;</span><br><span class="line">         version.PrintVersion()</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      cmd.Usage()</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>ServeCmd中代码片段<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">      registry, err := NewRegistry(ctx, config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.HTTP.Debug.Prometheus.Enabled &#123;</span><br><span class="line">	path := config.HTTP.Debug.Prometheus.Path</span><br><span class="line">	<span class="keyword">if</span> path == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		path = <span class="string">&quot;/metrics&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Info(<span class="string">&quot;providing prometheus metrics on &quot;</span>, path)</span><br><span class="line">	http.Handle(path, metrics.Handler())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = registry.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalln(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用获取blob为例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;</span><br></pre></td></tr></table></figure><br>这个对应的就是调用其handler：blobDispatcher。<br>注册的地方为<br>/registry/handlers/app.go。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">app.register(v2.RouteNameManifest, manifestDispatcher)</span><br><span class="line">app.register(v2.RouteNameCatalog, catalogDispatcher)</span><br><span class="line">app.register(v2.RouteNameTags, tagsDispatcher)</span><br><span class="line">app.register(v2.RouteNameBlob, blobDispatcher)</span><br><span class="line">app.register(v2.RouteNameBlobUpload, blobUploadDispatcher)</span><br><span class="line">app.register(v2.RouteNameBlobUploadChunk, blobUploadDispatcher)</span><br></pre></td></tr></table></figure></p>
<p>获取blob流程(由于实验使用的s3作为存储后端，所以就看这条流程，其他存储后端看其他具体实现即可)：<br>/registry/handler/blob.go:blobDispatcher()–&gt;/registry/handler/blob.go:GetBlob()–&gt;/registry/storage/blobserver.go:ServeBlob()–&gt;/registry/storage/driver/s3-aws/s3.go:URLFor()–&gt;S3.GetObjectRequest(&amp;s3.GetObjectInput{<br>            Bucket: aws.String(d.Bucket),<br>            Key:    aws.String(d.s3Path(path)),<br>        })</p>
<p>代码片段：<br>/registry/handler/blob.go:blobDispatcher()<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blobDispatcher uses the request context to build a blobHandler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">blobDispatcher</span><span class="params">(ctx *Context, r *http.Request)</span></span> http.Handler &#123;</span><br><span class="line">	dgst, err := getDigest(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err == errDigestNotAvailable &#123;</span><br><span class="line">			<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">				ctx.Errors = <span class="built_in">append</span>(ctx.Errors, v2.ErrorCodeDigestInvalid.WithDetail(err))</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			ctx.Errors = <span class="built_in">append</span>(ctx.Errors, v2.ErrorCodeDigestInvalid.WithDetail(err))</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	blobHandler := &amp;blobHandler&#123;</span><br><span class="line">		Context: ctx,</span><br><span class="line">		Digest:  dgst,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mhandler := handlers.MethodHandler&#123;</span><br><span class="line">		<span class="string">&quot;GET&quot;</span>:  http.HandlerFunc(blobHandler.GetBlob),</span><br><span class="line">		<span class="string">&quot;HEAD&quot;</span>: http.HandlerFunc(blobHandler.GetBlob),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !ctx.readOnly &#123;</span><br><span class="line">		mhandler[<span class="string">&quot;DELETE&quot;</span>] = http.HandlerFunc(blobHandler.DeleteBlob)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mhandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>/registry/storage/driver/s3-aws/s3.go:URLFor()<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// URLFor returns a URL which may be used to retrieve the content stored at the given path.</span></span><br><span class="line"><span class="comment">// May return an UnsupportedMethodErr in certain StorageDriver implementations.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *driver)</span></span> URLFor(ctx context.Context, path <span class="type">string</span>, options <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	methodString := <span class="string">&quot;GET&quot;</span></span><br><span class="line">	method, ok := options[<span class="string">&quot;method&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		methodString, ok = method.(<span class="type">string</span>)</span><br><span class="line">		<span class="keyword">if</span> !ok || (methodString != <span class="string">&quot;GET&quot;</span> &amp;&amp; methodString != <span class="string">&quot;HEAD&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, storagedriver.ErrUnsupportedMethod&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	expiresIn := <span class="number">20</span> * time.Minute</span><br><span class="line">	expires, ok := options[<span class="string">&quot;expiry&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		et, ok := expires.(time.Time)</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			expiresIn = time.Until(et)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> req *request.Request</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> methodString &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">		req, _ = d.S3.GetObjectRequest(&amp;s3.GetObjectInput&#123;</span><br><span class="line">			Bucket: aws.String(d.Bucket),</span><br><span class="line">			Key:    aws.String(d.s3Path(path)),</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;HEAD&quot;</span>:</span><br><span class="line">		req, _ = d.S3.HeadObjectRequest(&amp;s3.HeadObjectInput&#123;</span><br><span class="line">			Bucket: aws.String(d.Bucket),</span><br><span class="line">			Key:    aws.String(d.s3Path(path)),</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> req.Presign(expiresIn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>通过文章<a href="https://supereagle.github.io/2018/04/24/docker-registry/">镜像仓库中镜像存储的原理解析</a>  发现结论：<br>同一镜像，在不同镜像仓库中，存储的方式和内容完全一样。<br>文章中通过实验得出如下结论：<br>通过 Registry API 获得的两个镜像仓库中相同镜像的 manifest 信息完全相同。<br>两个镜像仓库中相同镜像的 manifest 信息的存储路径和内容完全相同。<br>两个镜像仓库中相同镜像的 blob 信息的存储路径和内容完全相同。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://github.com/docker/distribution">docker registry官方github</a></p>
<p><a href="https://hui.lu/docker-registry-storage/">Docker Registry Storage</a>  </p>
<p><a href="https://supereagle.github.io/2018/04/24/docker-registry/">镜像仓库中镜像存储的原理解析</a>  </p>
<p><a href="https://blog.csdn.net/yuanfang_way/article/category/5904523">Distribution源码分析</a>  </p>
<p><a href="https://segmentfault.com/a/1190000014284289">Docker镜像的存储机制</a>  </p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-docker-registry/index.html">Docker registry 定制实例 – 集成您自己的镜像存储库</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>存储</tag>
        <tag>docker</tag>
        <tag>docker registry</tag>
      </tags>
  </entry>
  <entry>
    <title>harbor打离线包流程解析</title>
    <url>/2019/04/17/harbor%E6%89%93%E7%A6%BB%E7%BA%BF%E5%8C%85%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/04/gmv5y6.jpg" alt=""><br><span id="more"></span></p>
<p>本文主要解析harbor打离线包的流程，并在此基础上给出如果需要替换registry的操作方案。  </p>
<ul>
<li>harbor源码基于1.5.1版本 </li>
</ul>
<h2 id="为什么要分析harbor打离线包的流程"><a href="#为什么要分析harbor打离线包的流程" class="headerlink" title="为什么要分析harbor打离线包的流程"></a>为什么要分析harbor打离线包的流程</h2><p>在我们的项目过程会涉及到修改harbor源码的需求，然后修改源码之后自然需要出包部署；<br>通过文章<a href="https://www.a-programmer.top/2019/03/27/%E4%BB%8EHabor%E6%BA%90%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E5%8F%8A%E6%89%93%E5%8C%85/">从Habor源码进行安装及打包</a>可以得知修改harbor源码之后可以用如下命令出离线包（需要将下面命令里的版本替换自己实际的版本）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make package_offline GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0</span><br></pre></td></tr></table></figure><br>除此之外还可能会涉及到修改docker registry源码，通过前面的文章<a href="https://www.a-programmer.top/2019/03/26/Habor%E5%88%9D%E5%8D%B0%E8%B1%A1/">Habor初印象</a>可以知道harbor是依赖于docker registry的，所以要搞清楚修改docker registry之后如何将修改打包到harbor的离线包中。本文最后会基于流程分析，给出两个将registry修改打包到harbor的离线包中的方案。</p>
<h2 id="harbor打离线包的流程"><a href="#harbor打离线包的流程" class="headerlink" title="harbor打离线包的流程"></a>harbor打离线包的流程</h2><h3 id="harbor打离线包流程源码"><a href="#harbor打离线包流程源码" class="headerlink" title="harbor打离线包流程源码"></a>harbor打离线包流程源码</h3><p>在项目下github.com/docker/distribution有Makefile<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ll</span><br><span class="line">total 100</span><br><span class="line">-rw-r--r-- 1 root root  2016 May 22  2018 AUTHORS</span><br><span class="line">-rw-r--r-- 1 root root  3223 May 22  2018 CHANGELOG.md</span><br><span class="line">drwxr-xr-x 7 root root  4096 May 22  2018 contrib</span><br><span class="line">-rw-r--r-- 1 root root  4123 May 22  2018 CONTRIBUTING.md</span><br><span class="line">drwxr-xr-x 3 root root  4096 May 22  2018 docs</span><br><span class="line">-rw-r--r-- 1 root root 10771 May 22  2018 LICENSE</span><br><span class="line">drwxr-xr-x 7 root root  4096 Apr 17 16:01 make</span><br><span class="line">-rw-r--r-- 1 root root 19284 Mar 26 17:08 Makefile</span><br><span class="line">-rw-r--r-- 1 root root   482 May 22  2018 NOTICE</span><br><span class="line">-rw-r--r-- 1 root root   976 May 22  2018 partners.md</span><br><span class="line">-rw-r--r-- 1 root root  5206 May 22  2018 README.md</span><br><span class="line">-rw-r--r-- 1 root root  2214 May 22  2018 ROADMAP.md</span><br><span class="line">drwxr-xr-x 9 root root  4096 May 22  2018 src</span><br><span class="line">drwxr-xr-x 9 root root  4096 May 22  2018 tests</span><br><span class="line">drwxr-xr-x 6 root root  4096 May 22  2018 tools</span><br><span class="line">-rw-r--r-- 1 root root     3 Apr 15 17:50 UIVERSION</span><br><span class="line">-rw-r--r-- 1 root root     6 May 22  2018 VERSION</span><br></pre></td></tr></table></figure><br>出离线包的源码为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package_offline: compile version build modify_sourcefiles modify_composefile</span><br><span class="line">        @echo &quot;packing offline package ...&quot;</span><br><span class="line">        @cp -r make $(HARBORPKG)</span><br><span class="line">        @cp LICENSE $(HARBORPKG)/LICENSE</span><br><span class="line">        @cp NOTICE $(HARBORPKG)/NOTICE</span><br><span class="line">        @cp $(HARBORPKG)/photon/db/registry.sql $(HARBORPKG)/ha/</span><br><span class="line"></span><br><span class="line">        @if [ &quot;$(MIGRATORFLAG)&quot; = &quot;true&quot; ] ; then \</span><br><span class="line">                echo &quot;pulling Harbor migrator...&quot;; \</span><br><span class="line">                $(DOCKERPULL) vmware/harbor-migrator:$(MIGRATORVERSION); \</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        @echo &quot;saving harbor docker image&quot;</span><br><span class="line">        @$(DOCKERSAVE) $(DOCKERSAVE_PARA) &gt; $(HARBORPKG)/$(DOCKERIMGFILE).$(VERSIONTAG).tar</span><br><span class="line">        @gzip $(HARBORPKG)/$(DOCKERIMGFILE).$(VERSIONTAG).tar</span><br><span class="line"></span><br><span class="line">        @$(TARCMD) $(PACKAGE_OFFLINE_PARA)</span><br><span class="line">        @rm -rf $(HARBORPKG)</span><br><span class="line">        @echo &quot;Done.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>出离线包的命令如下（请将版本号修改为自己环境实际的版本号）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make package_offline GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0</span><br></pre></td></tr></table></figure></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>通过代码可以看到出离线包大致需要如下步骤：  </p>
<ol>
<li>compile  </li>
<li>version  </li>
<li>build  </li>
<li>modify_sourcefiles  </li>
<li>modify_composefile  </li>
<li>保存harbor docker镜像  </li>
<li>使用tar -zcvf命令进行打包  </li>
</ol>
<p>下面详细分析每一步：  </p>
<h4 id="compile-amp-amp-version"><a href="#compile-amp-amp-version" class="headerlink" title="compile &amp;&amp; version"></a>compile &amp;&amp; version</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile:check_environment compile_golangimage</span><br></pre></td></tr></table></figure>
<p>可以看到compile就做了检查环境check_environment和编译go镜像compile_golangimage两件事；<br><strong>check_environment</strong>:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check_environment:</span><br><span class="line">        @$(MAKEPATH)/$(CHECKENVCMD)</span><br></pre></td></tr></table></figure><br>其中<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BUILDPATH=$(CURDIR)</span><br><span class="line">MAKEPATH=$(BUILDPATH)/make</span><br><span class="line">CHECKENVCMD=checkenv.sh</span><br></pre></td></tr></table></figure><br>所以检查环境就是执行checkenv.sh脚本<br>脚本内容如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line"></span><br><span class="line">#docker version: 1.11.2</span><br><span class="line">#docker-compose version: 1.7.1</span><br><span class="line">#Harbor version: 0.4.5+</span><br><span class="line">set +e</span><br><span class="line">set -o noglob</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Set Colors</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">bold=$(tput bold)</span><br><span class="line">underline=$(tput sgr 0 1)</span><br><span class="line">reset=$(tput sgr0)</span><br><span class="line"></span><br><span class="line">red=$(tput setaf 1)</span><br><span class="line">green=$(tput setaf 76)</span><br><span class="line">white=$(tput setaf 7)</span><br><span class="line">tan=$(tput setaf 202)</span><br><span class="line">blue=$(tput setaf 25)</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Headers and Logging</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">underline() &#123; printf &quot;$&#123;underline&#125;$&#123;bold&#125;%s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line">h1() &#123; printf &quot;\n$&#123;underline&#125;$&#123;bold&#125;$&#123;blue&#125;%s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line">h2() &#123; printf &quot;\n$&#123;underline&#125;$&#123;bold&#125;$&#123;white&#125;%s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line">debug() &#123; printf &quot;$&#123;white&#125;%s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line">info() &#123; printf &quot;$&#123;white&#125;➜ %s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line">success() &#123; printf &quot;$&#123;green&#125;✔ %s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line">error() &#123; printf &quot;$&#123;red&#125;✖ %s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line">warn() &#123; printf &quot;$&#123;tan&#125;➜ %s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line">bold() &#123; printf &quot;$&#123;bold&#125;%s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">note() &#123; printf &quot;\n$&#123;underline&#125;$&#123;bold&#125;$&#123;blue&#125;Note:$&#123;reset&#125; $&#123;blue&#125;%s$&#123;reset&#125;\n&quot; &quot;$@&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">usage=$&#x27;Checking environment for harbor build and install. Include golang, docker and docker-compose.&#x27;</span><br><span class="line"></span><br><span class="line">while [ $# -gt 0 ]; do</span><br><span class="line">        case $1 in</span><br><span class="line">            --help)</span><br><span class="line">            note &quot;$usage&quot;</span><br><span class="line">            exit 0;;</span><br><span class="line">            *)</span><br><span class="line">            note &quot;$usage&quot;</span><br><span class="line">            exit 1;;</span><br><span class="line">        esac</span><br><span class="line">        shift || true</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">function check_golang &#123;</span><br><span class="line">        if ! go version &amp;&gt; /dev/null</span><br><span class="line">        then</span><br><span class="line">                warn &quot;No golang package in your enviroment. You should use golang docker image build binary.&quot;</span><br><span class="line">                return</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        # docker has been installed and check its version</span><br><span class="line">        if [[ $(go version) =~ (([0-9]+)\.([0-9]+)([\.0-9]*)) ]]</span><br><span class="line">        then</span><br><span class="line">                golang_version=$&#123;BASH_REMATCH[1]&#125;</span><br><span class="line">                golang_version_part1=$&#123;BASH_REMATCH[2]&#125;</span><br><span class="line">                golang_version_part2=$&#123;BASH_REMATCH[3]&#125;</span><br><span class="line"></span><br><span class="line">                # the version of golang does not meet the requirement</span><br><span class="line">                if [ &quot;$golang_version_part1&quot; -lt 1 ] || ([ &quot;$golang_version_part1&quot; -eq 1 ] &amp;&amp; [ &quot;$golang_version_part2&quot; -lt 6 ])</span><br><span class="line">                then</span><br><span class="line">                        warn &quot;Better to upgrade golang package to 1.6.0+ or use golang docker image build binary.&quot;</span><br><span class="line">                        return</span><br><span class="line">                else</span><br><span class="line">                        note &quot;golang version: $golang_version&quot;</span><br><span class="line">fi</span><br><span class="line">        else</span><br><span class="line">                warn &quot;Failed to parse golang version.&quot;</span><br><span class="line">                return</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function check_docker &#123;</span><br><span class="line">        if ! docker --version &amp;&gt; /dev/null</span><br><span class="line">        then</span><br><span class="line">                error &quot;Need to install docker(1.10.0+) first and run this script again.&quot;</span><br><span class="line">                exit 1</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        # docker has been installed and check its version</span><br><span class="line">        if [[ $(docker --version) =~ (([0-9]+)\.([0-9]+)([\.0-9]*)) ]]</span><br><span class="line">        then</span><br><span class="line">                docker_version=$&#123;BASH_REMATCH[1]&#125;</span><br><span class="line">                docker_version_part1=$&#123;BASH_REMATCH[2]&#125;</span><br><span class="line">                docker_version_part2=$&#123;BASH_REMATCH[3]&#125;</span><br><span class="line"></span><br><span class="line">                # the version of docker does not meet the requirement</span><br><span class="line">                if [ &quot;$docker_version_part1&quot; -lt 1 ] || ([ &quot;$docker_version_part1&quot; -eq 1 ] &amp;&amp; [ &quot;$docker_version_part2&quot; -lt 10 ])</span><br><span class="line">                then</span><br><span class="line">                        error &quot;Need to upgrade docker package to 1.10.0+.&quot;</span><br><span class="line">                        exit 1</span><br><span class="line">                else</span><br><span class="line">                        note &quot;docker version: $docker_version&quot;</span><br><span class="line">                fi</span><br><span class="line">        else</span><br><span class="line">                error &quot;Failed to parse docker version.&quot;</span><br><span class="line">                exit 1</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function check_dockercompose &#123;</span><br><span class="line">        if ! docker-compose --version &amp;&gt; /dev/null</span><br><span class="line">        then</span><br><span class="line">                error &quot;Need to install docker-compose(1.7.1+) by yourself first and run this script again.&quot;</span><br><span class="line">                exit 1</span><br><span class="line">        fi</span><br><span class="line"># docker-compose has been installed, check its version</span><br><span class="line">        if [[ $(docker-compose --version) =~ (([0-9]+)\.([0-9]+)([\.0-9]*)) ]]</span><br><span class="line">        then</span><br><span class="line">                docker_compose_version=$&#123;BASH_REMATCH[1]&#125;</span><br><span class="line">                docker_compose_version_part1=$&#123;BASH_REMATCH[2]&#125;</span><br><span class="line">                docker_compose_version_part2=$&#123;BASH_REMATCH[3]&#125;</span><br><span class="line"></span><br><span class="line">                # the version of docker-compose does not meet the requirement</span><br><span class="line">                if [ &quot;$docker_compose_version_part1&quot; -lt 1 ] || ([ &quot;$docker_compose_version_part1&quot; -eq 1 ] &amp;&amp; [ &quot;$docker_compose_version_part2&quot; -lt 6 ])</span><br><span class="line">                then</span><br><span class="line">                        error &quot;Need to upgrade docker-compose package to 1.7.1+.&quot;</span><br><span class="line">                        exit 1</span><br><span class="line">                else</span><br><span class="line">                        note &quot;docker-compose version: $docker_compose_version&quot;</span><br><span class="line">                fi</span><br><span class="line">        else</span><br><span class="line">                error &quot;Failed to parse docker-compose version.&quot;</span><br><span class="line">                exit 1</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_golang</span><br><span class="line">check_docker</span><br><span class="line">check_dockercompose</span><br></pre></td></tr></table></figure><br>可以看到检查环境主要是检查go环境、docker环境和docker-compose。<br>在笔者实验环境执行该脚本的结果如下：<br><img src="https://z3.ax1x.com/2021/05/04/gmvIOK.jpg" alt=""></p>
<p><strong>compile_golangimage</strong>：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compile_clarity:</span><br><span class="line">        @echo &quot;compiling binary for clarity ui...&quot;</span><br><span class="line">        @if [ &quot;$(HTTPPROXY)&quot; != &quot;&quot; ] ; then \</span><br><span class="line">                $(DOCKERCMD) run --rm -v $(BUILDPATH)/src:$(CLARITYSEEDPATH) $(CLARITYIMAGE) $(SHELL) $(CLARITYBUILDSCRIPT) -p $(HTTPPROXY); \</span><br><span class="line">        else \</span><br><span class="line">                $(DOCKERCMD) run --rm -v $(BUILDPATH)/src:$(CLARITYSEEDPATH) $(CLARITYIMAGE) $(SHELL) $(CLARITYBUILDSCRIPT); \</span><br><span class="line">        fi</span><br><span class="line">        @echo &quot;Done.&quot;</span><br><span class="line"></span><br><span class="line">compile_golangimage: compile_clarity</span><br><span class="line">        @echo &quot;compiling binary for adminserver (golang image)...&quot;</span><br><span class="line">        @echo $(GOBASEPATH)</span><br><span class="line">        @echo $(GOBUILDPATH)</span><br><span class="line">        @$(DOCKERCMD) run --rm -v $(BUILDPATH):$(GOBUILDPATH) -w $(GOBUILDPATH_ADMINSERVER) $(GOBUILDIMAGE) $(GOIMAGEBUILD) -o $(GOBUILDMAKEPATH_ADMINSERVER)/$(ADMINSERVERBINARYNAME)</span><br><span class="line">        @echo &quot;Done.&quot;</span><br><span class="line"></span><br><span class="line">        @echo &quot;compiling binary for ui (golang image)...&quot;</span><br><span class="line">        @echo $(GOBASEPATH)</span><br><span class="line">        @echo $(GOBUILDPATH)</span><br><span class="line">        @$(DOCKERCMD) run --rm -v $(BUILDPATH):$(GOBUILDPATH) -w $(GOBUILDPATH_UI) $(GOBUILDIMAGE) $(GOIMAGEBUILD) -o $(GOBUILDMAKEPATH_UI)/$(UIBINARYNAME)</span><br><span class="line">        @echo &quot;Done.&quot;</span><br><span class="line"></span><br><span class="line">        @echo &quot;compiling binary for jobservice (golang image)...&quot;</span><br><span class="line">        @$(DOCKERCMD) run --rm -v $(BUILDPATH):$(GOBUILDPATH) -w $(GOBUILDPATH_JOBSERVICE) $(GOBUILDIMAGE) $(GOIMAGEBUILD) -o $(GOBUILDMAKEPATH_JOBSERVICE)/$(JOBSERVICEBINARYNAME)</span><br><span class="line">        @echo &quot;Done.&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>version</strong>:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version:</span><br><span class="line">       @printf $(UIVERSIONTAG) &gt; $(VERSIONFILEPATH)/$(VERSIONFILENAME);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIVERSIONTAG=dev</span><br><span class="line">VERSIONFILEPATH=$(CURDIR)</span><br><span class="line">VERSIONFILENAME=UIVERSION</span><br></pre></td></tr></table></figure>
<p>version就是将版本（这里就是将“dev”，也就是默认是dev，可以自行修改定义）重定向输入到了当前路径的UIVERSION文件中</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>build对应源码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">build:</span><br><span class="line">        make -f $(MAKEFILEPATH_PHOTON)/Makefile build -e DEVFLAG=$(DEVFLAG) -e MARIADBVERSION=$(MARIADBVERSION) \</span><br><span class="line">         -e REGISTRYVERSION=$(REGISTRYVERSION) -e NGINXVERSION=$(NGINXVERSION) -e NOTARYVERSION=$(NOTARYVERSION) \</span><br><span class="line">         -e CLAIRVERSION=$(CLAIRVERSION) -e CLAIRDBVERSION=$(CLAIRDBVERSION) -e VERSIONTAG=$(VERSIONTAG) \</span><br><span class="line">         -e BUILDBIN=$(BUILDBIN) -e REDISVERSION=$(REDISVERSION)</span><br></pre></td></tr></table></figure><br>可以看到build就是调用$(MAKEPATH)/photon目录中的Makefile<br>参数分别为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAKEFILEPATH_PHOTON=$(MAKEPATH)/photon</span><br><span class="line">DEVFLAG=true</span><br><span class="line">MARIADBVERSION=$(VERSIONTAG) #这个前面就已经看到了也是dev</span><br><span class="line">REGISTRYVERSION=v2.6.2</span><br><span class="line">NGINXVERSION=$(VERSIONTAG) #---dev</span><br><span class="line">NOTARYVERSION=v0.5.1</span><br><span class="line">CLAIRVERSION=v2.0.1</span><br><span class="line">CLAIRDBVERSION=$(VERSIONTAG)  #---dev</span><br><span class="line">BUILDBIN=false</span><br><span class="line">REDISVERSION=$(VERSIONTAG)  #---dev</span><br></pre></td></tr></table></figure></p>
<p>查看$(MAKEPATH)/photon中Makefile:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">build: _build_postgresql _build_db _build_adminiserver _build_ui _build_jobservice _build_log _build_nginx _build_registry _build_notary _build_clair _build_redis</span><br></pre></td></tr></table></figure><br>可以看到build阶段，各种依赖的组件都在这build，如果关注那个组件的build就看对应的标记，这里笔者关注 _build_registr，便以 _build_registr为例。<br> _build_registry：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_build_registry:</span><br><span class="line">       @if [ &quot;$(BUILDBIN)&quot; != &quot;true&quot; ] ; then \</span><br><span class="line">               rm -rf $(DOCKERFILEPATH_REG)/binary &amp;&amp; mkdir -p $(DOCKERFILEPATH_REG)/binary &amp;&amp; \</span><br><span class="line">               $(call _get_binary, https://storage.googleapis.com/harbor-builds/bin/registry, $(DOCKERFILEPATH_REG)/binary/registry); \</span><br><span class="line">       else \</span><br><span class="line">               cd $(DOCKERFILEPATH_REG) &amp;&amp; $(DOCKERFILEPATH_REG)/builder $(REGISTRYVERSION); \</span><br><span class="line">       fi</span><br><span class="line">       @echo &quot;building registry container for photon...&quot;</span><br><span class="line">       @cd $(DOCKERFILEPATH_REG) &amp;&amp; chmod 655 $(DOCKERFILEPATH_REG)/binary/registry &amp;&amp; $(DOCKERBUILD) -f $(DOCKERFILEPATH_REG)/$(DOCKERFILENAME_REG) -t $(DOCKERIMAGENAME_REG):$(REGISTRYVERSION)-$(VERSIONTAG) .</span><br><span class="line">       @rm -rf $(DOCKERFILEPATH_REG)/binary</span><br><span class="line">       @echo &quot;Done.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br> 其中BUILDBIN字段在最外层的Makefile中定义<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BUILDBIN=false</span><br></pre></td></tr></table></figure><br> 也就是是否需要编译二进制，如果不编译，那么就会去<a href="https://storage.googleapis.com/harbor-builds/bin/registry">https://storage.googleapis.com/harbor-builds/bin/registry</a>下载，如果需要编译二进制就git clone源码进行编译。<br> 其他build流程诸如_build_postgresql _build_db _build_adminiserver _build_ui，如果有需要可以进一步细看，本文就不一一列出。</p>
<h4 id="modify-sourcefiles-amp-amp-modify-composefile"><a href="#modify-sourcefiles-amp-amp-modify-composefile" class="headerlink" title="modify_sourcefiles &amp;&amp; modify_composefile"></a>modify_sourcefiles &amp;&amp; modify_composefile</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modify_sourcefiles:</span><br><span class="line">        @echo &quot;change mode of source files.&quot;</span><br><span class="line">        @chmod 600 $(MAKEPATH)/common/templates/notary/notary-signer.key</span><br><span class="line">        @chmod 600 $(MAKEPATH)/common/templates/notary/notary-signer.crt</span><br><span class="line">        @chmod 600 $(MAKEPATH)/common/templates/notary/notary-signer-ca.crt</span><br><span class="line">        @chmod 600 $(MAKEPATH)/common/templates/ui/private_key.pem</span><br><span class="line">        @chmod 600 $(MAKEPATH)/common/templates/registry/root.crt</span><br></pre></td></tr></table></figure>
<p>可以看到modify_sourcefiles主要就是修改notary-signer.key、notary-signer.crt等文件的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modify_composefile: modify_composefile_notary modify_composefile_clair</span><br><span class="line">        @echo &quot;preparing docker-compose file...&quot;</span><br><span class="line">        @cp $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSETPLFILENAME) $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line">        @cp $(DOCKERCOMPOSEFILEPATH)/ha/$(DOCKERCOMPOSETPLFILENAME) $(DOCKERCOMPOSEFILEPATH)/ha/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__version__/$(VERSIONTAG)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/ha/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__version__/$(VERSIONTAG)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__reg_version__/$(REGISTRYVERSION)-$(VERSIONTAG)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__reg_version__/$(REGISTRYVERSION)-$(VERSIONTAG)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/ha/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__nginx_version__/$(NGINXVERSION)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__nginx_version__/$(NGINXVERSION)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/ha/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__redis_version__/$(REDISVERSION)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSEFILENAME)</span><br><span class="line"></span><br><span class="line">modify_composefile_notary:</span><br><span class="line">        @echo &quot;preparing docker-compose notary file...&quot;</span><br><span class="line">        @cp $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSENOTARYTPLFILENAME) $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSENOTARYFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__notary_version__/$(NOTARYVERSION)-$(VERSIONTAG)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSENOTARYFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__mariadb_version__/$(MARIADBVERSION)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSENOTARYFILENAME)</span><br><span class="line"></span><br><span class="line">modify_composefile_clair:</span><br><span class="line">        @echo &quot;preparing docker-compose clair file...&quot;</span><br><span class="line">        @cp $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSECLAIRTPLFILENAME) $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSECLAIRFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__postgresql_version__/$(CLAIRDBVERSION)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSECLAIRFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__clair_version__/$(CLAIRVERSION)-$(VERSIONTAG)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/$(DOCKERCOMPOSECLAIRFILENAME)</span><br><span class="line">        @cp $(DOCKERCOMPOSEFILEPATH)/ha/$(DOCKERCOMPOSECLAIRTPLFILENAME) $(DOCKERCOMPOSEFILEPATH)/ha/$(DOCKERCOMPOSECLAIRFILENAME)</span><br><span class="line">        @$(SEDCMD) -i &#x27;s/__clair_version__/$(CLAIRVERSION)-$(VERSIONTAG)/g&#x27; $(DOCKERCOMPOSEFILEPATH)/ha/$(DOCKERCOMPOSECLAIRFILENAME)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到modify_composefile主要是将各文件中的版本__xxx_version替换为设置的版本。</p>
<h4 id="保存harbor-docker镜像-amp-amp-打包"><a href="#保存harbor-docker镜像-amp-amp-打包" class="headerlink" title="保存harbor docker镜像 &amp;&amp; 打包"></a>保存harbor docker镜像 &amp;&amp; 打包</h4><p>保存harbor docker镜像 &amp;&amp; 打包其实很简单，直接看代码即可：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo &quot;saving harbor docker image&quot;</span><br><span class="line">        @$(DOCKERSAVE) $(DOCKERSAVE_PARA) &gt; $(HARBORPKG)/$(DOCKERIMGFILE).$(VERSIONTAG).tar</span><br><span class="line">        @gzip $(HARBORPKG)/$(DOCKERIMGFILE).$(VERSIONTAG).tar</span><br><span class="line"></span><br><span class="line">        @$(TARCMD) $(PACKAGE_OFFLINE_PARA)</span><br><span class="line">        @rm -rf $(HARBORPKG)</span><br><span class="line">        @echo &quot;Done.</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOCKERSAVE_PARA=$(DOCKERIMAGENAME_ADMINSERVER):$(VERSIONTAG) \</span><br><span class="line">                $(DOCKERIMAGENAME_UI):$(VERSIONTAG) \</span><br><span class="line">                $(DOCKERIMAGENAME_LOG):$(VERSIONTAG) \</span><br><span class="line">                $(DOCKERIMAGENAME_DB):$(VERSIONTAG) \</span><br><span class="line">                $(DOCKERIMAGENAME_JOBSERVICE):$(VERSIONTAG) \</span><br><span class="line">                vmware/redis-photon:$(REDISVERSION) \</span><br><span class="line">                vmware/nginx-photon:$(NGINXVERSION) vmware/registry-photon:$(REGISTRYVERSION)-$(VERSIONTAG) \</span><br><span class="line">                vmware/photon:$(PHOTONVERSION)</span><br><span class="line">PACKAGE_OFFLINE_PARA=-zcvf harbor-offline-installer-$(PKGVERSIONTAG).tgz \</span><br><span class="line">                          $(HARBORPKG)/common/templates $(HARBORPKG)/$(DOCKERIMGFILE).$(VERSIONTAG).tar.gz \</span><br><span class="line">                                  $(HARBORPKG)/prepare $(HARBORPKG)/NOTICE \</span><br><span class="line">                                  $(HARBORPKG)/LICENSE $(HARBORPKG)/install.sh \</span><br><span class="line">                                  $(HARBORPKG)/harbor.cfg $(HARBORPKG)/$(DOCKERCOMPOSEFILENAME) \</span><br><span class="line">                                  $(HARBORPKG)/ha</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>打包就是使用tar -zcvf命令进行打包,当然需要把“$(HARBORPKG)/prepare $(HARBORPKG)/NOTICE \<br>                                  $(HARBORPKG)/LICENSE $(HARBORPKG)/install.sh \<br>                                  $(HARBORPKG)/harbor.cfg $(HARBORPKG)/$(DOCKERCOMPOSEFILENAME) \<br>                                  $(HARBORPKG)/ha<br>”等包含进去。</p>
<h2 id="修改docker-registry后如何打离线包"><a href="#修改docker-registry后如何打离线包" class="headerlink" title="修改docker registry后如何打离线包"></a>修改docker registry后如何打离线包</h2><p>看这段代码（这段代码分析可参考上面build小节）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_build_registry:</span><br><span class="line">       @if [ &quot;$(BUILDBIN)&quot; != &quot;true&quot; ] ; then \</span><br><span class="line">               rm -rf $(DOCKERFILEPATH_REG)/binary &amp;&amp; mkdir -p $(DOCKERFILEPATH_REG)/binary &amp;&amp; \</span><br><span class="line">               $(call _get_binary, https://storage.googleapis.com/harbor-builds/bin/registry, $(DOCKERFILEPATH_REG)/binary/registry); \</span><br><span class="line">       else \</span><br><span class="line">               cd $(DOCKERFILEPATH_REG) &amp;&amp; $(DOCKERFILEPATH_REG)/builder $(REGISTRYVERSION); \</span><br></pre></td></tr></table></figure><br>很容易想到两种方案：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>将修改后docker registry编译出对应的二进制文件registry，编译方法如下(可参考文章<a href="https://blog.csdn.net/u010931295/article/details/84862407">Docker Registry-源码安装</a>)：<br>到项目路径下执行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make PREFIX=/go clean binaries</span><br></pre></td></tr></table></figure><br>然后把二进制放到固定位置registry_bin_path,然后修改脚本；<br>可以把这<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf $(DOCKERFILEPATH_REG)/binary &amp;&amp; mkdir -p $(DOCKERFILEPATH_REG)/binary &amp;&amp; \</span><br><span class="line">                $(call _get_binary, https://storage.googleapis.com/harbor-builds/bin/registry, $(DOCKERFILEPATH_REG)/binary/registry); </span><br></pre></td></tr></table></figure><br>修改为<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf $(DOCKERFILEPATH_REG)/binary &amp;&amp; mkdir -p $(DOCKERFILEPATH_REG)/binary &amp;&amp; \</span><br><span class="line">                cp $(registry_bin_path) $(DOCKERFILEPATH_REG)/binary/registry</span><br></pre></td></tr></table></figure><br>只要达到使用本地编译出来的二进制文件即可</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>自己到github建立一个自己的存放修改后的docker registry代码的项目，然后把脚本中<br>harbor-1.5.1/make/photon/registry/builder中项目地址改为自己的docker registry代码的项目地址即可。<br>即把<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># the temp folder to store distribution source code...</span><br><span class="line">TEMP=`mktemp -d /$TMPDIR/distribution.XXXXXX`</span><br><span class="line">git clone -b $VERSION https://github.com/docker/distribution.git $TEMP</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>改为<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># the temp folder to store distribution source code...</span><br><span class="line">TEMP=`mktemp -d /$TMPDIR/distribution.XXXXXX`</span><br><span class="line">git clone -b $VERSION $(你自己的docker registry github项目地址) $TEMP</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>修改完之后重新出包部署即可 : )</p>
<h2 id="构建带安全扫描工具的harbor离线包"><a href="#构建带安全扫描工具的harbor离线包" class="headerlink" title="构建带安全扫描工具的harbor离线包"></a>构建带安全扫描工具的harbor离线包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make package_offline GOBUILDIMAGE=golang:1.9.2 COMPILETAG=compile_golangimage CLARITYIMAGE=vmware/harbor-clarity-ui-builder:1.3.0 CLAIRFLAG=true</span><br></pre></td></tr></table></figure>
<p>此时安装时需要带参数了：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./install.sh --with-clair</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://github.com/goharbor/harbor">harbor 官方github</a>  </p>
<p><a href="https://github.com/docker/distribution">docker registry官方github</a>  </p>
<p><a href="https://www.a-programmer.top/2019/03/26/Habor%E5%88%9D%E5%8D%B0%E8%B1%A1/">Habor初印象</a>  </p>
<p><a href="https://www.a-programmer.top/2019/03/27/%E4%BB%8EHabor%E6%BA%90%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E5%8F%8A%E6%89%93%E5%8C%85/">从Habor源码进行安装及打包</a></p>
<p><a href="https://blog.csdn.net/u010931295/article/details/84862407">Docker Registry-源码安装</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>docker registry</tag>
        <tag>harbor</tag>
        <tag>harbor离线包</tag>
      </tags>
  </entry>
  <entry>
    <title>由LeetCode一题窥探GO程序的性能测试及性能优化</title>
    <url>/2019/03/21/%E7%94%B1LeetCode%E4%B8%80%E9%A2%98%E7%AA%A5%E6%8E%A2GO%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><img src="http://s3.51cto.com/oss/201710/24/0e74679601d45a92e0a5b55934cfd47b.jpeg-wh_651x-s_2760864022.jpeg" alt=""><br><span id="more"></span><br>本文将通过一道LeetCode的题目介绍GO语言程序的性能测试及性能优化方法。<br>题目是<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></p>
<h3 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>本题有多种解法：题解请参考:<br><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/">无重复字符的最长子串题解</a><br>本文实现参考第三种解法</p>
<h3 id="GO程序性能测试"><a href="#GO程序性能测试" class="headerlink" title="GO程序性能测试"></a>GO程序性能测试</h3><p>假设go程序实现如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// longestNotRpeatedSubstring project main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestNotRpeatedSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	lastOccurred := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	maxLength := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="type">byte</span>(s) &#123;</span><br><span class="line">		<span class="comment">//lastI, ok := lastOccurred[ch]</span></span><br><span class="line">		lastI := lastOccurred[ch]</span><br><span class="line">		<span class="keyword">if</span> lastI &gt;= start &#123;</span><br><span class="line">			start = lastI + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">			maxLength = i - start + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastOccurred[ch] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;abcadefg&quot;</span>))</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;abcabcbb&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意上面的程序不支持中文字符，其实可以稍微修改让程序支持中文字符，比如使用rune类型，这是GO语言为了用于支持各种语言而设定的类型。<br>golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节</p>
<ul>
<li>byte 等同于int8，常用来处理ascii字符</li>
<li>rune 等同于int32,常用来处理unicode或utf-8字符  </li>
</ul>
<p>通用版解法：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestNotRpeatedSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	lastOccurred := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	maxLength := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="type">rune</span>(s) &#123;</span><br><span class="line">		lastI, ok := lastOccurred[ch]</span><br><span class="line">		<span class="keyword">if</span> ok &amp;&amp; lastI &gt;= start &#123;</span><br><span class="line">			start = lastI + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">			maxLength = i - start + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastOccurred[ch] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;abcadefg&quot;</span>))</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;abcabcbb&quot;</span>))</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;黑化肥发灰挥发会花飞灰化肥挥发发黑会飞花&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>GO语言由于提供了一系列测试相关的工具，所以其性能测试做起来相对其他语言而言来说是相当的方便。<br>另外命名一个文件：比如longestNotRpeatedSubstring_test.go<br><strong>注意必须要以xxxx_test.go的方式命名</strong><br>longestNotRpeatedSubstring_test.go内容如下<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSubstring</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	s, ans := <span class="string">&quot;灰化肥挥发发黑会飞花&quot;</span>, <span class="number">9</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line">		s = s + s</span><br><span class="line">	&#125;</span><br><span class="line">	b.Logf(<span class="string">&quot;len(s) = %d&quot;</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		actual := longestNotRpeatedSubstring(s)</span><br><span class="line">		<span class="keyword">if</span> actual != ans &#123;</span><br><span class="line">			b.Errorf(<span class="string">&quot;got %d for input %s; &quot;</span>+</span><br><span class="line">				<span class="string">&quot;expected %d&quot;</span>, actual, s, ans)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>做性能测试命令如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test -bench .</span><br><span class="line">go test -bench . -cpuprofile cpu.out</span><br><span class="line">go tool pprof cpu.out</span><br></pre></td></tr></table></figure><br>执行效果如下图：<br><img src="http://wx2.sinaimg.cn/mw690/71c65545ly1g1aevh6j5qj20jh0dv0t7.jpg" alt=""><br>go test -bench . -cpuprofile cpu.out生成的cpu.out文件是二进制文件，需要借助go的pprof工具进行查看，然后使用go tool pprof cpu.out命令进入到交互式命令行，可以敲入help进行查看，执行效果如下图：<br><img src="http://wx3.sinaimg.cn/mw690/71c65545ly1g1aevhqr4dj20j70ewq3j.jpg" alt=""></p>
<p>这里使用简单的办法：直接敲入web，也就是通过web server查看可视化的图<br>网页中显示效果如下：<br><img src="http://wx4.sinaimg.cn/mw690/71c65545ly1g1aez6u4b0j20r90ntmyd.jpg" alt=""></p>
<p><strong>注意：这里需要安装graphviz工具，可以到官网下载安装，Windows安装之后记得把软件的bin目录添加到环境变量中去，然后重新打开命令窗口即可</strong><br>具体步骤可参考：<br><img src="https://img-blog.csdn.net/20160628204148230" alt=""></p>
<h3 id="GO程序性能优化"><a href="#GO程序性能优化" class="headerlink" title="GO程序性能优化"></a>GO程序性能优化</h3><p><img src="http://wx3.sinaimg.cn/mw690/71c65545ly1g1afusfykej20kh0gkq3l.jpg" alt=""><br>通过上面的步骤，可以看到上面给出解法，主要耗时在map的访问<br>那我们可以想办法把这块时间优化掉，通常这采用的办法是：<strong>用空间换时间</strong><br>我们可以选择不用map，那么可以将程序改成：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestNotRpeatedSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	lastOccurred := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0xffff</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> lastOccurred &#123;</span><br><span class="line">		lastOccurred[i] = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	maxLength := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="type">rune</span>(s) &#123;</span><br><span class="line">		lastI := lastOccurred[ch]</span><br><span class="line">		<span class="keyword">if</span> lastI &gt;= start &#123;</span><br><span class="line">			start = lastI + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">			maxLength = i - start + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastOccurred[ch] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;abcadefg&quot;</span>))</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;abcabcbb&quot;</span>))</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;黑化肥发灰挥发会花飞灰化肥挥发发黑会飞花&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再次执行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test -bench . -cpuprofile cpu.out</span><br><span class="line">go tool pprof cpu.out</span><br></pre></td></tr></table></figure><br><img src="http://wx2.sinaimg.cn/mw690/71c65545ly1g1ag9vepk5j20ib0903yp.jpg" alt=""><br>可以看到优化后的代码每次操作，也就是每次调用我们的函数耗时已经降为4.92ms，原来的时间是9.19ms（可以看上面的截图）可以得知此次优化还是非常好的，我们还可以使用web通过web server查看耗时情况：<br><img src="http://wx3.sinaimg.cn/mw690/71c65545ly1g1agfzg1dtj20mq0n7t99.jpg" alt=""></p>
<p>通过上面优化的示例，我们就可以看到优化的过程如下<br><img src="http://wx3.sinaimg.cn/mw690/71c65545ly1g1agtbsrkpj20h409cmyv.jpg" alt=""> </p>
<p>当然上面的程序还可以做一点优化，那就是把slice移到外面去，不用每次都去重新分配一个slice<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lastOccurred = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0xffff</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestNotRpeatedSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> lastOccurred &#123;</span><br><span class="line">		lastOccurred[i] = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	maxLength := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="type">rune</span>(s) &#123;</span><br><span class="line">		lastI := lastOccurred[ch]</span><br><span class="line">		<span class="keyword">if</span> lastI &gt;= start &#123;</span><br><span class="line">			start = lastI + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i-start+<span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">			maxLength = i - start + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastOccurred[ch] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;abcadefg&quot;</span>))</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;abcabcbb&quot;</span>))</span><br><span class="line">	fmt.Println(longestNotRpeatedSubstring(<span class="string">&quot;黑化肥发灰挥发会花飞灰化肥挥发发黑会飞花&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="GO程序普通测试的方法"><a href="#GO程序普通测试的方法" class="headerlink" title="GO程序普通测试的方法"></a>GO程序普通测试的方法</h3><p>编写测试用例，GO语言中主要采用表格测试的方法，将测试数据，与真正的测试逻辑分开</p>
<p>如果需要做普通的测试也可以在上述性能测试文件longestNotRpeatedSubstring_test.go里面添加如下函数：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSubstr</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		s   <span class="type">string</span></span><br><span class="line">		ans <span class="type">int</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="string">&quot;abcacbcc&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;pwwkew&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line"></span><br><span class="line">		&#123;<span class="string">&quot;&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;b&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;abcabcabcd&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;灰化肥挥发发黑会飞花&quot;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		actual := longestNotRpeatedSubstring(tt.s)</span><br><span class="line">		<span class="keyword">if</span> actual != tt.ans &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;got %d for input %s; expected %d&quot;</span>,</span><br><span class="line">				actual, tt.s, tt.ans)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试主要使用如下命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test .</span><br></pre></td></tr></table></figure><br>此外使用GO自带的工具还可以查看代码覆盖率，非常方便：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go test -coverprofile=c.out</span><br><span class="line">go tool cover -html=c.out</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="http://wx3.sinaimg.cn/mw690/71c65545ly1g1agzv7ii2j20tw0itaad.jpg" alt=""></p>
<h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><p>下面补充本题的C语言实现，仅供参考<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkExist</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">char</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> repeatPosition = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *p = s;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        repeatPosition = checkExist(s, start, cur, *p);</span><br><span class="line">        <span class="keyword">if</span>(repeatPosition &gt;= start)</span><br><span class="line">        &#123;</span><br><span class="line">            start = repeatPosition + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur - start + <span class="number">1</span> &gt; maxlen)</span><br><span class="line">        &#123;</span><br><span class="line">            maxlen = cur - start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p++;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a><br><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/">无重复字符的最长子串题解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>性能测试</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>编译docker源码并由二进制启动docker</title>
    <url>/2019/04/24/%E7%BC%96%E8%AF%91docker%E6%BA%90%E7%A0%81%E5%B9%B6%E7%94%B1%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%90%AF%E5%8A%A8docker/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/04/gmvdWn.jpg" alt=""></p>
<span id="more"></span>
<p>本文主要记录如何由docker源码编译出docker二进制，并由二进制启动docker。<br>由于项目使用的docker版本为17.03.2-ce，所以本文就以此版本为例。</p>
<h2 id="编译docker源码"><a href="#编译docker源码" class="headerlink" title="编译docker源码"></a>编译docker源码</h2><p>其实编译docker源码是一个比较复杂过程，但幸运的是docker官方提供了一个Makefile和Dockerfile，将编译docker的复杂的操作都封装起来了，使得我们手动编译的过程简单多了。解决一些源下载慢的问题后其实还挺简单方便的。</p>
<p>准备事项：</p>
<ul>
<li>硬件环境：编译docker的过程是挺耗费内存的，如果你使用虚拟机的话，建议至少分2GB的内存。我这里使用的OS是Centos，硬件是4核4GB的服务器。</li>
<li>因为docker是在容器里面去编译的，所以我们需要先安装docker</li>
<li><p>到<a href="https://github.com/moby/moby/releases">https://github.com/moby/moby/releases</a> 下载对应的17.03.2-ce版本源码</p>
</li>
<li><p>构建编译docker的环境。docker的编译是在容器中进行的，构建这个容器的命令很简单，在下载的docker源码目录执行make build即可。我们看Makefile文件可以发现，执行make build的时候其实值执行了如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build $&#123;BUILD_APT_MIRROR&#125; $&#123;DOCKER_BUILD_ARGS&#125; -t &quot;$(DOCKER_IMAGE)&quot; -f &quot;$(DOCKERFILE)&quot; .`</span><br></pre></td></tr></table></figure>
<p>Dockerfile就与Makefile文件处于同一个文件目录，其内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 # This file describes the standard way to build Docker, using docker</span><br><span class="line">  2 #</span><br><span class="line">  3 # Usage:</span><br><span class="line">  4 #</span><br><span class="line">  5 # # Assemble the full dev environment. This is slow the first time.</span><br><span class="line">  6 # docker build -t docker .</span><br><span class="line">  7 #</span><br><span class="line">  8 # # Mount your source in an interactive container for quick testing:</span><br><span class="line">  9 # docker run -v `pwd`:/go/src/github.com/docker/docker --privileged -i -t docker bash</span><br><span class="line"> 10 #</span><br><span class="line"> 11 # # Run the test suite:</span><br><span class="line"> 12 # docker run --privileged docker hack/make.sh test-unit test-integration-cli test-docker-py</span><br><span class="line"> 13 #</span><br><span class="line"> 14 # # Publish a release:</span><br><span class="line"> 15 # docker run --privileged \</span><br><span class="line"> 16 #  -e AWS_S3_BUCKET=baz \</span><br><span class="line"> 17 #  -e AWS_ACCESS_KEY=foo \</span><br><span class="line"> 18 #  -e AWS_SECRET_KEY=bar \</span><br><span class="line"> 19 #  -e GPG_PASSPHRASE=gloubiboulga \</span><br><span class="line"> 20 #  docker hack/release.sh</span><br><span class="line"> 21 #</span><br><span class="line"> 22 # Note: AppArmor used to mess with privileged mode, but this is no longer</span><br><span class="line"> 23 # the case. Therefore, you don&#x27;t have to disable it anymore.</span><br><span class="line"> 24 #</span><br><span class="line"> 25</span><br><span class="line"> 26 FROM debian:jessie</span><br><span class="line"> 27</span><br><span class="line"> 28 # allow replacing httpredir or deb mirror</span><br><span class="line"> 29 ARG APT_MIRROR=deb.debian.org</span><br><span class="line"> 30 RUN sed -ri &quot;s/(httpredir|deb).debian.org/$APT_MIRROR/g&quot; /etc/apt/sources.list</span><br><span class="line"> 31</span><br><span class="line"> 32 # Add zfs ppa</span><br><span class="line"> 33 COPY keys/launchpad-ppa-zfs.asc /go/src/github.com/docker/docker/keys/</span><br><span class="line"> 34 RUN apt-key add /go/src/github.com/docker/docker/keys/launchpad-ppa-zfs.asc</span><br><span class="line"> 35 RUN echo deb http://ppa.launchpad.net/zfs-native/stable/ubuntu trusty main &gt; /etc/apt/sources.list.d/zfs.list</span><br><span class="line"> 36</span><br><span class="line"> 37 # Packaged dependencies</span><br><span class="line"> 38 RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line"> 39         apparmor \</span><br><span class="line"> 40         apt-utils \</span><br><span class="line"> 41         aufs-tools \</span><br><span class="line"> 42         automake \</span><br><span class="line"> 43         bash-completion \</span><br><span class="line"> 44         binutils-mingw-w64 \</span><br><span class="line"> 45         bsdmainutils \</span><br><span class="line"> 46         btrfs-tools \</span><br><span class="line"> 47         build-essential \</span><br><span class="line"> 48         clang \</span><br><span class="line"> 49         cmake \</span><br><span class="line"> 50         createrepo \</span><br><span class="line"> 51         curl \</span><br><span class="line"> 52         dpkg-sig \</span><br><span class="line"> 53         gcc-mingw-w64 \</span><br><span class="line"> 54         git \</span><br><span class="line"> 55         iptables \</span><br><span class="line"> 56         jq \</span><br><span class="line"> 57         libapparmor-dev \</span><br><span class="line"> 58         libcap-dev \</span><br><span class="line"> 59         libltdl-dev \</span><br><span class="line"> 60         libnl-3-dev \</span><br><span class="line"> 61         libprotobuf-c0-dev \</span><br><span class="line"> 62         libprotobuf-dev \</span><br><span class="line"> 63         libsqlite3-dev \</span><br><span class="line"> 64         libsystemd-journal-dev \</span><br><span class="line"> 65         libtool \</span><br><span class="line"> 66         mercurial \</span><br><span class="line"> 67         net-tools \</span><br><span class="line"> 68         pkg-config \</span><br><span class="line"> 69         protobuf-compiler \</span><br><span class="line"> 70         protobuf-c-compiler \</span><br><span class="line"> 71         python-dev \</span><br><span class="line"> 72         python-mock \</span><br><span class="line"> 73         python-pip \</span><br><span class="line"> 74         python-websocket \</span><br><span class="line"> 75         ubuntu-zfs \</span><br><span class="line"> 76         xfsprogs \</span><br><span class="line"> 77         vim-common \</span><br><span class="line"> 78         libzfs-dev \</span><br><span class="line"> 79         tar \</span><br><span class="line"> 80         zip \</span><br><span class="line"> 81         --no-install-recommends \</span><br><span class="line"> 82         &amp;&amp; pip install awscli==1.10.15</span><br><span class="line"> 83 # Get lvm2 source for compiling statically</span><br><span class="line"> 84 ENV LVM2_VERSION 2.02.103</span><br><span class="line"> 85 RUN mkdir -p /usr/local/lvm2 \</span><br><span class="line"> 86         &amp;&amp; curl -fsSL &quot;https://mirrors.kernel.org/sourceware/lvm2/LVM2.$&#123;LVM2_VERSION&#125;.tgz&quot; \</span><br><span class="line"> 87                 | tar -xzC /usr/local/lvm2 --strip-components=1</span><br><span class="line"> 88 # See https://git.fedorahosted.org/cgit/lvm2.git/refs/tags for release tags</span><br><span class="line"> 89</span><br><span class="line"> 90 # Compile and install lvm2</span><br><span class="line"> 91 RUN cd /usr/local/lvm2 \</span><br><span class="line"> 92         &amp;&amp; ./configure \</span><br><span class="line"> 93                 --build=&quot;$(gcc -print-multiarch)&quot; \</span><br><span class="line"> 94                 --enable-static_link \</span><br><span class="line"> 95         &amp;&amp; make device-mapper \</span><br><span class="line"> 96         &amp;&amp; make install_device-mapper</span><br><span class="line"> 97 # See https://git.fedorahosted.org/cgit/lvm2.git/tree/INSTALL</span><br><span class="line"> 98</span><br><span class="line"> 99 # Configure the container for OSX cross compilation</span><br><span class="line">100 ENV OSX_SDK MacOSX10.11.sdk</span><br><span class="line">101 ENV OSX_CROSS_COMMIT a9317c18a3a457ca0a657f08cc4d0d43c6cf8953</span><br><span class="line">102 RUN set -x \</span><br><span class="line">103         &amp;&amp; export OSXCROSS_PATH=&quot;/osxcross&quot; \</span><br><span class="line">104         &amp;&amp; git clone https://github.com/tpoechtrager/osxcross.git $OSXCROSS_PATH \</span><br><span class="line">105         &amp;&amp; ( cd $OSXCROSS_PATH &amp;&amp; git checkout -q $OSX_CROSS_COMMIT) \</span><br><span class="line">106         &amp;&amp; curl -sSL https://s3.dockerproject.org/darwin/v2/$&#123;OSX_SDK&#125;.tar.xz -o &quot;$&#123;OSXCROSS_PATH&#125;/tarballs/$&#123;OSX_SDK&#125;.tar.xz&quot; \</span><br><span class="line">107         &amp;&amp; UNATTENDED=yes OSX_VERSION_MIN=10.6 $&#123;OSXCROSS_PATH&#125;/build.sh</span><br><span class="line">108 ENV PATH /osxcross/target/bin:$PATH</span><br><span class="line">109</span><br><span class="line">110 # Install seccomp: the version shipped in trusty is too old</span><br><span class="line">111 ENV SECCOMP_VERSION 2.3.1</span><br><span class="line">112 RUN set -x \</span><br><span class="line">113         &amp;&amp; export SECCOMP_PATH=&quot;$(mktemp -d)&quot; \</span><br><span class="line">114         &amp;&amp; curl -fsSL &quot;https://github.com/seccomp/libseccomp/releases/download/v$&#123;SECCOMP_VERSION&#125;/libseccomp-$&#123;SECCOMP_VERSION&#125;.tar.gz&quot; \</span><br><span class="line">115                 | tar -xzC &quot;$SECCOMP_PATH&quot; --strip-components=1 \</span><br><span class="line">116         &amp;&amp; ( \</span><br><span class="line">117                 cd &quot;$SECCOMP_PATH&quot; \</span><br><span class="line">118                 &amp;&amp; ./configure --prefix=/usr/local \</span><br><span class="line">119                 &amp;&amp; make \</span><br><span class="line">120                 &amp;&amp; make install \</span><br><span class="line">121                 &amp;&amp; ldconfig \</span><br><span class="line">122         ) \</span><br><span class="line">123         &amp;&amp; rm -rf &quot;$SECCOMP_PATH&quot;</span><br><span class="line">124</span><br><span class="line">125 # Install Go</span><br><span class="line">126 # IMPORTANT: If the version of Go is updated, the Windows to Linux CI machines</span><br><span class="line">127 #            will need updating, to avoid errors. Ping #docker-maintainers on IRC</span><br><span class="line">128 #            with a heads-up.</span><br><span class="line">129 ENV GO_VERSION 1.7.5</span><br><span class="line">130 RUN curl -fsSL &quot;https://golang.org/dl/go$&#123;GO_VERSION&#125;.linux-amd64.tar.gz&quot; \</span><br><span class="line">131         | tar -xzC /usr/local</span><br><span class="line">132</span><br><span class="line">133 ENV PATH /go/bin:/usr/local/go/bin:$PATH</span><br><span class="line">134 ENV GOPATH /go</span><br><span class="line">135</span><br><span class="line">136 # Compile Go for cross compilation</span><br><span class="line">137 ENV DOCKER_CROSSPLATFORMS \</span><br><span class="line">138         linux/386 linux/arm \</span><br><span class="line">139         darwin/amd64 \</span><br><span class="line">140         freebsd/amd64 freebsd/386 freebsd/arm \</span><br><span class="line">141         windows/amd64 windows/386 \</span><br><span class="line">142         solaris/amd64</span><br><span class="line">143</span><br><span class="line">144 # Dependency for golint</span><br><span class="line">145 ENV GO_TOOLS_COMMIT 823804e1ae08dbb14eb807afc7db9993bc9e3cc3</span><br><span class="line">146 RUN git clone https://github.com/golang/tools.git /go/src/golang.org/x/tools \</span><br><span class="line">147         &amp;&amp; (cd /go/src/golang.org/x/tools &amp;&amp; git checkout -q $GO_TOOLS_COMMIT)</span><br><span class="line">148</span><br><span class="line">149 # Grab Go&#x27;s lint tool</span><br><span class="line">150 ENV GO_LINT_COMMIT 32a87160691b3c96046c0c678fe57c5bef761456</span><br><span class="line">151 RUN git clone https://github.com/golang/lint.git /go/src/github.com/golang/lint \</span><br><span class="line">152         &amp;&amp; (cd /go/src/github.com/golang/lint &amp;&amp; git checkout -q $GO_LINT_COMMIT) \</span><br><span class="line">153         &amp;&amp; go install -v github.com/golang/lint/golint</span><br><span class="line">154</span><br><span class="line">155 # Install CRIU for checkpoint/restore support</span><br><span class="line">156 ENV CRIU_VERSION 2.2</span><br><span class="line">157 RUN mkdir -p /usr/src/criu \</span><br><span class="line">158         &amp;&amp; curl -sSL https://github.com/xemul/criu/archive/v$&#123;CRIU_VERSION&#125;.tar.gz | tar -v -C /usr/src/criu/ -xz --strip-components=1 \</span><br><span class="line">159         &amp;&amp; cd /usr/src/criu \</span><br><span class="line">160         &amp;&amp; make \</span><br><span class="line">161         &amp;&amp; make install-criu</span><br><span class="line">162</span><br><span class="line">163 # Install two versions of the registry. The first is an older version that</span><br><span class="line">164 # only supports schema1 manifests. The second is a newer version that supports</span><br><span class="line">165 # both. This allows integration-cli tests to cover push/pull with both schema1</span><br><span class="line">166 # and schema2 manifests.</span><br><span class="line">167 ENV REGISTRY_COMMIT_SCHEMA1 ec87e9b6971d831f0eff752ddb54fb64693e51cd</span><br><span class="line">168 ENV REGISTRY_COMMIT 47a064d4195a9b56133891bbb13620c3ac83a827</span><br><span class="line">169 RUN set -x \</span><br><span class="line">170         &amp;&amp; export GOPATH=&quot;$(mktemp -d)&quot; \</span><br><span class="line">171         &amp;&amp; git clone https://github.com/docker/distribution.git &quot;$GOPATH/src/github.com/docker/distribution&quot; \</span><br><span class="line">172         &amp;&amp; (cd &quot;$GOPATH/src/github.com/docker/distribution&quot; &amp;&amp; git checkout -q &quot;$REGISTRY_COMMIT&quot;) \</span><br><span class="line">173         &amp;&amp; GOPATH=&quot;$GOPATH/src/github.com/docker/distribution/Godeps/_workspace:$GOPATH&quot; \</span><br><span class="line">174                 go build -o /usr/local/bin/registry-v2 github.com/docker/distribution/cmd/registry \</span><br><span class="line">175         &amp;&amp; (cd &quot;$GOPATH/src/github.com/docker/distribution&quot; &amp;&amp; git checkout -q &quot;$REGISTRY_COMMIT_SCHEMA1&quot;) \</span><br><span class="line">176         &amp;&amp; GOPATH=&quot;$GOPATH/src/github.com/docker/distribution/Godeps/_workspace:$GOPATH&quot; \</span><br><span class="line">177                 go build -o /usr/local/bin/registry-v2-schema1 github.com/docker/distribution/cmd/registry \</span><br><span class="line">178         &amp;&amp; rm -rf &quot;$GOPATH&quot;</span><br><span class="line">179</span><br><span class="line">180 # Install notary and notary-server</span><br><span class="line">181 ENV NOTARY_VERSION v0.4.2</span><br><span class="line">182 RUN set -x \</span><br><span class="line">183         &amp;&amp; export GOPATH=&quot;$(mktemp -d)&quot; \</span><br><span class="line">184         &amp;&amp; git clone https://github.com/docker/notary.git &quot;$GOPATH/src/github.com/docker/notary&quot; \</span><br><span class="line">185         &amp;&amp; (cd &quot;$GOPATH/src/github.com/docker/notary&quot; &amp;&amp; git checkout -q &quot;$NOTARY_VERSION&quot;) \</span><br><span class="line">186         &amp;&amp; GOPATH=&quot;$GOPATH/src/github.com/docker/notary/vendor:$GOPATH&quot; \</span><br><span class="line">187                 go build -o /usr/local/bin/notary-server github.com/docker/notary/cmd/notary-server \</span><br><span class="line">188         &amp;&amp; GOPATH=&quot;$GOPATH/src/github.com/docker/notary/vendor:$GOPATH&quot; \</span><br><span class="line">189                 go build -o /usr/local/bin/notary github.com/docker/notary/cmd/notary \</span><br><span class="line">190         &amp;&amp; rm -rf &quot;$GOPATH&quot;</span><br><span class="line">191</span><br><span class="line">192 # Get the &quot;docker-py&quot; source so we can run their integration tests</span><br><span class="line">193 ENV DOCKER_PY_COMMIT e2655f658408f9ad1f62abdef3eb6ed43c0cf324</span><br><span class="line">194 RUN git clone https://github.com/docker/docker-py.git /docker-py \</span><br><span class="line">195         &amp;&amp; cd /docker-py \</span><br><span class="line">196         &amp;&amp; git checkout -q $DOCKER_PY_COMMIT \</span><br><span class="line">197         &amp;&amp; pip install -r test-requirements.txt</span><br><span class="line">198</span><br><span class="line">199 # Install yamllint for validating swagger.yaml</span><br><span class="line">200 RUN pip install yamllint==1.5.0</span><br><span class="line">201</span><br><span class="line">202 # Install go-swagger for validating swagger.yaml</span><br><span class="line">203 ENV GO_SWAGGER_COMMIT c28258affb0b6251755d92489ef685af8d4ff3eb</span><br><span class="line">204 RUN git clone https://github.com/go-swagger/go-swagger.git /go/src/github.com/go-swagger/go-swagger \</span><br><span class="line">205         &amp;&amp; (cd /go/src/github.com/go-swagger/go-swagger &amp;&amp; git checkout -q $GO_SWAGGER_COMMIT) \</span><br><span class="line">206         &amp;&amp; go install -v github.com/go-swagger/go-swagger/cmd/swagger</span><br><span class="line">207</span><br><span class="line">208 # Set user.email so crosbymichael&#x27;s in-container merge commits go smoothly</span><br><span class="line">209 RUN git config --global user.email &#x27;docker-dummy@example.com&#x27;</span><br><span class="line">210</span><br><span class="line">211 # Add an unprivileged user to be used for tests which need it</span><br><span class="line">212 RUN groupadd -r docker</span><br><span class="line">213 RUN useradd --create-home --gid docker unprivilegeduser</span><br><span class="line">214</span><br><span class="line">215 VOLUME /var/lib/docker</span><br><span class="line">216 WORKDIR /go/src/github.com/docker/docker</span><br><span class="line">217 ENV DOCKER_BUILDTAGS apparmor pkcs11 seccomp selinux</span><br><span class="line">218</span><br><span class="line">219 # Let us use a .bashrc file</span><br><span class="line">220 RUN ln -sfv $PWD/.bashrc ~/.bashrc</span><br><span class="line">221 # Add integration helps to bashrc</span><br><span class="line">222 RUN echo &quot;source $PWD/hack/make/.integration-test-helpers&quot; &gt;&gt; /etc/bash.bashrc</span><br><span class="line">223</span><br><span class="line">224 # Register Docker&#x27;s bash completion.</span><br><span class="line">225 RUN ln -sv $PWD/contrib/completion/bash/docker /etc/bash_completion.d/docker</span><br><span class="line">226</span><br><span class="line">227 # Get useful and necessary Hub images so we can &quot;docker load&quot; locally instead of pulling</span><br><span class="line">228 COPY contrib/download-frozen-image-v2.sh /go/src/github.com/docker/docker/contrib/</span><br><span class="line">229 RUN ./contrib/download-frozen-image-v2.sh /docker-frozen-images \</span><br><span class="line">230         buildpack-deps:jessie@sha256:25785f89240fbcdd8a74bdaf30dd5599a9523882c6dfc567f2e9ef7cf6f79db6 \</span><br><span class="line">231         busybox:latest@sha256:e4f93f6ed15a0cdd342f5aae387886fba0ab98af0a102da6276eaf24d6e6ade0 \</span><br><span class="line">232         debian:jessie@sha256:f968f10b4b523737e253a97eac59b0d1420b5c19b69928d35801a6373ffe330e \</span><br><span class="line">233         hello-world:latest@sha256:8be990ef2aeb16dbcb9271ddfe2610fa6658d13f6dfb8bc72074cc1ca36966a7</span><br><span class="line">234 # See also &quot;hack/make/.ensure-frozen-images&quot; (which needs to be updated any time this list is)</span><br><span class="line">235</span><br><span class="line">236 # Install tomlv, vndr, runc, containerd, tini, docker-proxy</span><br><span class="line">237 # Please edit hack/dockerfile/install-binaries.sh to update them.</span><br><span class="line">238 COPY hack/dockerfile/binaries-commits /tmp/binaries-commits</span><br><span class="line">239 COPY hack/dockerfile/install-binaries.sh /tmp/install-binaries.sh</span><br><span class="line">240 RUN /tmp/install-binaries.sh tomlv vndr runc containerd tini proxy bindata</span><br><span class="line">241</span><br><span class="line">242 # Wrap all commands in the &quot;docker-in-docker&quot; script to allow nested containers</span><br><span class="line">243 ENTRYPOINT [&quot;hack/dind&quot;]</span><br><span class="line">244</span><br><span class="line">245 # Upload docker source</span><br><span class="line">246 COPY . /go/src/github.com/docker/docker</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们会遇到的问题是下载问题，所以好几个地方需要换成国内的源：</p>
<p>第一、替换Debian源为中国的源（大约第29行）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改前</span><br><span class="line">ARG APT_MIRROR=deb.debian.org</span><br><span class="line"></span><br><span class="line"># 修改后</span><br><span class="line">ARG APT_MIRROR=ftp.cn.debian.org</span><br></pre></td></tr></table></figure></p>
<p>第二、修改pip源为国内的源（大约第82行）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改前</span><br><span class="line">&amp;&amp; pip install awscli==1.10.15</span><br><span class="line"></span><br><span class="line"># 修改后</span><br><span class="line">&amp;&amp; pip install awscli==1.10.15 -i http://mirrors.aliyun.com/pypi/simple</span><br></pre></td></tr></table></figure></p>
<p>第三、修改下载go安装包的地址（大约第129行）。这里需要注意GO_VERSION的版本，不同版本的地址可以去<a href="http://golangtc.com/download">http://golangtc.com/download</a>获取。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改前</span><br><span class="line">ENV GO_VERSION 1.7.5</span><br><span class="line">RUN curl -fsSL &quot;https://golang.org/dl/go$&#123;GO_VERSION&#125;.linux-amd64.tar.gz&quot; \</span><br><span class="line">| tar -xzC /usr/local</span><br><span class="line"></span><br><span class="line"># 修改后</span><br><span class="line">ENV GO_VERSION 1.7.5</span><br><span class="line">RUN curl -fsSL &quot;http://golangtc.com/static/go/1.7.5/go1.7.5.linux-amd64.tar.gz&quot; \</span><br><span class="line">| tar -xzC /usr/local</span><br></pre></td></tr></table></figure></p>
<p>做如上修改之后就可以使用make build命令了，如果不出什么错的话，编译完之后就会有一个叫docker-dev的容器。当然上述命令可能由于github下载不稳定导致比较慢，如果受不了这种情况，另一个比较快的办法是，购买一台海外的云服务器，然后也不用做上述修改，直接make build，很简单快捷: )</p>
<ul>
<li>编译docker：就在刚才目录执行make binary命令即可：</li>
</ul>
<p>编译出的结果如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@vultr moby-17.03.2-ce]# ll bundles/latest/binary-client/</span><br><span class="line">total 13808</span><br><span class="line">lrwxrwxrwx 1 root root       17 Apr 23 16:58 docker -&gt; docker-17.03.2-ce</span><br><span class="line">-rwxr-xr-x 1 root root 14128576 Apr 23 16:58 docker-17.03.2-ce</span><br><span class="line">-rw-r--r-- 1 root root       52 Apr 23 16:58 docker-17.03.2-ce.md5</span><br><span class="line">-rw-r--r-- 1 root root       84 Apr 23 16:58 docker-17.03.2-ce.sha256</span><br><span class="line">[root@vultr moby-17.03.2-ce]# ll bundles/latest/binary-daemon/</span><br><span class="line">total 69160</span><br><span class="line">-rwxr-xr-x 1 root root  8932648 Apr 23 16:59 docker-containerd</span><br><span class="line">-rwxr-xr-x 1 root root  8381448 Apr 23 16:59 docker-containerd-ctr</span><br><span class="line">-rw-r--r-- 1 root root       56 Apr 23 16:59 docker-containerd-ctr.md5</span><br><span class="line">-rw-r--r-- 1 root root       88 Apr 23 16:59 docker-containerd-ctr.sha256</span><br><span class="line">-rw-r--r-- 1 root root       52 Apr 23 16:59 docker-containerd.md5</span><br><span class="line">-rw-r--r-- 1 root root       84 Apr 23 16:59 docker-containerd.sha256</span><br><span class="line">-rwxr-xr-x 1 root root  3047368 Apr 23 16:59 docker-containerd-shim</span><br><span class="line">-rw-r--r-- 1 root root       57 Apr 23 16:59 docker-containerd-shim.md5</span><br><span class="line">-rw-r--r-- 1 root root       89 Apr 23 16:59 docker-containerd-shim.sha256</span><br><span class="line">lrwxrwxrwx 1 root root       18 Apr 23 16:59 dockerd -&gt; dockerd-17.03.2-ce</span><br><span class="line">-rwxr-xr-x 1 root root 39989264 Apr 23 16:59 dockerd-17.03.2-ce</span><br><span class="line">-rw-r--r-- 1 root root       53 Apr 23 16:59 dockerd-17.03.2-ce.md5</span><br><span class="line">-rw-r--r-- 1 root root       85 Apr 23 16:59 dockerd-17.03.2-ce.sha256</span><br><span class="line">-rwxr-xr-x 1 root root   772408 Apr 23 16:59 docker-init</span><br><span class="line">-rw-r--r-- 1 root root       46 Apr 23 16:59 docker-init.md5</span><br><span class="line">-rw-r--r-- 1 root root       78 Apr 23 16:59 docker-init.sha256</span><br><span class="line">-rwxr-xr-x 1 root root  2534781 Apr 23 16:59 docker-proxy</span><br><span class="line">-rw-r--r-- 1 root root       47 Apr 23 16:59 docker-proxy.md5</span><br><span class="line">-rw-r--r-- 1 root root       79 Apr 23 16:59 docker-proxy.sha256</span><br><span class="line">-rwxr-xr-x 1 root root  7092608 Apr 23 16:59 docker-runc</span><br><span class="line">-rw-r--r-- 1 root root       46 Apr 23 16:59 docker-runc.md5</span><br><span class="line">-rw-r--r-- 1 root root       78 Apr 23 16:59 docker-runc.sha256</span><br></pre></td></tr></table></figure><br><img src="https://z3.ax1x.com/2021/05/04/gmvBQ0.jpg" alt=""></p>
<h2 id="由二进制安装启动docker"><a href="#由二进制安装启动docker" class="headerlink" title="由二进制安装启动docker"></a>由二进制安装启动docker</h2><p>编译出二进制文件之后就可以安装启动docker了，其主要步骤就是将编译出来的二进制拷贝到指定目录，然后启动服务。<br>安装启动步骤：</p>
<ul>
<li>编译出docker二进制或者下载docker发布的linux的二进制包</li>
<li>生成docker.service的文件并设定到/usr/lib/systemd/system目录下</li>
<li>拷贝docker的二进制文件docker*到/usr/bin或者执行路径可以找到的目录</li>
<li>systemctl restart docker</li>
<li>systemctl enable docker</li>
</ul>
<p>为了方便，将该过程脚本化，脚本名为install_docker.sh：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">############################################################</span><br><span class="line"># This script can install docker from docker binary files. #</span><br><span class="line"># So first need the dir contains the docker bin files.     #</span><br><span class="line"># You can compile the source code for binary files         #</span><br><span class="line"># or get docker-ce binary from:                            #</span><br><span class="line"># https://download.docker.com/linux/static/stable/x86_64/  #</span><br><span class="line">############################################################</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYSTEMDDIR=/usr/lib/systemd/system</span><br><span class="line">SERVICEFILE=docker.service</span><br><span class="line">DOCKERDIR=/usr/bin</span><br><span class="line">SERVICENAME=docker</span><br><span class="line"></span><br><span class="line">precheck()&#123;</span><br><span class="line">  echo &quot;Check the env before install docker...&quot;</span><br><span class="line">  if [ -f $&#123;DOCKERDIR&#125;/$&#123;SERVICENAME&#125; ]; then</span><br><span class="line">     echo &quot;already had docker, remove current docker...&quot;</span><br><span class="line">     echo &quot;Stop current $&#123;SERVICENAME&#125; service...&quot;</span><br><span class="line">     systemctl stop $&#123;SERVICENAME&#125;</span><br><span class="line">     echo &quot;Remove current $&#123;SERVICENAME&#125; bin files&quot;</span><br><span class="line">     rm -f $&#123;DOCKERDIR&#125;/$&#123;SERVICENAME&#125;*</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;Finish precheck.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">usage()&#123;</span><br><span class="line">  echo &quot;Usage: $0 DOCKER_BIN_FILE_DIR&quot;</span><br><span class="line">  echo &quot;       $0 ./docker/&quot;</span><br><span class="line">  echo &quot;Get docker-ce binary from: https://download.docker.com/linux/static/stable/x86_64/ or compile source code yourself&quot;</span><br><span class="line">  echo &quot;eg: wget https://download.docker.com/linux/static/stable/x86_64/docker-17.09.0-ce.tgz&quot;</span><br><span class="line">  echo &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ $# -ne 1 ]; then</span><br><span class="line">  usage</span><br><span class="line">  exit 1</span><br><span class="line">else</span><br><span class="line">  DOCKERBIN=&quot;$1&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">precheck</span><br><span class="line">if [ ! -d $&#123;DOCKERBIN&#125; ]; then</span><br><span class="line">  echo &quot;Docker binary dir does not exist, please check it&quot;</span><br><span class="line">  echo &quot;Get docker-ce binary from: https://download.docker.com/linux/static/stable/x86_64/ or you can compile the docker source code for binary files&quot;</span><br><span class="line">  echo &quot;eg: wget https://download.docker.com/linux/static/stable/x86_64/docker-17.09.0-ce.tgz&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;##binary : $&#123;DOCKERBIN&#125; copy to $&#123;DOCKERDIR&#125;&quot;</span><br><span class="line">cp -p $&#123;DOCKERBIN&#125;/* $&#123;DOCKERDIR&#125; &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">which $&#123;SERVICENAME&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;##systemd service: $&#123;SERVICEFILE&#125;&quot;</span><br><span class="line">echo &quot;##docker.service: create docker systemd file&quot;</span><br><span class="line">cat &gt;$&#123;SYSTEMDDIR&#125;/$&#123;SERVICEFILE&#125; &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=http://docs.docker.com</span><br><span class="line">After=network.target docker.socket</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=-/run/flannel/docker</span><br><span class="line">WorkingDirectory=/usr/local/bin</span><br><span class="line">ExecStart=/usr/bin/dockerd \</span><br><span class="line">                -H tcp://0.0.0.0:4243 \</span><br><span class="line">                -H unix:///var/run/docker.sock \</span><br><span class="line">                --selinux-enabled=false \</span><br><span class="line">                --log-opt max-size=1g</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line"># Having non-zero Limit*s causes performance problems due to accounting overhead</span><br><span class="line"># in the kernel. We recommend using cgroups to do container-local accounting.</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"># Uncomment TasksMax if your systemd version supports it.</span><br><span class="line"># Only systemd 226 and above support this version.</span><br><span class="line">#TasksMax=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line"># set delegate yes so that systemd does not reset the cgroups of docker containers</span><br><span class="line">Delegate=yes</span><br><span class="line"># kill only the docker process, not all processes in the cgroup</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">echo &quot;&quot;</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">echo &quot;##Service status: $&#123;SERVICENAME&#125;&quot;</span><br><span class="line">systemctl status $&#123;SERVICENAME&#125;</span><br><span class="line">echo &quot;##Service restart: $&#123;SERVICENAME&#125;&quot;</span><br><span class="line">systemctl restart $&#123;SERVICENAME&#125;</span><br><span class="line">echo &quot;##Service status: $&#123;SERVICENAME&#125;&quot;</span><br><span class="line">systemctl status $&#123;SERVICENAME&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;##Service enabled: $&#123;SERVICENAME&#125;&quot;</span><br><span class="line">systemctl enable $&#123;SERVICENAME&#125;</span><br><span class="line"></span><br><span class="line">echo &quot;## docker version&quot;</span><br><span class="line">docker version</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>脚本使用说明：<br>使用脚本的时候需要将所有的docker二进制放到一个目录中，比如就放到当前的docker目录中，那么使用方法便是<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh install_docker.sh ./docker</span><br></pre></td></tr></table></figure><br><img src="https://z3.ax1x.com/2021/05/04/gmvyeU.jpg" alt=""></p>
<p>安装启动完毕查看docker是否正常<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.2-ce</span><br><span class="line"> API version:  1.27</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   1</span><br><span class="line"> Built:        Tue Apr 23 08:57:53 2019</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.2-ce</span><br><span class="line"> API version:  1.27 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   1</span><br><span class="line"> Built:        Tue Apr 23 08:57:53 2019</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: false</span><br></pre></td></tr></table></figure><br>或者使用<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><br>查看</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="没有指定DOCKER-GITCOMMIT的问题"><a href="#没有指定DOCKER-GITCOMMIT的问题" class="headerlink" title="没有指定DOCKER_GITCOMMIT的问题"></a>没有指定DOCKER_GITCOMMIT的问题</h3><blockquote>
<p>.git directory missing and DOCKER_GITCOMMIT not specified<br>  Please either build with the .git directory accessible, or specify the<br>  exact (–short) commit hash you are building using DOCKER_GITCOMMIT for<br>  future accountability in diagnosing build issues.  Thanks!</p>
</blockquote>
<p>解决办法：<br>     手动指定即可，例如<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make DOCKER_GITCOMMIT=bb80604 binary</span><br></pre></td></tr></table></figure></p>
<h3 id="Failed-to-start-Docker-Application-Container-Engine或者initializing-graphdriver-driver-not-supported"><a href="#Failed-to-start-Docker-Application-Container-Engine或者initializing-graphdriver-driver-not-supported" class="headerlink" title="Failed to start Docker Application Container Engine或者initializing graphdriver: driver not supported"></a>Failed to start Docker Application Container Engine或者initializing graphdriver: driver not supported</h3><p><img src="https://z3.ax1x.com/2021/05/04/gmv2FJ.jpg" alt=""><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: docker.service: main process exited, code=exited, status=203/EXEC</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: Unit docker.service entered failed state.</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: docker.service failed.</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: docker.service holdoff time over, scheduling restart.</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: Stopped Docker Application Container Engine.</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: start request repeated too quickly for docker.service</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: Unit docker.service entered failed state.</span><br><span class="line">Apr 24 10:19:15 vultr.guest systemd[1]: docker.service failed.</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>错误原因：error initializing graphdriver: driver not supported<br>解决办法：在 /etc/docker 目录的daemon.json文件中加入以下配置<br>vi /etc/docker/daemon.json<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">  &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;overlay2.override_kernel_check=true&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再次启动<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></p>
<p>另外一个解决办法是：<br>sudo mv /var/lib/docker /var/lib/docker.old，然后重启</p>
<p>这个方法有个弊端，因为docker的所有文件都是在这个文件夹里面的，所以<strong>所有的container和image</strong>都会没了</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://github.com/moby/moby/releases">https://github.com/moby/moby/releases</a> </p>
<p><a href="https://niyanchun.com/compile-docker-from-source.html">从源码编译docker</a>  </p>
<p><a href="https://delveshal.github.io/2018/06/04/docker%E4%B9%8B%E8%B7%AF%EF%BC%9Adocker-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">docker之路：docker 开发环境配置</a></p>
<p><a href="https://jimmysong.io/posts/docker-plugin-develop/">Docker17.03-CE插件开发案例</a></p>
<p><a href="https://blog.csdn.net/liumiaocn/article/details/71157586">二进制方式安装docker</a></p>
<p><a href="https://www.imooc.com/article/70557">Docker无法启动 error initializing graphdriver: driver not supported</a></p>
<p><a href="https://github.com/liumiaocn/easypack/blob/master/docker/install-docker.sh">docker安装脚本</a></p>
<p><a href="https://github.com/moby/moby/issues/27581">Releases unbuildable because of unset <code>DOCKER_GITCOMMIT</code></a></p>
<p><a href="https://jimmysong.io/posts/docker-dev-env/">Docker源码编译和开发环境搭建</a></p>
<p><a href="https://urzz.me/2017/12/17/failed-start-docker-after-upgrade-kernel/">升级内核后无法启动docker</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker源码</tag>
      </tags>
  </entry>
  <entry>
    <title>raft协议解析</title>
    <url>/2019/05/16/raft%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/04/23/cOKAZq.jpg" alt=""></p>
<span id="more"></span>
<p>本文主要介绍raft一致性协议，在理解该协议的过程中，除了阅读原论文，还参考了很多参考资料中列出的文章，这些文章对我对raft的理解起了很大的帮助。在这些文章的基础上，遂按照自己的理解对相关资料做了整合更新。另外就是发现每次读原版论文和相关文章的时候都能读出新的东西，很是奇妙。PS:个人觉得这些经典的论文和资料可以多读几遍。</p>
<p>Raft实现了和Paxos相同的功能，它将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等。同时，Raft算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。<br>本文通过Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）以及具体实例等方面来解析raft。</p>
<h2 id="一致性-consensus"><a href="#一致性-consensus" class="headerlink" title="一致性(consensus)"></a>一致性(consensus)</h2><p>在开始正式解析raft之前，我们看一下什么是一致性问题？举个简单的例子，现在的分布式存储系统中，为了保证数据的可靠性及服务的高可用性，一般一个数据都存三份，那么问题就来了，如何保证这三份复本的一致性，也就是要保证三个复本一样。此外，更广泛的一致性问题还指相互独立的节点之间如何达成一项决议的问题。分布式系统中，进行数据库事务提交(commit transaction)、Leader选举、序列号生成等都会遇到一致性问题。这个问题在我们的日常生活中也很常见，比如牌友怎么商定几点在哪打几圈麻将，有人可能会说，决定什么时候在哪搓麻将，4个人商量一下就ok，这不很简单吗？<br>但就这样看似简单的事情，分布式系统实现起来并不轻松，因为它面临着这些问题：</p>
<ul>
<li><strong>消息传递异步无序(asynchronous)</strong>: 现实网络不是一个可靠的信道，存在消息延时、丢失，节点间消息传递做不到同步有序(synchronous)  </li>
<li><strong>节点宕机(fail-stop)</strong>: 节点持续宕机，不会恢复（这种情况对应我们存储系统中一般称为永久故障）</li>
<li><strong>节点宕机恢复(fail-recover)</strong>: 节点宕机一段时间后恢复，在分布式系统中最常见（这种情况对应我们存储系统中一般称为临时故障）</li>
<li><strong>网络分化(network partition)</strong>: 网络链路出现问题，将N个节点隔离成多个部分</li>
<li><strong>拜占庭将军问题(byzantine failure)</strong>: 节点或宕机或逻辑失败，甚至不按套路出牌抛出干扰决议的信息</li>
</ul>
<p>假设一个具有N个节点的分布式系统，当其满足以下条件时，我们说这个系统满足一致性：</p>
<ul>
<li><strong>全认同(agreement)</strong>: 所有N个节点都认同一个结果</li>
<li><strong>值合法(validity)</strong>: 该结果必须由N个节点中的节点提出</li>
<li><strong>可结束(termination)</strong>: 决议过程在一定时间内结束，不会无休止地进行下去</li>
</ul>
<h2 id="raft协议概述"><a href="#raft协议概述" class="headerlink" title="raft协议概述"></a>raft协议概述</h2><p>Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：</p>
<p>Leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。<br>Follower：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。<br>Candidate：Leader选举过程中的临时角色。</p>
<p>Raft算法角色<br>在正常情况下，Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。</p>
<p>Raft算法角色状态转换如下：<br><img src="https://z3.ax1x.com/2021/04/23/cOKEd0.jpg" alt="Raft算法角色状态转换"></p>
<p>Follower只响应其他服务器的请求。如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举。收到大多数服务器投票的Candidate会成为新的Leader。Leader在宕机之前会一直保持Leader的状态。</p>
<p><img src="https://z3.ax1x.com/2021/04/23/cOKFLn.jpg" alt=""><br>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束(这里的term相当于逻辑时钟，可以用term来判别一个消息是否过时)。Raft 保证了在一个给定的任期内，最多只有一个领导者。</p>
<h2 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h2><p>Raft协议的每个副本都会处于三种状态之一：Leader、Follower、Candidate。</p>
<p>Leader：所有请求的处理者，Leader副本接受client的更新请求，本地处理后再同步到多个其他副本；<br>Follower：请求的被动更新者，从Leader接受更新请求，然后写入本地日志文件<br>Candidate：如果Follower副本在一段时间内没有收到Leader副本的心跳，则判断Leader可能已经故障，此时启动选主过程，此时副本会变成Candidate状态，直到选主结束。<br>时间被分为很多连续的随机长度的term，term有唯一的id。每个term一开始就进行选主：</p>
<ul>
<li>Follower将自己维护的current_term_id加1（即自增当前的任期号currentTerm）， 然后将自己的状态转成Candidate</li>
<li>给自己投票</li>
<li>重置选举超时计时器</li>
<li>发送RequestVoteRPC消息(带上current_term_id) 给 其它所有server</li>
</ul>
<p>这个过程会有三种可能的结果：</p>
<ol>
<li>自己赢得了这次的选举，成了主。当收到了majority的投票后，状态切成Leader，并且定期给其它的所有server发心跳消息（不带log的AppendEntriesRPC）以告诉对方自己是current_term_id所标识的term的leader。每个term最多只有一个leader，<strong>term id作为logical clock，在每个RPC消息中都会带上，用于检测过期的消息</strong>。当一个server收到的RPC消息中的rpc_term_id比本地的current_term_id更大时，就更新current_term_id为rpc_term_id，并且如果当前state为leader或者candidate时，将自己的状态切成follower。如果rpc_term_id比本地的current_term_id更小，则拒绝这个RPC消息。</li>
<li>其他的服务器成为主。如1所述，当Candidator在等待投票的过程中，收到了大于或者等于本地的current_term_id的声明对方是leader的AppendEntriesRPC时，则将自己的state切成follower，并且更新本地的current_term_id。</li>
<li>没有选出主。当投票被瓜分，没有任何一个candidate收到了majority的vote时，没有leader被选出。这种情况下，每个candidate等待的投票的过程就超时了，接着candidates都会将本地的current_term_id再加1，发起RequestVoteRPC进行新一轮的leader election。</li>
</ol>
<p>投票策略：</p>
<p>每个节点只会给每个term投一票，具体的是否同意和Safety有关，请参阅Safety（安全性）这一节。<br>当投票被瓜分后，所有的candidate同时超时，然后有可能进入新一轮的票数被瓜分，为了避免这个问题，Raft采用一种很简单的方法：每个Candidate的election timeout从150ms-300ms之间随机取，那么第一个超时的Candidate就可以发起新一轮的leader election，带着最大的term_id给其它所有server发送RequestVoteRPC消息，从而自己成为leader，然后给他们发送心跳消息以告诉他们自己是主。</p>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>当Leader被选出来后，就可以接受客户端发来的请求了，每个请求包含一条需要被replicated state machines执行的命令。leader会把它作为一个log entry append到日志中，然后给其它的server发AppendEntriesRPC请求。当Leader确定一个log entry被safely replicated了（大多数副本已经将该命令写入日志当中），就apply这条log entry到状态机中然后返回结果给客户端。如果某个Follower宕机了或者运行的很慢，或者网络丢包了，则会一直给这个Follower发AppendEntriesRPC直到日志一致。</p>
<p>当一条日志是commited时，Leader才可以将它应用到状态机中。Raft保证一条commited的log entry已经持久化了并且会被所有的节点执行。</p>
<p>Raft日志复制保证如下两点：</p>
<ul>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/04/23/cOKVoV.jpg" alt=""></p>
<p>当一个新的Leader被选出来时，它的日志和其它的Follower的日志可能不一样，这个时候，就需要一个机制来保证日志的一致性。一个新leader产生时，集群状态可能如下：<br><img src="https://z3.ax1x.com/2021/04/23/cOKuz4.jpg" alt=""><br>最上面这个是新leader,其上方的数字代表log index，a~f是follower，每个格子代表一条log entry，格子内的数字代表这个log entry是在哪个term上产生的。</p>
<p>新leader产生后，就以leader上的log为准。其它的follower要么少了数据比如b，要么多了数据，比如d，要么既少了又多了数据，比如f。</p>
<p>因此，需要有一种机制来让leader和follower对log达成一致，leader会为每个follower维护一个nextIndex，表示leader给各个follower发送的下一条log entry在log中的index，初始化为leader的最后一条log entry的下一个位置。leader给follower发送AppendEntriesRPC消息，带着(term_id, (nextIndex-1))， term_id即(nextIndex-1)这个槽位的log entry的term_id，follower接收到AppendEntriesRPC后，会从自己的log中找是不是存在这样的log entry，如果不存在，就给leader回复拒绝消息，然后leader则将nextIndex减1，再重复，知道AppendEntriesRPC消息被接收。</p>
<p>以leader和b为例：</p>
<p>初始化，nextIndex为11，leader给b发送AppendEntriesRPC(6,10)，b在自己log的10号槽位中没有找到term_id为6的log entry。则给leader回应一个拒绝消息。接着，leader将nextIndex减一，变成10，然后给b发送AppendEntriesRPC(6, 9)，b在自己log的9号槽位中同样没有找到term_id为6的log entry。循环下去，直到leader发送了AppendEntriesRPC(4,4)，b在自己log的槽位4中找到了term_id为4的log entry，便接收了消息。随后，leader就可以从槽位5开始给b推送日志了。</p>
<h2 id="Safety（安全性）"><a href="#Safety（安全性）" class="headerlink" title="Safety（安全性）"></a>Safety（安全性）</h2><p>安全性主要解决什么样的节点可以成为主的问题，那么哪些follower有资格成为leader?</p>
<blockquote>
<p><strong>Raft保证被选为新leader的节点拥有所有已提交的log entry</strong>，这与ViewStamped Replication不同，后者不需要这个保证，而是通过其他机制从follower拉取自己没有的提交的日志记录  </p>
</blockquote>
<p>这个保证是在RequestVoteRPC阶段做的，candidate在发送RequestVoteRPC时，会带上自己的最后一条日志记录的term_id和index，其他节点收到消息时，如果发现自己的日志比RPC请求中携带的更新，拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term id更大，则更新，如果term id一样大，则日志更多的更大(index更大)。</p>
<p>哪些日志记录被认为是commited?</p>
<blockquote>
<p>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</p>
</blockquote>
<p>之所以要这样，是因为可能会出现已提交的日志又被覆盖的情况：<br><img src="https://z3.ax1x.com/2021/04/23/cOKMQJ.jpg" alt=""></p>
<ol>
<li>在阶段a，term为2，S1是Leader，且S1写入日志（term, index）为(2, 2)，并且日志被同步写入了S2；  </li>
<li>在阶段b，S1离线，触发一次新的选主，此时S5被选为新的Leader，此时系统term为3，且写入了日志（term, index）为（3， 2）;</li>
<li>S5尚未将日志推送到Followers变离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点（S1, S2, S3），因此，此时日志（2，2）可以被commit了（即更新到状态机）；</li>
<li>在阶段d，S1又很不幸地下线了，系统触发一次选主，而S5有可能被选为新的Leader（这是因为S5可以满足作为主的一切条件：1. term = 3 &gt; 2, 2. 最新的日志index为2，比大多数节点（如S2/S3/S4的日志都新），然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志（2，2）被截断了，这是致命性的错误，因为一致性协议中不允许出现已经应用到状态机中的日志被截断。</li>
</ol>
<p>为了避免这种致命错误，需要对协议进行一个微调：</p>
<blockquote>
<p><strong>只允许主节点提交包含当前term的日志</strong></p>
</blockquote>
<p>针对上述情况就是：即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被Commit，因为它是来自之前term(2)的日志，直到S1在当前term（4）产生的日志（4， 3）被大多数Follower确认，S1方可Commit（4，3）这条日志，当然，根据Raft定义，（4，3）之前的所有日志也会被Commit。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志（4，3）。</p>
<p>总结就是为了安全性考虑，raft中对要成为主的节点增加了以下两点限制：</p>
<ul>
<li>拥有最新的已提交的log entry的Follower才有资格成为Leader</li>
<li>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，leader不能直接提交旧的term的日志，即使旧term的日志已经复制到大多数服务器上了，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</li>
</ul>
<h2 id="集群拓扑变化-Cluser-Membership-变更"><a href="#集群拓扑变化-Cluser-Membership-变更" class="headerlink" title="集群拓扑变化(Cluser Membership 变更)"></a>集群拓扑变化(Cluser Membership 变更)</h2><p>前面文章阐述的一个基础是加速集群配置是固定的（即参与到一致性算法中的服务器的集合是固定的）。然而在实际中配置变更却经常是必要，比如替换掉故障的机器或者从三副本变更到六副本。当然我们可以通过下线整个集群、更新配置文件、然后重启集群来达到配置变更的目的，但是这会使集群在做变更操作期间不可用。此外，如果这个过程是手动操作的，那么还会有操作失误的风险。为了避免这些问题，raft自动化了整个配置变更过程。<br>为了确保配置变更机制安全，那就必须保证在转换的过程中，在同一term内，没有出现两个leader的情况。</p>
<blockquote>
<p>成员变更也是一个分布式一致性问题，既所有服务器对新成员达成一致。但是成员变更又有其特殊性，因为在成员变更的一致性达成的过程中，参与投票的进程会发生变化。<br>如果将成员变更当成一般的一致性问题，直接向Leader发送成员变更请求，Leader复制成员变更日志，达成多数派之后提交，各服务器提交成员变更日志后从旧成员配置（Cold）切换到新成员配置（Cnew）。<br>因为各个服务器提交成员变更日志的时刻可能不同，造成各个服务器从旧成员配置（Cold）切换到新成员配置（Cnew）的时刻不同。<br>成员变更不能影响服务的可用性，但是成员变更过程的某一时刻，可能出现在Cold和Cnew中同时存在两个不相交的多数派，进而可能选出两个Leader，形成不同的决议，破坏安全性。</p>
</blockquote>
<p>下图是成员变更的某一时刻Cold和Cnew中同时存在两个不相交的多数派，这种情况下就有可能出现server2认为自己是leader，而server3也认为自己是主的情况。（server2看到集群配置是server1,server2,server3,然后server1和server2投票给server2，这是一个多数派；而server3看得集群配置是server1,server2,server3,server4,server5，然后server3,server4,server5投票给server3，这是第二个多数派，所以这种情况下会出现两个leader）<br><img src="https://pic3.zhimg.com/v2-c8e4ead21f6f2e9d40361717739519c6_b.jpg" alt=""><br>由于成员变更的这一特殊性，成员变更不能当成一般的一致性问题去解决。为了解决这一问题，Raft提出了两阶段的成员变更方法。集群先从旧成员配置Cold切换到一个过渡成员配置，称为共同一致（joint consensus），共同一致是旧成员配置Cold和新成员配置Cnew的组合Cold U Cnew，一旦共同一致Cold U Cnew被提交，系统再切换到新成员配置Cnew。<br><img src="https://pic3.zhimg.com/v2-6b85a141cd131aa129a4e70d060f37be_b.jpg" alt=""></p>
<p><strong>Raft两阶段成员变更过程如下</strong>：  </p>
<ol>
<li>Leader收到成员变更请求从Cold切成Cnew；  </li>
<li>Leader在本地生成一个新的log entry，其内容是Cold∪Cnew，代表当前时刻新旧成员配置共存，写入本地日志，同时将该log entry复制至Cold∪Cnew中的所有副本。在此之后新的日志同步需要保证得到Cold和Cnew两个多数派的确认；  </li>
<li>Follower收到Cold∪Cnew的log entry后更新本地日志，并且此时就以该配置作为自己的成员配置；  </li>
<li>如果Cold和Cnew中的两个多数派确认了Cold U Cnew这条日志，Leader就提交这条log entry；  </li>
<li>接下来Leader生成一条新的log entry，其内容是新成员配置Cnew，同样将该log entry写入本地日志，同时复制到Follower上；  </li>
<li>Follower收到新成员配置Cnew后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在Cnew这个成员配置中会自动退出；  </li>
<li>Leader收到Cnew的多数派确认后，表示成员变更成功，后续的日志只要得到Cnew多数派确认即可。Leader给客户端回复成员变更执行成功。</li>
</ol>
<p><strong>异常分析</strong>：  </p>
<ul>
<li>如果Leader的Cold U Cnew尚未推送到Follower，Leader就挂了，此后选出的新Leader并不包含这条日志，此时新Leader依然使用Cold作为自己的成员配置。</li>
<li>如果Leader的Cold U Cnew推送到大部分的Follower后就挂了，此后选出的新Leader可能是Cold也可能是Cnew中的某个Follower。</li>
<li>如果Leader在推送Cnew配置的过程中挂了，那么同样，新选出来的Leader可能是Cold也可能是Cnew中的某一个，此后客户端继续执行一次改变配置的命令即可。</li>
<li>如果大多数的Follower确认了Cnew这个消息后，那么接下来即使Leader挂了，新选出来的Leader肯定位于Cnew中。  </li>
</ul>
<p>两阶段成员变更比较通用且容易理解，但是实现比较复杂，同时两阶段的变更协议也会在一定程度上影响变更过程中的服务可用性，因此我们期望增强成员变更的限制，以简化操作流程。<br>两阶段成员变更，之所以分为两个阶段，是因为对Cold与Cnew的关系没有做任何假设，为了避免Cold和Cnew各自形成不相交的多数派选出两个Leader，才引入了两阶段方案。<br>如果增强成员变更的限制，假设Cold与Cnew任意的多数派交集不为空，这两个成员配置就无法各自形成多数派，那么成员变更方案就可能简化为一阶段。<br>那么如何限制Cold与Cnew，使之任意的多数派交集不为空呢？方法就是每次成员变更只允许增加或删除一个成员。  </p>
<p><strong>可从数学上严格证明，只要每次只允许增加或删除一个成员，Cold与Cnew不可能形成两个不相交的多数派。</strong>  </p>
<p>一阶段成员变更：</p>
<ul>
<li>成员变更限制每次只能增加或删除一个成员（如果要变更多个成员，连续变更多次）。</li>
<li>成员变更由Leader发起，Cnew得到多数派确认后，返回客户端成员变更成功。</li>
<li>一次成员变更成功前不允许开始下一次成员变更，因此新任Leader在开始提供服务前要将自己本地保存的最新成员配置重新投票形成多数派确认。</li>
<li>Leader只要开始同步新成员配置，即可开始使用新的成员配置进行日志同步。</li>
</ul>
<h2 id="Log-Compaction（日志压缩）"><a href="#Log-Compaction（日志压缩）" class="headerlink" title="Log Compaction（日志压缩）"></a>Log Compaction（日志压缩）</h2><p>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响可用性。Raft采用对整个系统进行snapshot来解决，snapshot之前的日志都可以丢弃。</p>
<p>每个副本独立的对自己的系统状态进行snapshot，并且只能对已经提交的日志记录进行snapshot。</p>
<p>Snapshot中包含以下内容：</p>
<ul>
<li>日志元数据。最后一条已提交的 log entry的 log index和term。这两个值在snapshot之后的第一条log entry的AppendEntries RPC的完整性检查的时候会被用上。</li>
<li>系统当前状态<br><img src="https://z3.ax1x.com/2021/04/23/cOKlLR.jpg" alt=""><br>当Leader要发给某个日志落后太多的Follower的log entry被丢弃，Leader会将snapshot发给Follower。或者当新加进一台机器时，也会发送snapshot给它。发送snapshot使用InstalledSnapshot RPC（RPC细节参见八、Raft算法总结）。</li>
</ul>
<p>做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。</p>
<p>做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p>
<h2 id="Raft与Paxos"><a href="#Raft与Paxos" class="headerlink" title="Raft与Paxos"></a>Raft与Paxos</h2><p>Raft 其实就是 Multi-Paxos 的一个变种，Raft 通过简化 Multi-Paxos 的模型，实现了一种更容易让人理解的共识算法，它们两者都能够对一系列连续的问题达成一致。<br>Raft 在 Multi-Paxos 的基础之上做了两个限制，首先是 Raft 中追加日志的操作必须是连续的，而 Multi-Paxos 中追加日志的操作是并发的，但是对于节点内部的状态机来说两者都是有序的，第二就是 Raft 对 Leader 选举的条件做了限制，只有拥有最新、最全日志的节点才能够当选 Leader，但是 Multi-Paxos 由于任意节点都可以写日志，所以在选择 Leader 上也没有什么限制，只是在选择 Leader 之后需要将 Leader 中的日志补全。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>略<br>可参考<a href="http://thesecretlivesofdata.com/raft/">动画图解raft</a> </p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://raft.github.io/raft.pdf">raft论文</a><br><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf">raft博士论文</a><br><a href="https://raft.github.io/">The Raft Consensus Algorithm</a><br><a href="http://thesecretlivesofdata.com/raft/">动画图解raft</a><br><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">raft论文翻译</a><br><a href="https://www.codedump.info/post/20180921-raft/">Raft算法原理</a><br><a href="https://zhuanlan.zhihu.com/p/27207160">Raft协议详解</a><br><a href="https://zhuanlan.zhihu.com/p/32052223">Raft算法详解</a><br><a href="https://zhuanlan.zhihu.com/p/36547283">别再怀疑自己的智商了，Raft协议本来就不好理解</a><br><a href="https://pingcap.com/blog-cn/optimizing-raft-in-tikv/">raft优化可参考</a><br><a href="https://zhuanlan.zhihu.com/p/49460319">MIT课程有关raft</a>  </p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>一致性算法</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>解决photon中ping command not found</title>
    <url>/2019/04/19/%E8%A7%A3%E5%86%B3photon%E4%B8%ADping%20command%20not%20found/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/04/gmvtoQ.jpg" alt=""></p>
<span id="more"></span>
<p>本文主要解决photon中ping command not found的问题</p>
<h2 id="photon介绍"><a href="#photon介绍" class="headerlink" title="photon介绍"></a>photon介绍</h2><p><img src="http://static.oschina.net/uploads/img/201512/20112919_P9RS.png" alt=""><br>VMware推出的Linux操作系统Photon，为vSphere优化的Container执行平台。<br>Photon是以提供Container执行环境为目的的轻量操作系统。</p>
<p>虚拟化厂商VMware在2015年4月推出了自家的Linux版本Photon，用于打造轻量级虚拟化Container环境的轻量级Linux操作系统。</p>
<p>Photon提供4种安装模式，而4种模式所占的镜像文件大小都不一样，如全安装占了1.7GB，最小安装（Minimal）则需303MB，微安装（Micro）需要462MB，至于最后一个自定义安装则介于全安装及最小安装两者之间。</p>
<p>VMware表示，Photon是一个为vSphere优化的Container执行平台，可以支持多项Container技术，如Docker、Rocket Container（rkt）和Pivotal Garden Container镜像文件。</p>
<p>Photon可部署于vSphere 5.5、vSphere 6.0、vCloud Air、VMware Fusion和VMware Workstation产品上，除了协助企业将Fusion、VMware Workstaion等测试环境上的应用程序，搬迁到使用vSphere上的正式环境，并通过Lightwave对Container进行访问控制、身份管理等功能。</p>
<p>企业也可以整合Lightwave和Photon，提供多租户目录服务，加强大量Container的管理，例如限定特定Container所能执行的主机，并且限制只有特定权限的使用者可以管理Container。<br><img src="http://static.oschina.net/uploads/img/201512/20112919_RJTD.png" alt=""></p>
<p>Photon可部署在vSphere之上，并透过Lightwave对Container进行访问控制、身份管理等功能。</p>
<p><img src="http://static.oschina.net/uploads/img/201512/20112920_Lt6d.png" alt=""></p>
<p>Photon可以提供4种安装模式：微安装（Micro）、最小安装（Minimal）、全安装及客制化安装，每种模式的映像文件大小都不一。</p>
<h2 id="解决ping-command-not-found问题"><a href="#解决ping-command-not-found问题" class="headerlink" title="解决ping command not found问题"></a>解决ping command not found问题</h2><p><strong>VMware 的开源项目harbor使用的基础镜像也包括photon</strong><br>不过在项目过程中，遇到使用photon的容器无法联通host上一个虚拟IP，而用Ubuntu的容器则可以，但是photon上面貌似什么命令也没有，包括ping命令。下面给出解决ping command not found问题的方法：</p>
<h3 id="photon-1-0版本"><a href="#photon-1-0版本" class="headerlink" title="photon 1.0版本"></a>photon 1.0版本</h3><p>查看photon版本<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/photon-release</span><br></pre></td></tr></table></figure><br>结果：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VMware Photon Linux 1.0</span><br><span class="line">PHOTON_BUILD_NUMBER=62c543d</span><br></pre></td></tr></table></figure></p>
<p>使用如下命令解决：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tdnf install iputils</span><br></pre></td></tr></table></figure></p>
<h3 id="photon-2-0及以上版本"><a href="#photon-2-0及以上版本" class="headerlink" title="photon 2.0及以上版本"></a>photon 2.0及以上版本</h3><p>查看photon版本<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/photon-release</span><br></pre></td></tr></table></figure><br>结果：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VMware Photon OS 2.0</span><br><span class="line">PHOTON_BUILD_NUMBER=0922243</span><br></pre></td></tr></table></figure></p>
<p>使用如下命令解决：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tdnf install pmd-cli</span><br></pre></td></tr></table></figure></p>
<p>可以将这个安装添加到Dockerfile中：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM vmware/photon:2.0</span><br><span class="line"></span><br><span class="line">RUN tdnf erase vim -y \</span><br><span class="line">    &amp;&amp; tdnf distro-sync -y || echo \</span><br><span class="line">    &amp;&amp; tdnf install -y sudo &gt;&gt; /dev/null \</span><br><span class="line">    &amp;&amp; tdnf install -y pmd-cli &gt;&gt; /dev/null \</span><br><span class="line">    &amp;&amp; tdnf clean all \</span><br><span class="line">    &amp;&amp; groupadd -r -g 10000 harbor &amp;&amp; useradd --no-log-init -r -g 10000 -u 10000 harbor \</span><br><span class="line">    &amp;&amp; mkdir /harbor/</span><br><span class="line">COPY ./make/dev/adminserver/harbor_adminserver ./make/photon/adminserver/start.sh /harbor/</span><br><span class="line">HEALTHCHECK CMD curl --fail -s http://127.0.0.1:8080/api/ping || exit 1</span><br><span class="line"></span><br><span class="line">RUN chmod u+x /harbor/harbor_adminserver /harbor/start.sh</span><br><span class="line">WORKDIR /harbor/</span><br><span class="line">ENTRYPOINT [&quot;/harbor/start.sh&quot;]</span><br></pre></td></tr></table></figure></p>
<h2 id="telnet命令没有找到"><a href="#telnet命令没有找到" class="headerlink" title="telnet命令没有找到"></a>telnet命令没有找到</h2><p>解决方法： telnet(use SSH instead)</p>
<blockquote>
<p>The following Linux troubleshoot tools are neither installed on Photon OS by default nor available in the Photon OS repositories:<br>iostat<br>telnet (use SSH instead)<br>Iprm<br>hdparm<br>syslog (use journalctl instead)<br>ddd<br>ksysmoops<br>xev<br>GUI tools (because Photon OS has no GUI)</p>
</blockquote>
<h2 id="Why-is-netstat-not-working"><a href="#Why-is-netstat-not-working" class="headerlink" title="Why is netstat not working?"></a>Why is netstat not working?</h2><p>A. netstat is deprecated, ss or ip (part of iproute2) should be used instead.</p>
<p>For more information, see Use <a href="https://vmware.github.io/photon/assets/files/html/3.0/photon_admin/use-ip-and-ss-commands.html">ip and ss Commands</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以多看看<br><a href="https://github.com/vmware/photon/wiki/Frequently-Asked-Questions">Photon OS Frequently Asked Questions</a><br>这里面包含了许多常见问题</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://my.oschina.net/JasonZhang/blog/548023">harbor 官方github</a> </p>
<p><a href="https://www.paluszek.com/wp/2018/03/27/photon-os-no-ping-and-no-ecmp-replies-other-quick-hints-on-photon-too/">Photon OS – no ping and no ICMP replies? Other quick hints on Photon too.</a>  </p>
<p><a href="https://vmware.github.io/photon/assets/files/html/3.0/photon_troubleshoot/linux-troubleshooting-tools.html">Linux Troubleshooting Tools</a></p>
<p><a href="https://github.com/vmware/photon/wiki/Frequently-Asked-Questions">Photon OS Frequently Asked Questions</a></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>harbor</tag>
        <tag>photon</tag>
      </tags>
  </entry>
  <entry>
    <title>解决github网站无法打开的问题</title>
    <url>/2019/11/16/%E8%A7%A3%E5%86%B3github%E7%BD%91%E7%AB%99%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/06/U9fd1g.jpg" alt=""></p>
<span id="more"></span>
<p>本文主要记录github网站无法打开问题的解决方法，笔者两年前遇到过一次，当时通过搜索引擎解决了该问题，最近不知为啥又遇到了，搜了尝试好几个方法才最终解决，所以在此记录一下，但愿能帮助到跟我一样遇到同样问题的人。</p>
<h2 id="问题症状"><a href="#问题症状" class="headerlink" title="问题症状"></a>问题症状</h2><ol>
<li>首先电脑是能上网的，百度甚至谷歌都是OK的 : )</li>
<li>ping github.com全是超时，无法ping通</li>
</ol>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li>找到目录 C:\Windows\System32\drivers\etc 文件下的 hosts文件</li>
<li>拷贝到其他地方进行修改，在文件中添加（<strong>注意不要复制下面的IP，请自行根据下文重点进行IP查询,然后将IP改为你自己查到的IP</strong>）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.113.3     github.com</span><br><span class="line">199.232.69.194    github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>
<p>3.修改之后保存，再覆盖 C:\Windows\System32\drivers\etc目录下的hosts文件</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>上面添加的IP是因人而异的，如果你直接复制我上面的IP可能是无效的，需要自己查询对应的IP进行修改，查询地址为： <a href="http://github.global.ssl.fastly.net.ipaddress.com/"> http://github.global.ssl.fastly.net.ipaddress.com/</a><br>如下图：<br><img src="https://s1.ax1x.com/2020/07/06/U9fKpD.jpg" alt=""><br>可以在其搜索框中输入<strong>github.com</strong>来查询github的IP,然后修改hosts文件之后就好啦</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>修改之后可以在命令行中执行ipconfig /flushdns命令来刷新缓存。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://blog.csdn.net/u010377383/article/details/79365049">ping github 请求超时解决方案</a>     </p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>处理ECTD空间满的问题</title>
    <url>/2019/12/19/%E5%A4%84%E7%90%86ETCD%E7%A9%BA%E9%97%B4%E6%BB%A1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<span id="more"></span>
<p>本文主要介绍在使用etcd集群过程中遇到的空间满的问题的解决方法。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>切换到有etcd可执行文件的目录下：</p>
<p>xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx换成自己etcd集群的真实IP</p>
<p>查看当前状态<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./etcdctl --endpoints=xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx</span><br><span class="line"></span><br><span class="line">endpoint health</span><br></pre></td></tr></table></figure><br>处理etcd空间满的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export ETCDCTL_API=3</span><br><span class="line"></span><br><span class="line">./etcdctl --endpoints=http://127.0.0.1:2379 alarm list</span><br><span class="line"></span><br><span class="line">./etcdctl --write-out=table --endpoints=xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx endpoint status</span><br></pre></td></tr></table></figure>
<p>1.获取当前etcd数据的修订版本(revision)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rev=$(ETCDCTL_API=3 ./etcdctl --endpoints=:2379 endpoint status --write-out=&quot;json&quot; | egrep -o &#x27;&quot;revision&quot;:[0-9]*&#x27; | egrep -o &#x27;[0-9]*&#x27;)</span><br></pre></td></tr></table></figure><br>2.整合压缩旧版本数据<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 ./etcdctl compact $rev</span><br></pre></td></tr></table></figure><br>3.执行碎片整理<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./etcdctl --endpoints=http://xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx defrag</span><br></pre></td></tr></table></figure><br>4.取消告警信息<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./etcdctl --endpoints=http://xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx,xxx.xxx.xxx.xxx:xxxx alarm disarm</span><br></pre></td></tr></table></figure><br>根据实践发现只配置auto-compaction-retention只会做碎片整理，不会实际减少空间大小；　如果需要减少大小还是需要使用etcdctl compact 和　etcdctl defrag清理空间</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实可以将本文的步骤写成一个shell脚本然后放到crontab中去每天执行一次就OK了。</p>
]]></content>
      <categories>
        <category>问题处理</category>
      </categories>
      <tags>
        <tag>问题处理</tag>
        <tag>etcd</tag>
        <tag>分布式组件，问题定位</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算相关知识一</title>
    <url>/2019/10/20/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%B8%80/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/10/20/KQpzh6.jpg" alt=""></p>
<span id="more"></span>
<p>从本文开始准备开一个新坑，主要用于记录云计算相关的知识，主要参考资料为公开课Cloud Computing Concepts, Part 1。可以看做是学习记录 : )  </p>
<p>本文将尝试回答什么是cloud，与传统的分布式系统相比较，有什么新的特点cloud comupute与早期几代分布式系统的区别  </p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Process-a-program-in-action"><a href="#Process-a-program-in-action" class="headerlink" title="Process = a program in action"></a>Process = a program in action</h3><p><img src="https://s2.ax1x.com/2019/10/20/KMOOiD.jpg" alt=""></p>
<p>C语言的程序，main调用f1，f1调用f2程序代码是不变的，但是有变化的组件，那些变化的组件：   </p>
<ol>
<li>PC是程序计数器program counter,表明当前程序执行到哪了  </li>
<li>stack被函数用于传递参数和返回值，比如main调用f1时传递的参数就可以通过push压栈到stack中，然后f1可以通过pop获取到main传递给他的参数。  </li>
</ol>
<p>f1调用f2类似，当f2执行完毕，便可以通过push将执行结果压栈到stack顶，然后f1可以通过pop获取到f2的执行结果，类似的，main也可以获取到f1的执行结果</p>
<h3 id="简化的计算机架构"><a href="#简化的计算机架构" class="headerlink" title="简化的计算机架构"></a>简化的计算机架构</h3><p><img src="https://s2.ax1x.com/2019/10/20/KMOqIO.jpg" alt=""></p>
<p>两种云：私有云  公有云<br>私有云一般仅供公司内部使用<br>公有云是把服务提供给付费的用户使用，比如AWS S3,阿里云，华为云之类的公有云服务</p>
<h2 id="why-clouds？节约时间和金钱"><a href="#why-clouds？节约时间和金钱" class="headerlink" title="why clouds？节约时间和金钱"></a>why clouds？节约时间和金钱</h2><p><img src="https://s2.ax1x.com/2019/10/20/KMj64U.jpg" alt=""></p>
<p>如果你创办了一个公司，是使用公有云服务呢，还是自己搭建一套私有云？通常可以对比两者，看公司使用时间，如果在一年内，那使用公有云更划算，如果是使用多年，那使用私有云更划算。前期为了业务尽快上线，一般选用公有云，省时省力，当公司业务发展到一定水平，存储量业务量都很大的时候，这时候势必要上私有云了。</p>
<h2 id="什么是云"><a href="#什么是云" class="headerlink" title="什么是云"></a>什么是云</h2><p><img src="https://s2.ax1x.com/2019/10/20/KMjxbt.md.jpg" alt=""></p>
<blockquote>
<p>For the purposes of this course, however, I’m going to come up with a very simple definition, it’s a working definition. It’s not perfect. It’s not meant to be perfect. It’s meant to be good enough for us to learn more about the technologies that exist out there. So working definition says, that a Cloud consists of a lot of storage resources, so you can store gigabytes, terabytes, petabytes, maybe even more of data with compute cycles located nearby. Notice that this definition is not the reverse which is it doesn’t say, you have compute cycles with data moving around. Essentially, there is so much data. It is a data intensive world that we live in, that you can’t really move around the data all that easily. So, you need to bring the compute closer to the data rather than bring the data closer to where the computer is. </p>
</blockquote>
<p><img src="https://s2.ax1x.com/2019/10/20/KMz5bn.jpg" alt=""></p>
<h2 id="当今的云计算，与前几代的分布式系统比，不同的地方"><a href="#当今的云计算，与前几代的分布式系统比，不同的地方" class="headerlink" title="当今的云计算，与前几代的分布式系统比，不同的地方"></a>当今的云计算，与前几代的分布式系统比，不同的地方</h2><ul>
<li>超大规模</li>
<li>按需访问</li>
<li>数据密集性质</li>
<li>新的云计算程序模型<br><img src="https://s2.ax1x.com/2019/10/20/KQSEKH.jpg" alt=""><br>按需访问， 在这里我们会把它作为 aaS （即服务）行业分类的一部分来讨论。 按需访问是指 你为你已经实际使用的服务付费， 而不是支付预付成本， 或提前购买。 这就像是 叫了一辆出租车对比 租了一辆车，你需要 付一些预付款来使用 其他人已拥有的服务，或者买一辆车 相似的， 你买了自己的数据中心。 而现在，云服务让你可以 仅仅支付几十美分或几块钱来 购买CPU的运行小时， 你可以用任意你想拥有的CPU数量， 只要你的应用程序需要。 比如，AWS的EC2， 以及微软的Azure都能提供这种服务。 或者支付几十美分或几块钱 来购买每月的GB容量来存储数据。 同样的，AWS和Azure都能为你提供这种服务。 还有许多的其他公司 都能提供相似的服务，提供的条件也有竞争力。 现在整个行业经常为 提供的云服务进行分类， 按照这些服务本身的特性。 经常被分类成， aaS， “即服务” 概念。<br>HaaS硬件即服务、IaaS基础设计即服务，PaaS平台及服务，SaaS软件及服务。<br>云计算第三个新的方面， 今天云区别自身与 之前几代分布式系统的是 我们已经可以着手处理大数据。 然而在此之前， 是<strong>计算密集型</strong>处理技术， 比如基于消息传递接口、 即MPI的计算， 还有高性能计算技术， 当你有一个相对小的数据集的时候， 但是你仍然需要相当性能的密集型计算， 比如，天气模型就是一个密集型计算， 这里当然包括了 诸如NCSA Blue Waters 数据中心， 但是 数据密集型计算技术却有一点相反， 你有大量的数据存储在 数据中心， 而且你需要附近的计算节点， 是因为你要处理海量的数据。<br>在计算密集型的应用中，CPU利用率，被视为资源利用率 最主要的衡量指标， 但在数据密集型的云服务中， CPU已经不再是最主要的度量， I/O才是最重要的度量，disk I/O 和 network I/O。</li>
</ul>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="">Cloud Computing Concepts, Part 1</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB整体架构</title>
    <url>/2020/01/15/Leveldb%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/20/J3ZJpT.png" alt=""></p>
<span id="more"></span>
<p>从本文起开启一个新坑，进行LevelDB源码的阅读。本文主要介绍LevelDB的整体架构。<br>关于整体架构这块其实有很多文章都写的比较好，所以本文主要是搬运别人的文章，然后对文章进行稍微的修改，原始文章为：<a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">数据分析与处理之二（Leveldb 实现原理）</a></p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><blockquote>
<p>整体架构主要从静态角度来描述。<br>所谓的静态角度，我们可以假想整个存储系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等等；<br>从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。<br>LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么你会看到如下图的景象</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/04/20/J3mNw9.png" alt=""></p>
<p>从图中可以看出，构成 LevelDB 静态结构的包括六个主要部分：</p>
<ul>
<li>内存中的MemTable；</li>
<li>内存中的Immutable Memtable；</li>
<li>磁盘上的Manifest文件；</li>
<li>磁盘上的Current文件；</li>
<li>磁盘上的log文件；</li>
<li>磁盘上的SSTable文件。</li>
</ul>
<p>当然，LevelDB 除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是 LevelDB 的主体构成元素。<br>当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p>
<p>SSTable 就是由内存中的数据不断导出并进行 Compaction 操作后形成的，而且 SSTable 的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。</p>
<p>下面分别介绍上面提到的六个部分</p>
<h2 id="MemTable-与-Immutable-Memtable"><a href="#MemTable-与-Immutable-Memtable" class="headerlink" title="MemTable 与 Immutable Memtable"></a>MemTable 与 Immutable Memtable</h2><p>MemTable 与 Immutable Memtable均存在于内存中。<br>所有 KV 数据都是存储在 Memtable，Immutable Memtable 和 SSTable 中的，Immutable Memtable从结构上讲和 Memtable 是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而 Memtable 则是允许写入和读取的。当 Memtable 写入的数据占用内存到达指定数量，则自动转换为 Immutable Memtable，等待 Dump 到磁盘中，系统会自动生成新的 Memtable 供写操作写入新数据，理解了 Memtable，那么 Immutable Memtable 自然不在话下。</p>
<p>LevelDB 的 MemTable 提供了将 KV 数据写入，删除以及读取 KV 记录的操作接口，但是事实上 Memtable 并不存在真正的删除操作,删除某个Key的Value在 Memtable 内是作为插入一条记录实施的，但是会打上一个 Key 的删除标记，真正的删除操作是Lazy的，会在以后的 Compaction 过程中去掉这个KV。</p>
<p>需要注意的是，LevelDB 的 Memtable 中KV对是根据key大小有序存储的，在系统插入新的KV时，LevelDB 要把这个KV插到合适的位置上以保持这种 Key 有序性。其实，LevelDB 的 Memtable 类只是一个接口类，真正的操作是通过背后的 SkipList 来做的，包括插入操作和读取操作等，所以 Memtable 的核心数据结构是一个 SkipList。</p>
<p>SkipList是由 William Pugh 发明。他在 Communications of the ACM June 1990, 33(6) 668-676 发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。关于SkipList的详细介绍可以参考这篇文章:<a href="http://www.a-programmer.top/2018/06/03/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB--%E8%B7%B3%E8%B7%83%E8%A1%A8/">跳跃表 SkipList</a>与<a href="https://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html">跳表SkipList</a>。</p>
<h2 id="Mainifest文件"><a href="#Mainifest文件" class="headerlink" title="Mainifest文件"></a>Mainifest文件</h2><p>SSTable 中的某个文件属于特定层级，而且其存储的记录是 key 有序的，那么必然有文件中的最小 key 和最大 key，这是非常重要的信息，LevelDB 应该记下这些信息。manifest 就是干这个的，它记载了 SSTable 各个文件的管理信息，比如属于哪个 level，文件名称叫啥，最小 key 和最大 key 各自是多少。下图是 manifest 所存储内容的示意：<br><img src="https://img-blog.csdnimg.cn/20191215114340747.png#pic_center" alt=""><br>图中只显示了两个文件（manifest 会记载所有 SSTable 文件的这些信息），即 level 0 的 Test1.sst 和 Test2.sst 文件，同时记载了这些文件各自对应的 key 范围，比如 Test1.sst 的 key 范围是 “abc” 到 “hello”，而文件 Test2.sst 的 key 范围是 “bbc” 到 “world”，可以看出两者的 key 范围是有重叠的。</p>
<h2 id="Current文件"><a href="#Current文件" class="headerlink" title="Current文件"></a>Current文件</h2><p>这个文件的内容只有一个信息，就是记载当前的 manifest 文件名。因为在 LevleDB 的运行过程中，随着 compaction 的进行，SSTable 文件会发生变化，会有新的文件产生，老的文件被废弃，manifest 也会跟着反映这种变化，此时往往会新生成 manifest 文件来记载这种变化，而 current 则用来指出哪个 manifest 文件才是我们关心的那个 manifest文件。</p>
<h2 id="LOG文件"><a href="#LOG文件" class="headerlink" title="LOG文件"></a>LOG文件</h2><p>log 文件在 LevelDB 中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的 memtable 之前，会先写入 log 文件，这样即使系统发生故障，memtable 中的数据没有来得及 dump 到磁盘的 SSTable 文件，LevelDB 也可以根据 log 文件恢复内存的 Memtable 数据结构内容，不会造成系统丢失数据。</p>
<p>LevelDB 对于一个 log 文件，会把它切割成以 32K 为单位的物理 Block，每次读取以一个 Block 作为基本读取单位，下图展示的 log 文件由3个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。<br><img src="https://img-blog.csdnimg.cn/20191215114558676.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""><br>log 文件中的数据是以 block 为单位组织，写日志时，处于一致性考虑并没有按 block 单位写，每次更新均对 log 文件进行 IO，每次更新写入作为一个 record，每条 record 的结构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191215114653955.png#pic_center" alt=""></p>
<p><strong>checksum</strong><br>记录的是 “type” 和 “data” 字段的CRC校验，为了避免处理不完整或者是被破坏的数据，当 LevelDB 读取记录数据时候会对数据进行校验，如果发现和存储的 checksum 相同，说明数据完整无破坏，可以继续后续流程。<br><strong>length</strong><br>记录的是 record 内保存的 data 长度(小端对齐)。<br><strong>data</strong><br>记录的是 Key:Value 数值对<br><strong>type</strong><br>type字段则指出了每条记录的逻辑结构和 log 文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL, FIRST, MIDDLE, LAST。如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p>
<p>举例：<br>假设目前存在三条记录，Record A，Record B 和 Record C，其中 Record A 大小为10K，Record B 大小为80K，Record C大小为<strong>4K</strong>，那么其在 log 文件中的逻辑布局会如上面的图所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为<strong>4K</strong>，Block 3剩下的空间(<strong>6K</strong>)足以全部放下它，所以其类型标识为FULL。</p>
<p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDB一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p>
<h2 id="SSTable文件"><a href="#SSTable文件" class="headerlink" title="SSTable文件"></a>SSTable文件</h2><p>LevelDB 不同层级有很多 SSTable 文件（以后缀.sst为特征），所有 .sst 文件内部布局都是一样的。上节介绍 log 文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：log文件中的记录是 Key 无序的，即先后记录的 key 大小没有明确大小关系，而 .sst 文件内部则是根据记录的 Key 由小到大排列的。<br><img src="https://img-blog.csdnimg.cn/20191215115112192.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""><br>上图展示了一个 .sst 文件的物理划分结构，同 log 文件一样，也是划分为固定大小的存储块，每个 Block 分为三个部分：</p>
<p>数据存储区；<br>Type 区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩）；<br>CRC校验则是数据校验码，用于判别数据在生成和传输中是否出错。<br>以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。下图展示了.sst文件的内部逻辑解释。<br><img src="https://img-blog.csdnimg.cn/20191215115258766.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>从上图可以看出，从大的方面，可以将 .sst文 件划分为数据存储区和数据管理区，</p>
<p>数据存储区存放实际的 key-value 数据;<br>数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。<br>两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储 KV 数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：Meta Block，MetaBlock 索引和数据索引块以及一个文件尾部块。</p>
<ul>
<li><p>Data block：实际存储的 KV 数据。  </p>
</li>
<li><p>Meta block：每个 Data block 对应一个 Meta block，保存 Data block 中的 key size/value size/kv counts 之类的统计信息。   </p>
</li>
<li><p>Metablock index：保存 Meta block 的索引信息(后续会看到主要用于filter)。</p>
</li>
<li><p>Index block：保存每个 Data block 的 last_key 及其在 SSTable 文件中的索引。block 中 entry 的 key 即是 last_key(依赖于FindShortestSeparator()/FindShortSuccessor()的实现)，value即是该Data block的BlockHandler（offset/size）。</p>
</li>
<li><p>Footer：文件末尾固定长度的数据。保存着 metaindex_block 和 index_block 的索引信息(BlockHandler)，为达到固定的长度，添加 padding_bytes。最后有8个字节的 magic 校验。<br>footer 的结构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191215115938250.png#pic_center" alt=""></p>
</li>
<li><p>metaindex_block_handle：指出了 metaindex block 的起始位置和大小；</p>
</li>
<li><p>index_block_handle：指出了 index Block 的起始地址和大小；</p>
</li>
<li><p>padding_bytes：为达到固定的长度填充使用；</p>
</li>
<li><p>magic：用于检验。</p>
</li>
</ul>
<p>metaindex_block_handle、index_block_handle，这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的。<br>下图是数据索引块的内部结构示意图：<br><img src="https://img-blog.csdnimg.cn/20191215230402224.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>Data Block 内的 KV 记录是按照 key 由小到大排列的，数据索引区的每条记录是对某个 Data Block 建立的索引信息，每条索引信息包含三个内容。以上图所示的数据块 i 的索引 index i 来说：</p>
<p>第一个字段：记录大于等于数据块i中最大的 key 值的那个 key。在索引里保存的这个 key 值未必一定是某条记录的 key，以上的例子来说，假设数据块i的最小key=“samecity”，最大key=“the best”；数据块i+1的最小key=“the fox”，最大key=“zoo”，那么对于数据块i的索引 index i 来说，其第一个字段记载大于等于数据块i的最大Key(“the best”) 同时要小于数据块i+1的最小Key(“the fox”)，所以例子中 index i 的第一个字段是 “the c”，这个是满足要求的；而 index i+1 的第一个字段则是 “zoo”，即数据块i+1的最大 key。</p>
<p>第二个字段：指出数据块 i 在 .sst 文件中的起始位置。</p>
<p>第三个字段：指出 Data Block i 的大小（有时候是有数据压缩的）。</p>
<p>上面主要介绍的是数据管理区的内部结构，下图是数据区的一个 Block 的数据部分布局：<br><img src="https://img-blog.csdnimg.cn/20191215230627962.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>从图中可以看出，其内部也分为两个部分，前面是一个个 KV 记录，其顺序是根据 key 值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point），其实是一些指针，指出 Block 内容中的一些记录位置。</p>
<p>“重启点”是干什么的呢？Block内容里的KV记录是按照 key 大小有序的，这样的话，相邻的两条记录很可能 key 部分存在重叠，比如 key i=“the Car”，Key i+1=“the color”，那么两者存在重叠部分 “the c”，为了减少 key 的存储量，Key i+1 可以只存储和上一条 key 不同的部分 “olor”，两者的共同部分从 key i 中可以获得。记录的 key 在 Block 内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的 key 部分，而是重新记录所有的 key 值，假设 key i+1 是一个重启点，那么 key 里面会完整存储 “the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。<br>其中记录的格式如下所示：<br><img src="https://img-blog.csdnimg.cn/20191215230759119.png#pic_center" alt=""></p>
<p>每个记录包含5个字段：</p>
<ul>
<li>key共享长度：比如上面的 “olor” 记录， 其 key 和上一条记录共享的 key 部分长度是 “the c” 的长度，即5；</li>
<li>key非共享长度：对于“olor”来说，是4；</li>
<li>value长度：指出 key-value 中 value 的长度，在后面的 value 内容字段中存储实际的 value 值；</li>
<li>key非共享内容：指实际存储 “olor” 这个 key 字符串；</li>
<li>value内容：存储实际的 value 值。</li>
</ul>
<p>后续文章会针对SSTable有更细的结构说明。</p>
<h2 id="读记录"><a href="#读记录" class="headerlink" title="读记录"></a>读记录</h2><p>因为写入操作比较简单就不介绍了，LevelDB 的读取流程如下所示：<br><img src="https://img-blog.csdnimg.cn/2019121523120787.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>LevelDB 首先会去查看内存中的 Memtable，如果 Memtable 中包含 key 及其对应的value，则返回 value 值即可；</p>
<p>如果在 Memtable 没有读到key，则接下来到同样处于内存中的 Immutable Memtable 中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。</p>
<p>因为SSTable数量较多，而且分成多个level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于 level 0 的文件中查找，如果找到则返回对应的value值，如果没有找到那么到 level 1 中的文件中去找，如此循环往复，直到在某层 SSTable 文件中找到这个 key 对应的 value 为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p>
<p>如果给定一个要查询的 key 和某个 key range 包含这个key的 SSTable 文件，那么 LevelDB 是如何进行具体查找过程的呢？LevelDB 一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后 LevelDB 根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的 SSTable 文件并不包含这个key，所以到下一级别的 SSTable 中去查找。</p>
<h2 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a>Compaction</h2><p>LevelDB 包含其中两种 compaction 模式：minor 和 major。所谓 minor Compaction，就是把 memtable 中的数据导出到 SSTable 文件中；major compaction 就是合并不同层级的 SSTable 文件。</p>
<h3 id="minor-Compaction"><a href="#minor-Compaction" class="headerlink" title="minor Compaction"></a>minor Compaction</h3><p>Minor compaction 的目的是当内存中的 memtable 大小到了一定值时，将内容保存到磁盘文件中。其机理如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191215231428295.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>当 memtable 数量到了一定程度会转换为 immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable 其实是一个多层级队列SkipList，其中的记录是根据 key 有序排列的。所以这个 minor compaction 实现起来也很简单，就是按照 immutable memtable 中记录由小到大遍历，并依次写入一个 level 0 的新建 SSTable 文件中，写完后建立文件的 index 数据，这样就完成了一次minor compaction。</p>
<p>从上图中也可以看出，对于被删除的记录，在 minor compaction 过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉 key 记录，但是这个 KV 数据在哪里？那需要复杂的查找，所以在 minor compaction 的时候并不做删除，只是将这个 key 作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的 compaction 中会去做。</p>
<h3 id="major-Compaction"><a href="#major-Compaction" class="headerlink" title="major Compaction"></a>major Compaction</h3><p>当某个 level 下的 SSTable 文件数目超过一定设置值后，levelDB 会从这个 level 的 SSTable 中选择一个文件（level&gt;0），将其和高一层级的 level+1 的 SSTable 文件合并，这就是 major compaction。</p>
<p>在大于 0 的层级中，每个 SSTable 文件内的key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。level 0 的 SSTable 文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为 level 0 的文件是通过 minor compaction 直接生成的，所以任意两个 level 0下的两个 SSTable 文件可能再key范围上有重叠。所以在做 major compaction 的时候，对于大于 level 0 的层级，选择其中一个文件就行，但是对于 level 0 来说，指定某个文件后，本 level 中很可能有其他 SSTable 文件的 key 范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和 level 1 的文件进行合并，即 level 0 在进行文件选择的时候，可能会有多个文件参与 major compaction。</p>
<p>LevelDB 在选定某个 level 进行 compaction 后，还要选择是具体哪个文件要进行 compaction，LevelDB 在这里有个小技巧， 就是说轮流来，比如这次是文件A进行 compaction，那么下次就是在 key range 上紧挨着文件A的文件B进行 compaction，这样每个文件都会有机会轮流和高层的 level 文件进行合并。</p>
<p>如果选好了 level i 的文件A和 level i+1 层的文件进行合并，那么问题又来了，应该选择 level i+1 哪些文件进行合并？LevelDB 选择 i+1 层中和文件A在 key range 上有重叠的所有文件来和文件A进行合并。</p>
<p>也就是说，选定了 level i 的文件A，之后在 level i+1 中找到了所有需要合并的文件B,C,D… 等等。剩下的问题就是具体是如何进行 major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的 KV 数据。</p>
<p>下图所示的是合并过程：<br><img src="https://img-blog.csdnimg.cn/20191215231909260.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>major compaction 的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入 level i+1 层中新生成的一个 SSTable 文件中。就这样对KV数据一一处理，形成了一系列新的 i+1 层数据文件，之前的 i 层文件和 i+1 层参与 compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了 i 层和 i+1 层文件记录的合并过程。</p>
<p>那么在 major compaction 过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于 i 层中存在这个key，那么这个KV在major compaction 过程中可以抛掉。因为，对于层级低于 i 的文件中如果存在同一 key 的记录，那么说明对于 key 来说，有更新鲜的 value 存在，那么过去的 value 就等于没有意义了，所以可以删除。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>读取操作如果没有在内存的 memtable 中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在 level 0 中最新的文件中找到了这个 key，那么也需要读取2次磁盘，一次是将 SSTable 的文件中的 index 部分读入内存，这样根据这个 index 可以确定 key 是在哪个 block 中存储；第二次是读入这个 block 的内容，然后在内存中查找 key 对应的 value。</p>
<p>LevelDB 中引入了两个不同的 Cache:Table Cache 和 Block Cache。其中 Block Cache 是配置可选的，即在配置文件中指定是否打开这个功能。</p>
<p>下图是 table cache 的结构：<br><img src="https://img-blog.csdnimg.cn/20191215232034452.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0g1MTQ0MzQ0ODU=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>在 Cache 中，key值是 SSTable 的文件名称，value 部分包含两部分，一个是指向磁盘打开的 SSTable 文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个 SSTable 文件对应的 Table 结构指针，table结构在内存中，保存了 SSTable 的 index 内容以及用来指示 block cache 用的 cache_id ，当然除此外还有其它一些内容。</p>
<p>比如在 get(key) 读取操作中，如果 LevelDB 确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，LevelDB 会首先查找 Table Cache，看这个文件是否在缓存里，如果找到了，那么根据 index 部分就可以查找是哪个 block 包含这个 key。如果没有在缓存中找到文件，那么打开 SSTable 文件，将其 index 部分读入内存，然后插入 Cache 里面，去 index 里面定位哪个 block 包含这个 key 。如果确定了文件哪个 block 包含这个 key，那么需要读入 block 内容，这是第二次读取。<br><img src="https://img-blog.csdnimg.cn/20191215232120774.png#pic_center" alt=""></p>
<p>Block Cache是为了加快这个过程的。上图是block cache 的结构。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p>
<p>如果 LevelDB发现这个 block 在 block cache 中，那么可以避免读取数据，直接在 cache 里的 block 内容里面查找key的value就行，如果没找到呢？那么读入 block 内容并把它插入 block cache 中。LevelDB 就是这样通过两个 cache 来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p>
<h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><p><strong>Version</strong>：保存了当前磁盘以及内存中所有的文件信息，一般只有一个 Version 叫做 “current” version（当前版本）。LevelDB还保存了一系列的历史版本，这些历史版本有什么作用呢？</p>
<p>当一个 Iterator 创建后，Iterator 就引用到了 current version(当前版本)，只要这个 Iterator 不被 delete 那么被 Iterator 引用的版本就会一直存活。这就意味着当你用完一个 Iterator 后，需要及时删除它。</p>
<p>当一次 Compaction 结束后（会生成新的文件，合并前的文件需要删除），LevelDB 会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p>
<p><strong>VersionSet</strong>： 是所有 Version的集合，管理着所有存活的 Version。</p>
<p><strong>VersionEdit</strong> ：表示 Version 之间的变化，相当于 delta 增量，表示有增加了多少文件，删除了文件。他们之间的关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Version0 +VersionEdit--&gt;Version1</span><br></pre></td></tr></table></figure>
<p>VersionEdit 会保存到 manifest 文件中，当做数据恢复时就会从 manifest 文件中读出来重建数据。</p>
<p>LevelDB 的这种版本的控制，让我想到了双 buffer 切换，双 buffer 切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。</p>
<p>比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个 buffer，将新的字典库加载到这个新 buffer 中，等到加载完毕，将字典的指针指向新的字典库。</p>
<p>LevelDB 的 version 管理和双 buffer 切换类似，但是如果原 version 被某个 iterator 引用，那么这个 version 会一直保持，直到没有被任何一个 iterator 引用，此时就可以删除这个 version。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">数据分析与处理之二（Leveldb 实现原理）</a><br><a href="https://zhuanlan.zhihu.com/p/80529047">LevelDb 源码阅读–写操作</a>   </p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码阅读 -- PUT流程</title>
    <url>/2020/01/20/Leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20--%20PUT%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/20/J3ZJpT.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍leveldb的put流程。</p>
<ul>
<li>整体架构</li>
<li>LOG文件</li>
<li>Put流程</li>
</ul>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><blockquote>
<p>整体架构主要从静态角度来描述。<br>所谓的静态角度，我们可以假想整个存储系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等等；<br>从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。<br>LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么你会看到如下图的景象</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/04/20/J3mNw9.png" alt=""></p>
<p>当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p>
<p>SSTable 就是由内存中的数据不断导出并进行 Compaction 操作后形成的，而且 SSTable 的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。</p>
<p>在图中我们可以看到，内存中有MemTable, Immutable memtable，磁盘中有LOG文件，Manifest文件,Current文件，以及SSTable。这些文件或者内存结构在后续的文章中会详细介绍。本文介绍Put流程，就先介绍LOG文件</p>
<h2 id="LOG文件"><a href="#LOG文件" class="headerlink" title="LOG文件"></a>LOG文件</h2><p>首先请看LOG文件相关的代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STORAGE_LEVELDB_DB_LOG_FORMAT_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STORAGE_LEVELDB_DB_LOG_FORMAT_H_</span></span><br><span class="line"></span><br><span class="line">namespace leveldb &#123;</span><br><span class="line">namespace <span class="built_in">log</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RecordType</span> &#123;</span></span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kMaxRecordType = kLastType;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kBlockSize = <span class="number">32768</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kHeaderSize = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><br>LOG文件在leveldb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入LOG文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据LOG文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。(PS:实际代码实现时，p写文件也可以通过参数控制是立马刷盘还是交由操作系统自行控制，也就是说交由系统控制的话，也是可能会存在丢数据的情况)</p>
<p>通过上面的代码可以看出LOG文件的物理布局就是由连续的 32K 大小 Block 构成的。<br>物理布局如下图：<br><img src="https://s1.ax1x.com/2020/04/21/J3nBAs.md.png" alt="物理布局"><br>在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在leveldb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理，下图显示了记录头的结构：<br><img src="https://s1.ax1x.com/2020/04/21/J3uVEj.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksum: uint32           // type及data[]对应的crc32值</span><br><span class="line">length:   uint16           // 数据长度</span><br><span class="line">type:     uint8            // FULL/FIRST/MIDDLE/LAST中的一种</span><br><span class="line">data:     uint8[length]    // 实际存储的数据</span><br></pre></td></tr></table></figure>
<p>类型存在4种：</p>
<p>kFullType ： 顾名思义记录完全在一个block中<br>kFirstType ： 当前block容纳不下所有的内容，记录的第一片在本block中<br>kMiddleType ： 记录的内容的起始位置不在本block，结束未知也不在本block<br>kLastType ： 记录的内容起始位置不在本block，但 结束位置在本block</p>
<h2 id="PUT流程"><a href="#PUT流程" class="headerlink" title="PUT流程"></a>PUT流程</h2><p><img src="https://s1.ax1x.com/2020/04/20/J3EOxg.png" alt=""><br>简单的说:其实PUT流程就两步，一写LOG, 二写(插入)memtable:  </p>
<ol>
<li>数据首先会被写到 log，保证持久性；  </li>
<li>然后写入 mutable memtable 中，返回；</li>
<li>当 mutable 内存到达一定大小之后就会变成 immutable memtable；  </li>
<li>当到达一定的条件后，后台的 Compaction 线程会把 immutable memtable 刷到盘中 Level 0 中 sstable；  </li>
<li>当 level i 到一定条件后，就会和 level i+1 中的 sstable 进行 Compaction，合并成 level i+1 的 sst 文件</li>
</ol>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>主要调用顺序大体就3步：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBImpl::Put -&gt; DB::Put -&gt; DBImpl::Write</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* updates) &#123;</span><br><span class="line">  Writer w(&amp;mutex_);</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = false;</span><br><span class="line"></span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line">  writers_.push_back(&amp;w);</span><br><span class="line">  while (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">    w.cv.Wait();</span><br><span class="line">  &#125;</span><br><span class="line">  if (w.done) &#123;</span><br><span class="line">    return w.status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // May temporarily unlock and wait.</span><br><span class="line">  Status status = MakeRoomForWrite(updates == nullptr);</span><br><span class="line">  uint64_t last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  if (status.ok() &amp;&amp; updates != nullptr) &#123;  // nullptr batch is for compactions</span><br><span class="line">    WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">    WriteBatchInternal::SetSequence(write_batch, last_sequence + 1);</span><br><span class="line">    last_sequence += WriteBatchInternal::Count(write_batch);</span><br><span class="line"></span><br><span class="line">    // Add to log and apply to memtable.  We can release the lock</span><br><span class="line">    // during this phase since &amp;w is currently responsible for logging</span><br><span class="line">    // and protects against concurrent loggers and concurrent writes</span><br><span class="line">    // into mem_.</span><br><span class="line">    &#123;</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line">      bool sync_error = false;</span><br><span class="line">      if (status.ok() &amp;&amp; options.sync) &#123;</span><br><span class="line">        status = logfile_-&gt;Sync();</span><br><span class="line">        if (!status.ok()) &#123;</span><br><span class="line">          sync_error = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (status.ok()) &#123;</span><br><span class="line">        status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      if (sync_error) &#123;</span><br><span class="line">        // The state of the log file is indeterminate: the log record we</span><br><span class="line">        // just added may or may not show up when the DB is re-opened.</span><br><span class="line">        // So we force the DB into a mode where all future writes fail.</span><br><span class="line">        RecordBackgroundError(status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (write_batch == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line"></span><br><span class="line">    versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line">    Writer* ready = writers_.front();</span><br><span class="line">    writers_.pop_front();</span><br><span class="line">    if (ready != &amp;w) &#123;</span><br><span class="line">      ready-&gt;status = status;</span><br><span class="line">      ready-&gt;done = true;</span><br><span class="line">      ready-&gt;cv.Signal();</span><br><span class="line">    &#125;</span><br><span class="line">    if (ready == last_writer) break;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Notify new head of write queue</span><br><span class="line">  if (!writers_.empty()) &#123;</span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先生成一个Writer，然后抢一个mutex锁，多线程的写入会在这里互斥，只能有一个进来，第一个进来的写操作会在真正写log文件和写memtable的时候把锁放掉，这时候别的写操作会进来把自己push到writes_的deque中，然后睡在自己的条件锁上，因为此时自己的done不是true并且自己不是deque中的第一个writer。等第一个writer全部操作完之后呢，会把此时deque中的所有writer唤醒,这里可能要问了，为什么醒了之后第一步是判断自己是不是done呢，自己还没执行怎么可能会done呢，其实这是leveldb的优化，当前抢到锁进来的writer会在真正操作之前把此时deque中所有的writer的任务都拿过来（实际上不是全拿过来，有数量限制，在BuildBatchGroup函数中有明确的过程），然后一起做了，并且把结果放回至每个writer对应的status中，最后再唤醒所有writer，所以这些writer醒来后发现自己的任务已经被做了，就直接拿自己的返回值返回了。</p>
<p>另外值得一提的是，条件变量与互斥锁之间的使用，直接上代码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct DBImpl::Writer &#123;</span><br><span class="line">  explicit Writer(port::Mutex* mu)</span><br><span class="line">      : batch(nullptr), sync(false), done(false), cv(mu) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Status status;</span><br><span class="line">  WriteBatch* batch;</span><br><span class="line">  bool sync;</span><br><span class="line">  bool done;</span><br><span class="line">  port::CondVar cv;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>就是代码中传入了互斥锁mu，如果不传这个的锁，会出现多线程中一个容易犯的问题：<strong>唤醒丢失</strong>问题，具体可以参考<a href="https://zhuanlan.zhihu.com/p/55123862">条件变量 之 稀里糊涂的锁</a></p>
<p><strong>写入前检查：MakeRoomForWrite</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::MakeRoomForWrite</span><span class="params">(<span class="type">bool</span> force)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!writers_.<span class="built_in">empty</span>());</span><br><span class="line">  <span class="type">bool</span> allow_delay = !force;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bg_error_.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// Yield previous error</span></span><br><span class="line">      s = bg_error_;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;<span class="built_in">NumLevelFiles</span>(<span class="number">0</span>) &gt;=</span><br><span class="line">                                  config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">      <span class="comment">// We are getting close to hitting a hard limit on the number of</span></span><br><span class="line">      <span class="comment">// L0 files.  Rather than delaying a single write by several</span></span><br><span class="line">      <span class="comment">// seconds when we hit the hard limit, start delaying each</span></span><br><span class="line">      <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></span><br><span class="line">      <span class="comment">// this delay hands over some CPU to the compaction thread in</span></span><br><span class="line">      <span class="comment">// case it is sharing the same core as the writer.</span></span><br><span class="line">      mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">      env_-&gt;<span class="built_in">SleepForMicroseconds</span>(<span class="number">1000</span>);</span><br><span class="line">      allow_delay = <span class="literal">false</span>;  <span class="comment">// Do not delay a single write more than once</span></span><br><span class="line">      mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line">               (mem_-&gt;<span class="built_in">ApproximateMemoryUsage</span>() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">      <span class="comment">// There is room in current memtable</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// We have filled up the current memtable, but the previous</span></span><br><span class="line">      <span class="comment">// one is still being compacted, so we wait.</span></span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Current memtable full; waiting...\n&quot;</span>);</span><br><span class="line">      background_work_finished_signal_.<span class="built_in">Wait</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;<span class="built_in">NumLevelFiles</span>(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">      <span class="comment">// There are too many level-0 files.</span></span><br><span class="line">      <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Too many L0 files; waiting...\n&quot;</span>);</span><br><span class="line">      background_work_finished_signal_.<span class="built_in">Wait</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></span><br><span class="line">      <span class="built_in">assert</span>(versions_-&gt;<span class="built_in">PrevLogNumber</span>() == <span class="number">0</span>);</span><br><span class="line">      <span class="type">uint64_t</span> new_log_number = versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">      WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line">      s = env_-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// Avoid chewing through file number space in a tight loop.</span></span><br><span class="line">        versions_-&gt;<span class="built_in">ReuseFileNumber</span>(new_log_number);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> log_;</span><br><span class="line">      <span class="keyword">delete</span> logfile_;</span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">      log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">      imm_ = mem_;</span><br><span class="line">      has_imm_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">      mem_ = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">      mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      force = <span class="literal">false</span>;  <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line">      <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>写入检查流程可以归结为下图：<br><img src="https://s1.ax1x.com/2020/04/21/J3lPij.jpg" alt=""></p>
<p>关于PUT流程暂且写这么多，如果想了解更多可以阅读参考资料。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">数据分析与处理之二（Leveldb 实现原理）</a><br><a href="https://zhuanlan.zhihu.com/p/80529047">LevelDb 源码阅读–写操作</a><br><a href="https://kernelmaker.github.io/Leveldb_Put">Leveldb之Put实现</a><br><a href="https://zhuanlan.zhihu.com/p/55123862">条件变量 之 稀里糊涂的锁</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么存在大端模式小端模式，为什么没有统一成一个标准</title>
    <url>/2020/01/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E5%A4%A7%E7%AB%AF%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E7%BB%9F%E4%B8%80%E6%88%90%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/19/JuoxHO.png" alt=""></p>
<span id="more"></span>
<p>本文主要回顾一个计算机中的基础知识，字节序的大端模式与小端模式。</p>
<ul>
<li>什么是小端模式</li>
<li>什么是大端模式</li>
<li>为什么没有统一成一个标准 </li>
<li>网络字节序</li>
</ul>
<h2 id="为什么存在大端模式小端模式"><a href="#为什么存在大端模式小端模式" class="headerlink" title="为什么存在大端模式小端模式"></a>为什么存在大端模式小端模式</h2><p>计算机系统中内存是以字节为单位进行编址的，每个地址单元都唯一的对应着1个字节（8 bit）。这可以应对char类型数据的存储要求，因为char类型长度刚好是1个字节，但是有些类型的长度是超过1个字节的（字符串虽然是多字节的，但它本质是由一个个char类型组成的类似数组的结构而已），比如C/C++中，short类型一般是2个字节，int类型一般4个字节等。因此这里就存在着一个如何安排多个字节数据中各字节存放顺序的问题。正是因为不同的安排顺序导致了<strong>大端存储模式</strong>和<strong>小端存储模式</strong>的存在。</p>
<h2 id="小端模式"><a href="#小端模式" class="headerlink" title="小端模式"></a>小端模式</h2><p>小端模式：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。<br>简单的说就是<strong>低地址存低位，高地址存高位</strong></p>
<p>为了方便说明，使用16进制表示这两个数，即0x12345678和0x11223344。小端模式采用以下方式存储这个两个数字：</p>
<p><img src="https://s1.ax1x.com/2020/04/19/JuLxbt.png" alt=""></p>
<h2 id="大端模式"><a href="#大端模式" class="headerlink" title="大端模式"></a>大端模式</h2><p>大端模式：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。<br>简单的上，就是<strong>低地址存高位，高地址存低位</strong>（跟人读写数值的顺序一样）<br>为了方便说明，使用16进制表示这两个数，即0x12345678和0x11223344。大端模式采用以下方式存储这个两个数字：</p>
<p><img src="https://s1.ax1x.com/2020/04/19/JuOSVP.png" alt=""></p>
<h2 id="为什么没有统一成一个标准"><a href="#为什么没有统一成一个标准" class="headerlink" title="为什么没有统一成一个标准"></a>为什么没有统一成一个标准</h2><p>一言以蔽之，这两种模式各有各的优点。</p>
<p><strong>小端模式优点</strong>：</p>
<ol>
<li>内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（注解：比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）；   </li>
<li>CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效</li>
</ol>
<p><strong>大端模式优点</strong>：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小</p>
<p>其各自的优点就是对方的缺点，正因为两者彼此不分伯仲，再加上一些硬件厂商的坚持，因此在多字节存储顺序上始终没有一个统一的标准</p>
<h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>不同的计算机使用的字节序可能不同，即有可能有的使用大端模式有的使用小端模式。那使用不同字节序模式的计算机如何进行通信呢？  （目前个人PC大部分都是X86的小端模式）<br>TCP/IP协议隆重出场，RFC1700规定使用“大端”字节序为网络字节序，其他不使用大端的计算机要注意了，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。这样就与CPU、操作系统无关了，实现了网络通信的标准化。</p>
<p>为了程序的兼容，你会看到，程序员们每次发送和接收数据都要进行转换，这样做的目的是保证代码在任何计算机上执行时都能达到预期的效果。</p>
<p>这么常用的操作，BSD Socket提供了封装好的转换接口，方便程序员使用。<br>包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
<h2 id="C语言判断一个当前计算机是使用大端模式还是小端模式"><a href="#C语言判断一个当前计算机是使用大端模式还是小端模式" class="headerlink" title="C语言判断一个当前计算机是使用大端模式还是小端模式"></a>C语言判断一个当前计算机是使用大端模式还是小端模式</h2><p>下面的一段代码可以用来判断计算机是大端的还是小端的，判断的思路是确定一个多字节的值（下面使用的是4字节的整数），将其写入内存（即赋值给一个变量），然后用指针取其首地址所对应的字节（即低地址的一个字节），判断该字节存放的是高位还是低位，高位说明是Big endian，低位说明是Little endian。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line">  <span class="type">char</span> *c = (<span class="type">char</span>*)&amp;x;</span><br><span class="line">  <span class="keyword">if</span> (*c == <span class="number">0x78</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Little endian&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Big endian&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他的信息，包括那个故事，请阅读参考资料</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节顺序–维基百科</a><br><a href="https://zhuanlan.zhihu.com/p/21388517">“字节序”是个什么鬼？</a><br><a href="https://jocent.me/2017/07/25/big-little-endian.html">大小端存储模式精解</a></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>查缺补漏</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码阅读 -- Log Writer</title>
    <url>/2020/01/25/Leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20--%20Log%20Writer%20/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/26/J6K7wT.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍leveldb的Log Writer</p>
<h2 id="LOG文件"><a href="#LOG文件" class="headerlink" title="LOG文件"></a>LOG文件</h2><p>LOG文件在leveldb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入LOG文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据LOG文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。(PS:实际代码实现时，p写文件也可以通过参数控制是立马刷盘还是交由操作系统自行控制，也就是说交由系统控制的话，也是可能会存在丢数据的情况)<br><img src="https://s1.ax1x.com/2020/04/26/J6Mgnx.jpg" alt=""></p>
<p>通过上面的代码可以看出LOG文件的物理布局就是由连续的 32K 大小 Block 构成的。<br>物理布局如下图：<br><img src="https://s1.ax1x.com/2020/04/21/J3nBAs.md.png" alt="物理布局"><br>在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在leveldb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理，下图显示了记录头的结构：<br><img src="https://s1.ax1x.com/2020/04/21/J3uVEj.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksum: uint32           // type及data[]对应的crc32值</span><br><span class="line">length:   uint16           // 数据长度</span><br><span class="line">type:     uint8            // FULL/FIRST/MIDDLE/LAST中的一种</span><br><span class="line">data:     uint8[length]    // 实际存储的数据</span><br></pre></td></tr></table></figure>
<p>类型存在4种：</p>
<p>kFullType ： 顾名思义记录完全在一个block中<br>kFirstType ： 当前block容纳不下所有的内容，记录的第一片在本block中<br>kMiddleType ： 记录的内容的起始位置不在本block，结束未知也不在本block<br>kLastType ： 记录的内容起始位置不在本block，但 结束位置在本block</p>
<h2 id="log-writer-cc注释"><a href="#log-writer-cc注释" class="headerlink" title="log_writer.cc注释"></a>log_writer.cc注释</h2><p><img src="https://s1.ax1x.com/2020/04/26/J6K0SA.png" alt=""></p>
<p>leveldb主要想解决的问题就是想尽量地把随机写改成顺序写。写入一个数据时，如果其大小超过32K，那么一个block是无法放下的，所以才有了记录的头部来进行管理，要不然也不知道哪个数据是哪个数据啊。具体代码逻辑见上面的注释。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">数据分析与处理之二（Leveldb 实现原理）</a><br><a href="https://www.a-programmer.top/2020/01/20/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89PUT%E6%B5%81%E7%A8%8B/">leveldb源码阅读（一）PUT流程</a><br><a href="https://zhuanlan.zhihu.com/p/35134533">LevelDB源码解析7. 日志格式</a><br><a href="https://zhuanlan.zhihu.com/p/44023605">LevelDB源码解析11. 7个byte</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码阅读 -- Version</title>
    <url>/2020/03/15/LevelDB%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20--%20Version/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/04/gmjpgP.jpg" alt=""></p>
<span id="more"></span>
<p>本文主要介绍LevelDB中的Version及其相关的结构和流程。</p>
<p>理解Version对理解LevelDB中compaction有很重要的作用，可以说不理解Version就无法理解Compaction。Version和Compaction互相联系，相互作用。Version，直观上理解就是版本，也就是说LevelDB中数据是可能是多版本共存的，所以在介绍Version具体相关的数据结构之前，我们先看一下MVCC。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>Multi-version Cocurrent Control，多版本并发控制。MVCC 技术最初也是在数据库</p>
<p>系统中被提出，但这种思想并不局限于单机的分布式系统，在分布式系统中同样有效。</p>
<p>顾名思义，MVCC 即多个不同版本的数据实现并发控制的技术，其基本思想是为每次事务生成一个新版本的数据，在读数据时选择不同版本的数据即可以实现对事务结果的完整性读取。在使用 MVCC 时，每个事务都是基于一个已生效的基础版本进行更新，事务可以并行进行，从而可以产生一种图状结构。</p>
<p><img src="https://z3.ax1x.com/2021/05/04/gmjpgP.jpg" alt=""></p>
<p>如上图所示，基础数据的版本为1，同时产生了两个事务：事务A 与事务B。这两个事务都各自对数据进行了一些本地修改（这些修改只有事务自己可见，不影响真正的数据），之后事务A 首先提交，生成数据版本2；基于数据版本2，又发起了事务C，事务C 继续提交，生成了数据版本3；最后事务B 提交，此时事务B 的结果需要与事务C 的结果合并，如果数据没有冲突，即事务B 没有修改事务A 与事务C 修改过的变量，那么事务B 可以提交，否则事务 B 提交失败。</p>
<p>MVCC 的流程过程非常类似于SVN 等版本控制系统的流程，或者说SVN 等版本控制系统就是使用的 MVCC 思想。</p>
<p>事务在基于基础版本做修改时，为了不影响真正的数据。通常有两种做法：</p>
<ol>
<li>将基础版本的数据全部拷贝出来之后再修改，SVN就使用了这个办法，SVN check out就是拷贝的过程</li>
<li>每个事务中只记录更新操作，不记录完整的数据，读取数据的再将更新操作应用于基础版本的数据从而得到更新后的数据</li>
</ol>
<p>LevelDB中的sstable的MVCC采用的上述的第2种方法，下文介绍LevelDB中Version相关内容。</p>
<h2 id="Version、VersionEdit、VersionSet"><a href="#Version、VersionEdit、VersionSet" class="headerlink" title="Version、VersionEdit、VersionSet"></a>Version、VersionEdit、VersionSet</h2><h3 id="关系介绍"><a href="#关系介绍" class="headerlink" title="关系介绍"></a>关系介绍</h3><ul>
<li>Version字面意思就是代表某一版本</li>
<li>VersionEdit就是指版本变化（一个版本到另一个版本之间的更新操作）</li>
<li>VersionSet看字面意思就是版本的集合，确实也是系统中Version的集合</li>
</ul>
<p>上文提到了LevelDB也有SSTable的MVCC，其具体实现就是通过Version、VersionEdit以及VersionSet实现的。Version代表一个基础版本，VersionEdit就是记录更新操作当中的各种变更，VersionSet则是管理了当前系统中所有的版本。也就是说有如下公式：</p>
<p><strong>Version(N) + VersionEdit = Version(N+1)</strong></p>
<p>在LevelDB的实现中，为方便将VersionEdit变更应用于Version之上，实现了VersionSet::Builder以及相关的方法。不过有个问题，如果有多次变更操作产生了多次VersionEdit，然后将这多个VersionEdit累积应用与基础Version版本，将会得到多个Version，如果只需要最终的一个Version或者某几个Version，那这个过程岂不是产生了很多中间版本。为了达到不产生这些中间版本的目的，VersionSet Builder中提供了一个Apply方法，可以把多次变更累积到一个VersionEdit中，然后将该VersionEdit应用于(VersionSet Builder提供的方法为SaveTo)基础版本Version就可以直接得到最终版本。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>本文只介绍下关键的数据结构成员及关键方法，并不会列出所有的数据成员，详细数据结构请参考源码。</p>
<ul>
<li>Version的主要数据结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">VersionSet* vset_;  // 当前版本属于的VersionSet</span><br><span class="line"></span><br><span class="line">Version* next_;     // 在VersionSet双向链表中的下一个版本</span><br><span class="line"></span><br><span class="line">Version* prev_;     // 在VersionSet双向链表中的前一个版本</span><br><span class="line"></span><br><span class="line">int refs_;          // 当前版本存有的引用计数</span><br><span class="line"></span><br><span class="line">// 每一层所拥有的文件列表</span><br><span class="line"></span><br><span class="line">std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line">// 基于统计访问次数选定的将要进行下一次compaction的文件*</span><br><span class="line"></span><br><span class="line">FileMetaData file_to_compact_;</span><br><span class="line"></span><br><span class="line">int file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">// Level that should be compacted next and its compaction score.</span><br><span class="line"></span><br><span class="line">// Score &lt; 1 means compaction is not strictly needed.  These fields</span><br><span class="line"></span><br><span class="line">// are initialized by Finalize().</span><br><span class="line"></span><br><span class="line">double compaction_score_;</span><br><span class="line"></span><br><span class="line">int compaction_level_;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从Version的主要数据结构可以看到，当前版本中包含属于当前版本的所有的文件，以及哪个文件将要用于compaction，还记录了compaction_score_以及compaction_level_（将要用于压缩的那一层，其compaction_score是最大的，注释中也提到了，score &lt; 1的情况下，compaction是不严格要求的, 也就是说这种情况可以不进行compaction）。此外，Version的数据结构中还记录上一个版本prev_以及下一个版本next_。</p>
<ul>
<li>VersionEdit主要数据结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;int, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line"></span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::pair&lt;int, FileMetaData&gt;&gt; new_files_;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面三个是VersionEdit中最重要的成员，每一个compact_pointers_表示某一层的要开始进行compact的InternalKey，比如在实际要进行compaction时，通过该变量可以知道在当前层（pair当中的第一个变量）从哪一个Key开始进行compaction，没有这个信息的话，就不知道从哪个key开始进行compaction，总不能每次都从第一个key开始吧。</p>
<p>deleted_files_则表示要删除哪些文件。</p>
<p>new_files_则表示新增哪些文件。</p>
<ul>
<li>VersionSet主要数据结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Versiondummy_versions_; // Head of circular doubly-linked list of versions.</span><br><span class="line"></span><br><span class="line">Version*current_;      // == dummy_versions_.prev_</span><br><span class="line"></span><br><span class="line">// Per-level key at which the next compaction at that level should start.</span><br><span class="line"></span><br><span class="line">// Either an empty string, or a valid InternalKey.</span><br><span class="line"></span><br><span class="line">std::stringcompact_pointer_[config::kNumLevels];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dummy_versions_是双向循环链表的头，也就是说VersionSet是一个双向循环连接，所有存在的Version都在这个双向循环链表上。</p>
<p>dummy_versions_.prev_指向当前版本current_。</p>
<p>compact_pointer_也是表明每一层进行下一次compaction时应该开始的Key，这个要么是个空字符串，要么是一个有效的InternalKey。</p>
<p>通过上面VersionEdit的主要数据结构可以看出，在LevelDB的MVCC是SSTable的MVCC，VersionEdit主要是记录了SSTable文件的变化（在compaction时生成新的SSTable，完成compaction之后删除旧的SSTable）。所以严格的来说，这里的MVCC并不是读取某一个数据多版本，当然由于compaction前同一个key在不同文件中确实有存在多个版本的问题，比如刚开始设置key1的值为1，然后一直有写请求，后面又将key1的值设为了2。那么这系统里面是存在两个版本的key1的value值的，我们读的时候，是会优先读到2的这个值的，也可以通过设置来读取到1，不过在进行compaction的时候会进行合并，合并之后就不会读到1了。</p>
<h3 id="主要方法及流程"><a href="#主要方法及流程" class="headerlink" title="主要方法及流程"></a>主要方法及流程</h3><h3 id="更多问题"><a href="#更多问题" class="headerlink" title="更多问题"></a>更多问题</h3><p>1.既然存在多版本，那什么时候Version会发生变化呢？</p>
<pre><code>答：当SSTable文件发生变化时则会产生新的Version
</code></pre><p>2.SSTable产生变化的触发条件是什么？</p>
<p> 答：（1）将Immutable转为SSTable时（minor compaction）</p>
<pre><code>（2）当后台开始进行Compact时 （major compaction）
</code></pre><p>3.Version产生的流程</p>
<p> 答：</p>
<ul>
<li>Memtable转为新的SSTable或者进行Compact之后SSTable产生变化时调用<strong>VersionSet::LogAndApply()</strong>产生新的Version。</li>
<li>leveldb上电还原Version过程，调用接口<strong>VersionSet::Recover()</strong>。</li>
<li>leveldb异常损坏，修复levelDB过程，调用接口RepairDB()产生新的Version。</li>
</ul>
<p>4.Manifest丢失或者损坏，LevelDB会丢数据吗？</p>
<p>  答：不会</p>
<p>5.Manifest丢失或者损坏，如何恢复LevelDB数据？</p>
<p> 答：使用python-leveldb，通过如下手段可以修复Leveldb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import leveldb</span><br><span class="line">ret ＝ leveldb.RepairDB(&#x27;/data/mon.iecvq/store.db&#x27;)</span><br></pre></td></tr></table></figure>
<p>6.为什么MANIFEST损坏或者丢失之后，依然可以恢复出来？LevelDB如何做到的？</p>
<p>答：对于LevelDB而言，修复过程如下：</p>
<ul>
<li>首先处理log，这些还未来得及写入的记录，写入新的.sst文件</li>
<li>扫描所有的sst文件，生成元数据信息：包括number filesize， 最小key，最大key</li>
<li>根据这些元数据信息，将生成新的MANIFEST文件。</li>
</ul>
<p>第三步如何生成新的MANIFEST？ 因为SSTable文件是分level的，但是很不幸，我们无法从名字上判断出来文件属于哪个level。第三步处理的原则是，既然我分不出来，我就认为所有的sstale文件都属于level 0，因为level 0是允许重叠的，因此并没有违反基本的准则。</p>
<p>当修复之后，第一次Open LevelDB的时候，很明显level 0 的文件可能远远超过4个文件，因此会Compaction。 又因为所有的文件都在Level 0 这次Compaction无疑是非常沉重的。它会扫描所有的文件，归并排序，产生出level 1文件，进而产生出其他level的文件。</p>
<p>从上面的处理流程看，如果只有MANIFEST文件丢失，其他文件没有损坏，LevelDB是不会丢失数据的，原因是，LevelDB既然已经无法将所有的数据分到不同的Level，但是数据毕竟没有丢，根据文件的number，完全可以判断出文件的新旧，从而确定不同sstable文件中的重复数据，which是最新的。经过一次比较耗时的归并排序，就可以生成最新的LevelDB。</p>
<p>上述的方法，从功能的角度看，是正确的，但是效率上不敢恭维。Riak曾经测试过78000个sstable 文件，490G的数据，大家都位于Level 0，归并排序需要花费6 weeks，6周啊，这个耗时让人发疯的。</p>
<p>Riak 1.3 版本做了优化，改变了目录结构，对于google 最初版本的LevelDB，所有的文件都在一个目录下，但是Riak 1.3版本引入了子目录， 将不同level的sst 文件放入不同的子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sst_0</span><br><span class="line">sst_1</span><br><span class="line">...</span><br><span class="line">sst_6</span><br></pre></td></tr></table></figure>
<p>有了这个，重新生成MANIFEST自然就很简单了，同样的78000 sstable文件，Repair过程耗时是分钟级别的。</p>
<p>7.compaction触发的时机？</p>
<p>答：主要有如下三个触发的时机</p>
<ul>
<li><strong>容量触发Compaction：</strong>每个Version在其生成的时候会初始化两个值compaction_level_、compaction_score_，这两个值记录了当前Version最需要进行Compaction的Level，以及其需要进行Compaction的紧迫程度，score大于1被认为是需要马上执行的。我们知道每次文件信息的改变都会生成新的Version，所以每个Version对应的这两个值初始化后不会再改变。level0层compaction_score_与文件数相关，其他level的则与当前层的文件总大小相关。这种区分的必要性也是显而易见的：每次Get操作都需要从level0层的每个文件中尝试查找，因此控制level0的文件数是很有必要的。同时Version中会记录每层上次Compaction结束后的最大Key值compact_pointer_，下一次触发自动Compaction会从这个Key开始。容量触发的优先级高于下面将要提到的Seek触发。</li>
<li><strong>Seek触发Compaction：</strong>Version中会记录file_to_compact_和file_to_compact_level_，这两个值会在Get操作每次尝试从文件中查找时更新。LevelDB认为每次查找同样会消耗IO，这个消耗在达到一定数量可以抵消一次Compaction操作消耗的IO，所以对Seek较多的文件应该主动触发一次Compaction。但在引入布隆过滤器后，这种查找消耗的IO就会变得微不足道了，因此由Seek触发的Compaction其实也就变得没有必要了。</li>
<li><strong>手动Compaction：</strong>LevelDB提供了外部接口CompactRange，用户可以指定触发某个Key Range的Compaction，LevelDB默认手动Compaction的优先级高于两种自动触发。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《分布式系统原理介绍》</p>
<p><a href="https://bean-li.github.io/leveldb-manifest/">leveldb之MANIFEST</a></p>
<p><a href="https://blog.csdn.net/H514434485/article/details/108210958">图解leveldb version相关结构及流程</a></p>
<p><a href="https://catkang.github.io/2017/02/03/leveldb-version.html">庖丁解LevelDB之版本控制</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码阅读 -- Log Reader</title>
    <url>/2020/02/20/Leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%20--%20Log%20Reader/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/26/J6K7wT.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍leveldb的Log Reader。主要就是介绍读日志的流程。</p>
<h2 id="名词说明"><a href="#名词说明" class="headerlink" title="名词说明"></a>名词说明</h2><ul>
<li>Slice：slice除了是levelDB上的slice，另外一层含义是一个完整的字符串，也就是一条完整的用户数据。比如用户输出一个78KB长度的字符串需要存入levelDB。这个slice在代码里面也可能叫做<strong>逻辑record</strong></li>
<li>PhysicalRecord: 可以理解为一个32K的Block，所以代码中ReadPhysicalRecord()其实就是每次读32K的Block </li>
</ul>
<h2 id="Log-Reader流程概述"><a href="#Log-Reader流程概述" class="headerlink" title="Log Reader流程概述"></a>Log Reader流程概述</h2><p>要理解这部分的代码，其实需要掌握LOG文件的物理布局。在理解物理布局的基础上来看代码就好理解了。<br>首先，要知道日志读取的时候就是一个Block一个Block的读的，也就是每次读32K，也就是代码中的ReadPhysicalRecord()<br>其实整个读日志流程，简单的来说，就是要把一条完整的数据读出来，但LOG文件的物理布局是32K大小的Block，由于单个Block可能无法存一条完整的数据，所以又添加了header来进行记录，里面会有字段标识当前block所包含的数据是不是一条完整的数据，如果不是一条完整的数据，则需要继续读，并读到的数据拼到一块，直至读到结尾标识。</p>
<p>下面，再回顾下LOG物理布局以帮助理解整个Log Reader流程代码。<br>LOG文件的物理布局就是由连续的 32K 大小 Block 构成的。<br>物理布局如下图：<br><img src="https://s1.ax1x.com/2020/04/21/J3nBAs.md.png" alt="物理布局"><br>header的结构如下：<br><img src="https://s1.ax1x.com/2020/04/21/J3uVEj.png" alt=""></p>
<p>类型存在4种，可以用于判断一条数据是否完整并根据类型就拼接：<br>kFullType ： 顾名思义记录完全在一个block中<br>kFirstType ： 当前block容纳不下所有的内容，记录的第一片在本block中<br>kMiddleType ： 记录的内容的起始位置不在本block，结束未知也不在本block<br>kLastType ： 记录的内容起始位置不在本block，但 结束位置在本block  </p>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><p>这里列出log_reader.cc的代码注释<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;db/log_reader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/env.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/coding.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/crc32c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="keyword">namespace</span> log &#123;</span><br><span class="line"></span><br><span class="line">Reader::Reporter::~<span class="built_in">Reporter</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Reader::<span class="built_in">Reader</span>(SequentialFile* file, Reporter* reporter, <span class="type">bool</span> checksum,</span><br><span class="line">               <span class="type">uint64_t</span> initial_offset)</span><br><span class="line">    : <span class="built_in">file_</span>(file),</span><br><span class="line">      <span class="built_in">reporter_</span>(reporter),</span><br><span class="line">      <span class="built_in">checksum_</span>(checksum),</span><br><span class="line">      <span class="built_in">backing_store_</span>(<span class="keyword">new</span> <span class="type">char</span>[kBlockSize]),</span><br><span class="line">      <span class="built_in">buffer_</span>(),</span><br><span class="line">      <span class="built_in">eof_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">last_record_offset_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">end_of_buffer_offset_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">initial_offset_</span>(initial_offset),</span><br><span class="line">      <span class="built_in">resyncing_</span>(initial_offset &gt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Reader::~<span class="built_in">Reader</span>() &#123; <span class="keyword">delete</span>[] backing_store_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::SkipToInitialBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在某个block中的偏移</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> offset_in_block = initial_offset_ % kBlockSize;</span><br><span class="line">  <span class="comment">// 需要跳过的块的位置</span></span><br><span class="line">  <span class="comment">// 这个变量的意思是说，后面在读的时候，要读的块的开头地址是什么？</span></span><br><span class="line">  <span class="type">uint64_t</span> block_start_location = initial_offset_ - offset_in_block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t search a block if we&#x27;d be in the trailer</span></span><br><span class="line">  <span class="comment">// 如果给定的初始位置的块中偏移</span></span><br><span class="line">  <span class="comment">// 刚好掉在了尾巴上的6个bytes以内。那么</span></span><br><span class="line">  <span class="comment">// 这个时候，应该是需要直接切入到下一个block的。</span></span><br><span class="line">  <span class="keyword">if</span> (offset_in_block &gt; kBlockSize - <span class="number">6</span>) &#123;</span><br><span class="line">    block_start_location += kBlockSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  end_of_buffer_offset_ = block_start_location;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip to start of first block that can contain the initial record</span></span><br><span class="line">  <span class="keyword">if</span> (block_start_location &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Status skip_status = file_-&gt;<span class="built_in">Skip</span>(block_start_location);</span><br><span class="line">    <span class="keyword">if</span> (!skip_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">ReportDrop</span>(block_start_location, skip_status);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::ReadRecord</span><span class="params">(Slice* record, std::string* scratch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (last_record_offset_ &lt; initial_offset_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SkipToInitialBlock</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  record-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">// 用于标记是不是 读在中间的状态。</span></span><br><span class="line">  <span class="type">bool</span> in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// Record offset of the logical record that we&#x27;re reading</span></span><br><span class="line">  <span class="comment">// 0 is a dummy value to make compilers happy</span></span><br><span class="line">  <span class="type">uint64_t</span> prospective_record_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Slice fragment;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里是读一个物理block上的record。并不是一个完整的slice信息。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = <span class="built_in">ReadPhysicalRecord</span>(&amp;fragment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReadPhysicalRecord may have only had an empty trailer remaining in its</span></span><br><span class="line">    <span class="comment">// internal buffer. Calculate the offset of the next physical record now</span></span><br><span class="line">    <span class="comment">// that it has returned, properly accounting for its header size.</span></span><br><span class="line">    <span class="type">uint64_t</span> physical_record_offset =</span><br><span class="line">        end_of_buffer_offset_ - buffer_.<span class="built_in">size</span>() - kHeaderSize - fragment.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resyncing_主要是指需要跳过的部分。</span></span><br><span class="line">    <span class="comment">// 跳过的时候是跳过一个完整的record.</span></span><br><span class="line">    <span class="comment">// 这主要是用于处理一上来就读到某条数据(Slice)中间部分的情况</span></span><br><span class="line">    <span class="comment">// 这种情况这整条数据肯定都要跳过</span></span><br><span class="line">    <span class="keyword">if</span> (resyncing_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (record_type == kMiddleType) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (record_type == kLastType) &#123;</span><br><span class="line">        resyncing_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resyncing_ = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里的时候，读取的就是一个完整的slice的开头了。</span></span><br><span class="line">    <span class="comment">// 所以这里才开始正常的处理。</span></span><br><span class="line">    <span class="comment">// 就是根据从一个物理Block读到类型进行处理</span></span><br><span class="line">    <span class="comment">// 主要是根据类型判断是不是可以拼出完整的一条数据</span></span><br><span class="line">    <span class="comment">// 或者本身就是一条完整的数据（kFullType的情况）</span></span><br><span class="line">    <span class="keyword">switch</span> (record_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> kFullType:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// 既然这条数据是完整的，然而状态表示是读到数据的中间，这肯定是出错了</span></span><br><span class="line">          <span class="comment">// Handle bug in earlier versions of log::Writer where</span></span><br><span class="line">          <span class="comment">// it could emit an empty kFirstType record at the tail end</span></span><br><span class="line">          <span class="comment">// of a block followed by a kFullType or kFirstType record</span></span><br><span class="line">          <span class="comment">// at the beginning of the next block.</span></span><br><span class="line">          <span class="keyword">if</span> (!scratch-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">ReportCorruption</span>(scratch-&gt;<span class="built_in">size</span>(), <span class="string">&quot;partial record without end(1)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prospective_record_offset = physical_record_offset;</span><br><span class="line">        scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">        *record = fragment;</span><br><span class="line">        last_record_offset_ = prospective_record_offset;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kFirstType:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// Handle bug in earlier versions of log::Writer where</span></span><br><span class="line">          <span class="comment">// it could emit an empty kFirstType record at the tail end</span></span><br><span class="line">          <span class="comment">// of a block followed by a kFullType or kFirstType record</span></span><br><span class="line">          <span class="comment">// at the beginning of the next block.</span></span><br><span class="line">          <span class="keyword">if</span> (!scratch-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">ReportCorruption</span>(scratch-&gt;<span class="built_in">size</span>(), <span class="string">&quot;partial record without end(2)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        prospective_record_offset = physical_record_offset;</span><br><span class="line">        scratch-&gt;<span class="built_in">assign</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        in_fragmented_record = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kMiddleType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// 当遇到middle type的时候。必然是“读在中间”状态。如果不是，报错！！</span></span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(1)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kLastType:</span><br><span class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// 读到lastType的时候，也必然是处在“读在中间”的状态。如果不是，报错！！</span></span><br><span class="line">          <span class="built_in">ReportCorruption</span>(fragment.<span class="built_in">size</span>(),</span><br><span class="line">                           <span class="string">&quot;missing start of fragmented record(2)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.<span class="built_in">data</span>(), fragment.<span class="built_in">size</span>());</span><br><span class="line">          *record = <span class="built_in">Slice</span>(*scratch);</span><br><span class="line">          last_record_offset_ = prospective_record_offset;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kEof:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="comment">// This can be caused by the writer dying immediately after</span></span><br><span class="line">          <span class="comment">// writing a physical record but before completing the next; don&#x27;t</span></span><br><span class="line">          <span class="comment">// treat it as a corruption, just ignore the entire logical record.</span></span><br><span class="line">          scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> kBadRecord:</span><br><span class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</span><br><span class="line">          <span class="built_in">ReportCorruption</span>(scratch-&gt;<span class="built_in">size</span>(), <span class="string">&quot;error in middle of record&quot;</span>);</span><br><span class="line">          in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">          scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">40</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;unknown record type %u&quot;</span>, record_type);</span><br><span class="line">        <span class="built_in">ReportCorruption</span>(</span><br><span class="line">            (fragment.<span class="built_in">size</span>() + (in_fragmented_record ? scratch-&gt;<span class="built_in">size</span>() : <span class="number">0</span>)),</span><br><span class="line">            buf);</span><br><span class="line">        in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">        scratch-&gt;<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reader::LastRecordOffset</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> last_record_offset_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader::ReportCorruption</span><span class="params">(<span class="type">uint64_t</span> bytes, <span class="type">const</span> <span class="type">char</span>* reason)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ReportDrop</span>(bytes, Status::<span class="built_in">Corruption</span>(reason));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader::ReportDrop</span><span class="params">(<span class="type">uint64_t</span> bytes, <span class="type">const</span> Status&amp; reason)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (reporter_ != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">      end_of_buffer_offset_ - buffer_.<span class="built_in">size</span>() - bytes &gt;= initial_offset_) &#123;</span><br><span class="line">    reporter_-&gt;<span class="built_in">Corruption</span>(<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(bytes), reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数的作用是从一个32K的block中读出一个record</span></span><br><span class="line"><span class="comment">//读出的record存放于result这个Slice中</span></span><br><span class="line"><span class="comment">//返回值则是Record的类型，以方便调用程序根据类型做相应处理</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Reader::ReadPhysicalRecord</span><span class="params">(Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//程序刚开始进来，因为这里buffer_.size() 为0，肯定是满足条件</span></span><br><span class="line">    <span class="comment">//并且也没有到文件结尾，也就是 !eof_ 条件成立</span></span><br><span class="line">    <span class="comment">//那么此时只需要读入一个32K的block即可</span></span><br><span class="line">    <span class="keyword">if</span> (buffer_.<span class="built_in">size</span>() &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!eof_) &#123;</span><br><span class="line">        <span class="comment">// Last read was a full read, so this is a trailer to skip</span></span><br><span class="line">        buffer_.<span class="built_in">clear</span>();</span><br><span class="line">        Status status = file_-&gt;<span class="built_in">Read</span>(kBlockSize, &amp;buffer_, backing_store_);</span><br><span class="line">        end_of_buffer_offset_ += buffer_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读入发生错误，进行报告，将eof_置为true，然后返回</span></span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          buffer_.<span class="built_in">clear</span>();</span><br><span class="line">          <span class="built_in">ReportDrop</span>(kBlockSize, status);</span><br><span class="line">          eof_ = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> kEof;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读到buffer_.size() &lt; kBlockSize，将eof_置为true后，继续循环</span></span><br><span class="line">        <span class="comment">//其实会走到下面的else分支</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer_.<span class="built_in">size</span>() &lt; kBlockSize) &#123;</span><br><span class="line">          eof_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//eof_为true，说明读一个Record已经结束</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意：如果buffer_是非空的。我们有一个truncated header在文件的尾巴。</span></span><br><span class="line">        <span class="comment">// 这可能是由于在写header时crash导致的。</span></span><br><span class="line">        <span class="comment">// 与其把这个失败的写入当成错误来处理，还不如直接当成EOF呢。</span></span><br><span class="line">        <span class="comment">// Note that if buffer_ is non-empty, we have a truncated header at the</span></span><br><span class="line">        <span class="comment">// end of the file, which can be caused by the writer crashing in the</span></span><br><span class="line">        <span class="comment">// middle of writing the header. Instead of considering this an error,</span></span><br><span class="line">        <span class="comment">// just report EOF.</span></span><br><span class="line">        buffer_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> kEof;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the header开始分析header</span></span><br><span class="line">    <span class="comment">//其实上面正常读完一个block后，由于不满足buffer_.size() &lt; kHeaderSize</span></span><br><span class="line">    <span class="comment">//程序就会运行到此处，开始处理读到一条Record</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* header = buffer_.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">//这提到过了，leveldb采用的是小端模式</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> type = header[<span class="number">6</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> length = a | (b &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    <span class="comment">//如果发生kHeaderSize + length &gt; buffer_.size()，当然是出错了</span></span><br><span class="line">    <span class="comment">//因为出现了头部记录的数据长度比实际的buffer_.size还要大，那肯定是出错了</span></span><br><span class="line">    <span class="keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="type">size_t</span> drop_size = buffer_.<span class="built_in">size</span>();</span><br><span class="line">      buffer_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">if</span> (!eof_) &#123;</span><br><span class="line">        <span class="built_in">ReportCorruption</span>(drop_size, <span class="string">&quot;bad record length&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> kBadRecord;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If the end of the file has been reached without reading |length| bytes</span></span><br><span class="line">      <span class="comment">// of payload, assume the writer died in the middle of writing the record.</span></span><br><span class="line">      <span class="comment">// Don&#x27;t report a corruption.</span></span><br><span class="line">      <span class="keyword">return</span> kEof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是zero type。那么返回Bad Record</span></span><br><span class="line">    <span class="comment">// 这种情况是有可能的。比如写入record到block里面之后。可能会遇到</span></span><br><span class="line">    <span class="comment">// 还余下7个bytes的情况。这个时候只能写入一个空的record。</span></span><br><span class="line">    <span class="keyword">if</span> (type == kZeroType &amp;&amp; length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Skip zero length record without reporting any drops since</span></span><br><span class="line">      <span class="comment">// such records are produced by the mmap based writing code in</span></span><br><span class="line">      <span class="comment">// env_posix.cc that preallocates file regions.</span></span><br><span class="line">      buffer_.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">return</span> kBadRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check crc</span></span><br><span class="line">    <span class="keyword">if</span> (checksum_) &#123;</span><br><span class="line">      <span class="type">uint32_t</span> expected_crc = crc32c::<span class="built_in">Unmask</span>(<span class="built_in">DecodeFixed32</span>(header));</span><br><span class="line">      <span class="type">uint32_t</span> actual_crc = crc32c::<span class="built_in">Value</span>(header + <span class="number">6</span>, <span class="number">1</span> + length);</span><br><span class="line">      <span class="keyword">if</span> (actual_crc != expected_crc) &#123;</span><br><span class="line">        <span class="comment">// Drop the rest of the buffer since &quot;length&quot; itself may have</span></span><br><span class="line">        <span class="comment">// been corrupted and if we trust it, we could find some</span></span><br><span class="line">        <span class="comment">// fragment of a real log record that just happens to look</span></span><br><span class="line">        <span class="comment">// like a valid log record.</span></span><br><span class="line">        <span class="type">size_t</span> drop_size = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        buffer_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">ReportCorruption</span>(drop_size, <span class="string">&quot;checksum mismatch&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> kBadRecord;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移除已经读到的Record</span></span><br><span class="line">    <span class="comment">//一个record可能没有占满整个32K的block，而读一次是读32K</span></span><br><span class="line">    buffer_.<span class="built_in">remove_prefix</span>(kHeaderSize + length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip physical record that started before initial_offset_</span></span><br><span class="line">    <span class="comment">// end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length</span></span><br><span class="line">    <span class="comment">// 这里得到的就是刚读出来的record的起始位置</span></span><br><span class="line">    <span class="comment">// 这里可能比较难理解，其实就按默认的来，把initial_offset_换成0就理解了</span></span><br><span class="line">    <span class="keyword">if</span> (end_of_buffer_offset_ - buffer_.<span class="built_in">size</span>() - kHeaderSize - length &lt;</span><br><span class="line">        initial_offset_) &#123;</span><br><span class="line">      result-&gt;<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">return</span> kBadRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *result = <span class="built_in">Slice</span>(header + kHeaderSize, length);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace log</span></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure><br>彩色版本如下（温馨提示，可能需要放大才能看清）：<br><img src="https://s1.ax1x.com/2020/05/07/Ymfwlj.jpg" alt=""></p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html">数据分析与处理之二（Leveldb 实现原理）</a><br><a href="https://zhuanlan.zhihu.com/p/35188065">LevelDB源码解析8. 读取日志</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>LevelDB源码阅读--快照snapshot</title>
    <url>/2020/04/19/LevelDB%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB--%E5%BF%AB%E7%85%A7snapshot/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/05/10/gYvrcV.jpg" alt=""></p>
<span id="more"></span>
<p>本文主要介绍存储快照的使用场景、存储快照实现原理，LevelDB中的快照(snapshot)，最后简单介绍快照与备份的区别。</p>
<p>在正式介绍LevelDB的快照之前，我们先看看通常情况下存储系统中，快照的定义。</p>
<h3 id="快照的定义"><a href="#快照的定义" class="headerlink" title="快照的定义"></a>快照的定义</h3><p>简单的来说，快照是数据存储某一时刻的状态记录。</p>
<p>存储网络行业协会SNIA（StorageNetworking Industry Association）快照的定义则是：关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。</p>
<p><strong>需要注意的是：快照是完全可用的拷贝，但不是一份完整的拷贝。</strong></p>
<h3 id="存储快照的使用场景"><a href="#存储快照的使用场景" class="headerlink" title="存储快照的使用场景"></a><strong>存储快照的使用场景</strong></h3><p><strong>场景一：</strong></p>
<p>存储快照，是一种数据保护措施，可以对源数据进行一定程度的保护，通俗地讲，可以理解为—-后悔药。</p>
<p><img src="https://z3.ax1x.com/2021/05/10/gYj2Wt.png" alt=""></p>
<p>如上图，假设在t0时刻，有一份完整的源数据，我们在t1时刻，针对这份源数据创建一份快照。</p>
<p>t2时刻，若因为各种原因（误操作、系统错误等）导致源数据损毁，那么，我们可以通过回滚（rollback）快照，将源数据恢复至快照创建时的状态（即t1时刻），这样，可以尽量降低数据损失（损失的数据，是t1到t2之间产生的数据）。</p>
<p>这种功能，常用于银行、公安户籍、科研单位等。操作系统、软件升级或机房设备更替，一般会选择在夜间或其他无生产业务时，进行高危操作，操作前会对数据进行快照，若操作失败，则将快照进行rollback，将源数据恢复至操作前的状态。</p>
<p><strong>场景2：</strong></p>
<p>前言中说过，快照是一份完全可用的副本，那么，它完全可以被上层业务当做源数据。</p>
<p><img src="https://z3.ax1x.com/2021/05/10/gYjIeg.md.png" alt=""></p>
<p>如上图，针对源数据，创建快照后，将快照卷映射给其他上层业务，可以用于数据挖掘和开发测试等工作，针对快照的读操作不影响源卷的数据。</p>
<p>这种功能，常用于直播（视频&amp;图片）鉴黄、科研数据模拟开发测试等，比如，视频直播平台需要将某一段时间的视频提供给执法机构进行筛查分析，那么可以通过对特定时间点保存的数据创建快照，将快照映射给执法机构的业务主机去进行挖掘分析。</p>
<h3 id="存储快照的实现原理"><a href="#存储快照的实现原理" class="headerlink" title="存储快照的实现原理"></a>存储快照的实现原理</h3><p>目前存储快照的实现方式均由各个厂商自行决定，但主要技术分为2类，一种是写时拷贝COW（Copy On Write），另一种，是写重定向ROW（Redirect On Write）。</p>
<p>关于这两种方式的流程可以参考文章：<a href="https://www.cnblogs.com/qcloud1001/p/9322321.html">https://www.cnblogs.com/qcloud1001/p/9322321.html</a></p>
<ul>
<li>写时拷贝COW</li>
</ul>
<p>COW(Copy-On-Write)，写时拷贝，也称为写前拷贝。</p>
<p>创建快照以后，如果源卷的数据发生了变化，那么快照系统会首先将原始数据拷贝到快照卷上对应的数据块中，然后再对源卷进行改写。</p>
<ul>
<li>写时重定向ROW</li>
</ul>
<p>ROW(Redirect-on-write )，也称为写时重定向。</p>
<p>创建快照以后，快照系统把对数据卷的写请求重定向给了快照预留的存储空间，直接将新的数据写入快照卷。上层业务读源卷时，创建快照前的数据从源卷读，创建快照后产生的数据，从快照卷读。</p>
<ul>
<li>两种快照技术的优缺点</li>
</ul>
<p><strong>COW最大的问题是对写性能有影响。</strong>第一次修改原卷，需要复制数据，因此需要多一次读写的数据块迁移过程。这个就比较要命，应用需要等待时间比较长。但原卷数据的布局没有任何改变，因此<strong>对读性能没有任何影响。</strong></p>
<p><strong>ROW最大的问题是对读性能影响比较大。</strong> ROW写的时候性能基本没有损耗，只是修改指针，实现效率很高。但多次读写后，原卷的数据就分散到各个地方，对于连续读写的性能不如COW。</p>
<h3 id="LevelDB中的快照"><a href="#LevelDB中的快照" class="headerlink" title="LevelDB中的快照"></a>LevelDB中的快照</h3><p>先看下LevelDB中快照的数据结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class SnapshotImpl: public Snapshot&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">SnapshotImpl(SequenceNumber sequence_number)</span><br><span class="line"></span><br><span class="line">:sequence_number_(sequence_number)&#123;&#125;</span><br><span class="line"></span><br><span class="line">SequenceNumbersequence_number()const&#123;returnsequence_number_;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">friend class SnapshotList;</span><br><span class="line"></span><br><span class="line">// SnapshotImpl is kept in a doubly-linked circular list. The SnapshotList</span><br><span class="line"></span><br><span class="line">// implementation operates on the next/previous fields direcly.</span><br><span class="line"></span><br><span class="line">SnapshotImpl* prev_;</span><br><span class="line"></span><br><span class="line">SnapshotImpl* next_;</span><br><span class="line"></span><br><span class="line">const SequenceNumbersequence_number_;</span><br><span class="line"></span><br><span class="line">#if!defined(NDEBUG)</span><br><span class="line"></span><br><span class="line">SnapshotList* list_=nullptr;</span><br><span class="line"></span><br><span class="line">#endif //!defined(NDEBUG)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过快照的实现类，可以发现LevelDB中的快照是通过sequence_number_来实现的。在LevelDB中每次来一个新的更新类请求（put/del），都会生成一个独一无二的且递增的sequence_number，并把这个sequence_number同原始的key编码（其实还有具体的操作类型put/del）到一个新的key中。当两个key是一样的，就可以通过sequence_number来区分新旧，并且在读的时候默认是返回最新的数据。LevelDB中快照SnapShot类的实现原理就是，当调用函数获取一个快照时，就获取目前的sequence number，当读取数据时，只读取小于等于这个序列号的记录，这样就可以读取这个快照时间点之前的数据了。</p>
<p>LevelDB通过双向循环链表来保存多个快照。每生成一个快照时，要插入双向链表中，链表源码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SnapshotList &#123;</span><br><span class="line"> public:</span><br><span class="line">  SnapshotList() &#123;</span><br><span class="line">    list_.prev_ = &amp;list_;//初始dummy节点时，前后节点为自己</span><br><span class="line">    list_.next_ = &amp;list_;</span><br><span class="line">  &#125;</span><br><span class="line">  bool empty() const &#123; return list_.next_ == &amp;list_; &#125;//判断是否为空</span><br><span class="line">  //获取最“老”的快照</span><br><span class="line">  SnapshotImpl* oldest() const &#123; assert(!empty()); return list_.next_; &#125;</span><br><span class="line">  //获取最新的快照</span><br><span class="line">  SnapshotImpl* newest() const &#123; assert(!empty()); return list_.prev_; &#125;</span><br><span class="line">  //新生成一个快照，并插入链表中</span><br><span class="line">  const SnapshotImpl* New(SequenceNumber seq) &#123;</span><br><span class="line">    SnapshotImpl* s = new SnapshotImpl;</span><br><span class="line">    s-&gt;number_ = seq;</span><br><span class="line">    s-&gt;list_ = this;</span><br><span class="line">    s-&gt;next_ = &amp;list_;</span><br><span class="line">    s-&gt;prev_ = list_.prev_;</span><br><span class="line">    s-&gt;prev_-&gt;next_ = s;</span><br><span class="line">    s-&gt;next_-&gt;prev_ = s;</span><br><span class="line">    return s;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //删除一个快照</span><br><span class="line">  void Delete(const SnapshotImpl* s) &#123;</span><br><span class="line">    assert(s-&gt;list_ == this);</span><br><span class="line">    s-&gt;prev_-&gt;next_ = s-&gt;next_;</span><br><span class="line">    s-&gt;next_-&gt;prev_ = s-&gt;prev_;</span><br><span class="line">    delete s;</span><br><span class="line">  &#125;</span><br><span class="line"> private:</span><br><span class="line">  // Dummy head of doubly-linked list of snapshots</span><br><span class="line">  SnapshotImpl list_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dummy是不存实际有用信息的头节点，dummy.prev是最新的节点，dummy.next为最“老”的节点。当插入快照时，往dummy之前插入；删除快照时，则删除dummy.next节点。</p>
<h3 id="LevelDB中对快照的调用"><a href="#LevelDB中对快照的调用" class="headerlink" title="LevelDB中对快照的调用"></a>LevelDB中对快照的调用</h3><p>在DBImpl类定义了一个SnapshotList类型的成员变量snapshots_，用该变量来进行所有快照的管理，当调用db-&gt;GetSnapshot()时，其实就是用上一个序列号生成一个快照，并且插入快照链表里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Snapshot* DBImpl::GetSnapshot() &#123;</span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line">  return snapshots_.New(versions_-&gt;LastSequence());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用db-&gt;ReleaseSnapshot(readoptions.snapshot)时，其实就是调用SnapshotList的delete方法，将传入的快照删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void DBImpl::ReleaseSnapshot(const Snapshot* s) &#123;</span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line">  snapshots_.Delete(reinterpret_cast&lt;const SnapshotImpl*&gt;(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，当进行读取操作</p>
<ol>
<li>首先判断是否定义了readoption.snapshot，如果定义了，那么就按这个快照读取数据;</li>
<li>如果没有定义，那么就用上一个序列号(last_sequence)作为快照序列号来读取数据。</li>
</ol>
<p>也就是在没有定义快照操作时，因为用上一个序列号(last_sequence)作为快照序列号来读取数据，所以此时读取操作是读取最新的数据。</p>
<h3 id="快照和备份的区别"><a href="#快照和备份的区别" class="headerlink" title="快照和备份的区别"></a>快照和备份的区别</h3><p>快照是数据存储的某一时刻的状态记录；备份则是数据存储的某一个时刻的副本。快照与备份是两个完全不同的概念。</p>
<p>快照和备份的不同在于：</p>
<ul>
<li><strong>备份的数据安全性更好</strong>：如果原始数据损坏（例如物理介质损坏，或者绕开了快照所在层的管理机制对锁定数据进行了改写），快照回滚是无法恢复出正确的数据的，而备份可以。</li>
<li><strong>快照的速度比备份快得多</strong>：生成快照的速度比备份速度快的多。也因为这个原因，为了回避因为备份时间带来的各种问题（例如IO占用、数据一致性等）很多备份软件是先生成快照，然后按照快照所记录的对应关系去读取底层数据来生成备份。</li>
<li><strong>占用空间不同</strong>：备份会占用双倍的存储空间，而快照所占用的存储空间则取决于快照的数量以及数据变动情况。极端情况下，快照可能会只占用1%不到的存储空间，也可能会占用数十倍的存储空间。（PS：不过如果同一份数据，同时做相同数量的快照和增量备份的话，备份还是会比快照占用的存储空间多得多。）</li>
</ul>
<h3 id="更多问题"><a href="#更多问题" class="headerlink" title="更多问题"></a>更多问题</h3><ul>
<li>上层是怎么运用LevelDB中的快照的呢？</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cassert&gt;</span><br><span class="line">#include&lt;leveldb/db.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	leveldb::DB *db;</span><br><span class="line">	leveldb::Options options;</span><br><span class="line">	options.create_if_missing=true;</span><br><span class="line">	leveldb::Status status=leveldb::DB::Open(options,&quot;mydb2&quot;,&amp;db);</span><br><span class="line">	assert(status.ok());</span><br><span class="line">	std::string key1=&quot;fruit&quot;;</span><br><span class="line">	std::string value1=&quot;apple&quot;;</span><br><span class="line">	status=db-&gt;Put(leveldb::WriteOptions(),key1,value1);</span><br><span class="line">	assert(status.ok());</span><br><span class="line">	leveldb::ReadOptions readoptions;</span><br><span class="line">	readoptions.snapshot=db-&gt;GetSnapshot();</span><br><span class="line">	 std::string value2=&quot;orange&quot;;</span><br><span class="line">	 status=db-&gt;Put(leveldb::WriteOptions(),key1,value2);</span><br><span class="line">	 assert(status.ok());</span><br><span class="line">	 std::string value;</span><br><span class="line">	 status=db-&gt;Get(leveldb::ReadOptions(),key1,&amp;value);</span><br><span class="line">    	assert(status.ok());</span><br><span class="line">	 std::cout&lt;&lt;value&lt;&lt;std::endl;</span><br><span class="line">	 db-&gt;ReleaseSnapshot(readoptions.snapshot);</span><br><span class="line">	 delete db;</span><br><span class="line">	 return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了快照，所有上面程序的输出结果将会是快照之前的值apple。</p>
<p>那么SSDB中是如何使用LevelDB提供的快照功能的呢？</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/question/20374919">快照与备份有什么区别？</a></p>
<p><a href="https://www.zhihu.com/question/20374919/answer/499376887">快照是数据存储的某一时刻的状态记录</a></p>
<p><a href="http://luodw.cc/2015/10/31/leveldb-15/">leveldb源码分析之快照SnapShots</a></p>
<p><a href="http://mingxinglai.com/cn/2013/01/leveldb-snapshot/">LevelDB源码剖析之snapshot原理</a></p>
<p><a href="https://www.cnblogs.com/qcloud1001/p/9322321.html">快照是什么？揭秘存储快照的实现</a></p>
<p><a href="http://www.dostor.com/article/2013-09-04/7686494.shtml">高端存储快照实现原理解读</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>源码阅读</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake构建c/c++项目</title>
    <url>/2020/05/20/cmake%E6%9E%84%E5%BB%BAc%E6%88%96c++%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>初学者可以参考文章中cmake简历教程比较清晰易懂。</p>
<h2 id="cmake简介"><a href="#cmake简介" class="headerlink" title="cmake简介"></a>cmake简介</h2><p>一般来说。GNU 开源软件的 Build 系统，软件的安装过程都是：<br>解压源代码包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>这个过程中， 需要有一个 configure 脚本，同时也需要一个 Makefile 文件。</p>
<p>最早的时候，程序员完成源代码开发以后，发布代码包时，一般会附带相应的 Makefile 文件。然后就可以 make &amp;&amp; make install 来编译工程。当时并不需要这个运行 configure 的步骤。</p>
<p>但是如果一个程序被广泛使用以后 (特别是成功的开源软件)，可能需要被安装到不同的平台上使用。这个时候，在不同的平台做 build 的时，一方面可能需要对 Makefile 文件进行调整 (最常见的例子就是：编译器的名字在不同的平台可能不同)。另外一方面，可能需要用一个替代函数来替换当前平台所不支持的函数 (例如：有的平台上不支持strdup这个调用)，需要在程序里面给每个平台写#define。</p>
<p>为了避免手工做这些调整，人们开始写 configure 脚本来自动做这些调整工作 (现在在 make 之前先运行 configure 是 GNU Code Style 标准所规定的)。configure 脚本一般会先检查目前的环境，然后生成一个config.h 文件 (里面带了各种各样的#define) ，同时会生成一个 针对当前平台的 Makefile 文件，之后，make 命令就会使用到这个 Makefile文件。另外，GNU的 build 系统还有一些”乱七八糟”的功能，用户在使用 configure 这个脚本的时候，可能会使用到这些功能 (最常见的就是用 –prefix 来指定安装路径，用configure –help来查看说明等等)。</p>
<p>C++是分别编译的，如果一个工程源文件太多，一个一个编译时就会特别麻烦，于是人们想到，为什么不设计一种类似批处理的程序，来批处理编译源文件呢，于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是Makefile。</p>
<p>对于一个大工程，编写Makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成Makefile呢，于是就出现了cmake、autotools等工具，它能够输出各种各样的Makefile或者project文件，从而帮助程序员减轻负担。但是随之而来也就是编写对应的CMakeLists.txt文件，它是cmake所依据的规则。所以在编程的世界里没有捷径可走，还是要脚踏实地的。</p>
<p>原文件－－CMakeLists.txt —cmake —Makefile —make —生成可执行文件<br>CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）。因此CMake的编译基本就两个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>cmake  指向CMakeLists.txt所在的目录，例如cmake .. 表示CMakeLists.txt在当前目录的上一级目录。cmake后会生成很多编译的中间文件以及makefile文件，所以一般建议新建一个新的目录，专门用来编译，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>1）项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── b.h</span><br><span class="line">└── src</span><br><span class="line">    ├── b.c</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure>
<p>2）代码：<br><img src="https://img-blog.csdnimg.cn/20190827214653629.png" alt=""><br>3）CMakeLists.txt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 #1.cmake verson，指定cmake版本 </span><br><span class="line"> 2 cmake_minimum_required(VERSION 3.2)</span><br><span class="line"> 3 </span><br><span class="line"> 4 #2.project name，指定项目的名称，一般和项目的文件夹名称对应</span><br><span class="line"> 5 PROJECT(test_sqrt)</span><br><span class="line"> 6 </span><br><span class="line"> 7 #3.head file path，头文件目录</span><br><span class="line"> 8 INCLUDE_DIRECTORIES(</span><br><span class="line"> 9 include</span><br><span class="line">10 )</span><br><span class="line">11 </span><br><span class="line">12 #4.source directory，源文件目录</span><br><span class="line">13 AUX_SOURCE_DIRECTORY(src DIR_SRCS)</span><br><span class="line">14 </span><br><span class="line">15 #5.set environment variable，设置环境变量，编译用到的源文件全部都要放到这里，否则编译能够通过，但是执行的时候会出现各种问题，比如&quot;symbol lookup error xxxxx , undefined symbol&quot;</span><br><span class="line">16 SET(TEST_MATH</span><br><span class="line">17 $&#123;DIR_SRCS&#125;</span><br><span class="line">18 )</span><br><span class="line">19 </span><br><span class="line">20 #6.add executable file，添加要编译的可执行文件</span><br><span class="line">21 ADD_EXECUTABLE($&#123;PROJECT_NAME&#125; $&#123;TEST_MATH&#125;)</span><br><span class="line">22 </span><br><span class="line">23 #7.add link library，添加可执行文件所需要的库，比如我们用到了libm.so（命名规则：lib+name+.so），就添加该库的名称</span><br><span class="line">24 TARGET_LINK_LIBRARIES($&#123;PROJECT_NAME&#125; m)</span><br></pre></td></tr></table></figure>
<p>4）编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/liuxiao723846/article/details/100109034">c++构建之cmake</a><br><a href="https://www.cnblogs.com/cv-pr/p/6206921.html">cmake实例</a><br><a href="https://blog.csdn.net/whahu1989/article/details/82078563">cmake简明教程</a></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>SeaweedFS初探</title>
    <url>/2021/06/19/SeaweedFS%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/06/19/RiSqa9.png" alt=""></p>
<span id="more"></span>
<p>本文主要内容如下：</p>
<ul>
<li>SeaweedFS架构</li>
<li>Master Server API</li>
<li>Volume Server API</li>
<li>TTL特性</li>
<li>EC特性</li>
<li>Filer</li>
<li>Mount</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://z3.ax1x.com/2021/06/19/RPzJkn.png" alt="图片"></p>
<p>SeaweedFS的架构中包含两个组件：</p>
<ol>
<li>数据存储集群（Volume Server Cluster）</li>
</ol>
<p>Volume Server Cluster中每个volume server对应一个磁盘，每个磁盘有一系列的volume文件，每个volume文件默认大小为30GB，用于存储小对象。</p>
<p>每个volume文件对应一个index文件，用于记录volume中存储的小对象的偏移和长度，在volume server 启动时缓存在内存中。</p>
<p>这也是Haystack的一个重要设计思想，它做了一个两级的元数据映射，第一级把它映射到一个大文件，这样文件系统本身的元数据开销是很小的。第二次映射的时候，只需要在大文件内部去找它的偏移和长度。</p>
<p>而且做完两级映射之后，可以使大文件里对应的小文件的元数据全部缓存在内存里面，这样就可以大大提高它的查找的效率。</p>
<ol start="2">
<li>Master Server Cluster</li>
</ol>
<p>Master Server Cluster运行的是raft协议，维护集群的一致性状态，一般与volume server混合部署。volume server会向它上报自己的状态，然后它能够维护整个volume server cluster的拓扑。</p>
<p>同时它还负责对象写入时volume server的分配，以及负责数据读取时volume id到volume server地址映射。</p>
<h3 id="Master-Server和Volume-Server"><a href="#Master-Server和Volume-Server" class="headerlink" title="Master Server和Volume Server"></a>Master Server和Volume Server</h3><p>架构非常简单，数据存储在存储节点上的volumes里。一个volume server有多个volumes，并支持带基本验证的读写访问。</p>
<p>所有的volumes由master server管理。Master server有volume id到volume server的映射表。这是相当静态的信息，并且容易缓存。</p>
<p>当发生写请求的时候，master server会生成一个file key（一个递增的64位的无符号整数）。</p>
<h3 id="写文件和读文件"><a href="#写文件和读文件" class="headerlink" title="写文件和读文件"></a>写文件和读文件</h3><p>Client发送一个写文件的请求，master server 为该文件返回其对应的（volume id, file key, file cookie, volume node url）。Client连接volume node并且POST 该文件。</p>
<p>当client需要读一个文件（使用volume id, file key, file cookie），通过volume id向master server获取(volume node url, volume node public url), 或者直接到缓存中获取，然后client就可以GET到文件内容。</p>
<p>FileId</p>
<p>Fid： 3,01637037d6</p>
<p>3表示volume id   32位无符号整数</p>
<p>01表示file key     64位无符号整数</p>
<p>637037d6表示file cookie  32位无符号整数</p>
<p>File key和file cookie均是以16进制表示，fid可以以<volume id, file key, file cookie>元组的方式存储，或者就表示为一个字符串。</p>
<h3 id="存储大小"><a href="#存储大小" class="headerlink" title="存储大小"></a>存储大小</h3><p>当前的实现，每个volume 32GB(8 x 2^32 bytes). 8 bytes对齐的</p>
<p>可以有4 gibibytes（4GB）volumes</p>
<p>8 x 4GB x 4GB = 128 EB</p>
<p>每个文件大小限制最多就是单个volume大小。</p>
<h3 id="复本策略"><a href="#复本策略" class="headerlink" title="复本策略"></a>复本策略</h3><p>SeaweedFS支持复本配置。不过其<strong>复本配置并不是基于文件层级的，而是基于volume的</strong></p>
<p>复本类型的释义：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>Value</strong></th>
<th style="text-align:left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">000</td>
<td style="text-align:left">没有冗余复本，就一份</td>
</tr>
<tr>
<td style="text-align:left">001</td>
<td style="text-align:left">在同一个rack上有一个复本</td>
</tr>
<tr>
<td style="text-align:left">010</td>
<td style="text-align:left">在同一个数据中心的不同rack上有一个复本</td>
</tr>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">在不同的数据中心上有一个复本</td>
</tr>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">两个复本在另外两个不同数据中心上</td>
</tr>
<tr>
<td style="text-align:left">110</td>
<td style="text-align:left">一个复本在不同rack上，一个复本在另一个数据中心</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>所有复本类型xyz表示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Column</th>
<th style="text-align:left"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">在其他数据中心的复本数量</td>
</tr>
<tr>
<td style="text-align:left">y</td>
<td style="text-align:left">在同一个数据中心不同rack上的复本数量</td>
</tr>
<tr>
<td style="text-align:left">z</td>
<td style="text-align:left">在同一个rack上的不同server上的复本数量</td>
</tr>
</tbody>
</table>
<p>说明：x,y,z的取值可以是0,1,2。所以有9种可能复本类型。</p>
<h2 id="Master-Server-API"><a href="#Master-Server-API" class="headerlink" title="Master Server API"></a>Master Server API</h2><p>可以在HTTP API后面添加“&amp;pretty=y”来得到一个json格式的输出。</p>
<h3 id="分配一个file-key"><a href="#分配一个file-key" class="headerlink" title="分配一个file key"></a>分配一个file key</h3><p>Basic Usage:</p>
<p>curl<a href="http://localhost:9333/dir/assign">http://localhost:9333/dir/assign</a></p>
<h3 id="查询volume"><a href="#查询volume" class="headerlink" title="查询volume"></a>查询volume</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;[http://localhost:9333/dir/lookup?volumeId=3&amp;pretty=y](http://localhost:9333/dir/lookup?volumeId=3&amp;pretty=y)&quot;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;locations&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;publicUrl&quot;: &quot;localhost:8080&quot;,</span><br><span class="line"></span><br><span class="line">&quot;url&quot;: &quot;localhost:8080&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预分配volumes"><a href="#预分配volumes" class="headerlink" title="预分配volumes"></a>预分配volumes</h3><p>一个volume 一次服务一个写请求，如果你需要增加并发，可以预分配许多volumes:</p>
<h1 id="specify-a-specific-replication"><a href="#specify-a-specific-replication" class="headerlink" title="specify a specific replication"></a>specify a specific replication</h1><p>curl “<a href="http://localhost:9333/vol/grow?replication=000&amp;count=4">http://localhost:9333/vol/grow?replication=000&amp;count=4</a>“</p>
<p>{“count”:4}# specify a collection</p>
<p>curl “<a href="http://localhost:9333/vol/grow?collection=turbo&amp;count=4&quot;#specify">http://localhost:9333/vol/grow?collection=turbo&amp;count=4&quot;#specify</a> data center</p>
<p>curl “<a href="http://localhost:9333/vol/grow?dataCenter=dc1&amp;count=4&quot;#specify">http://localhost:9333/vol/grow?dataCenter=dc1&amp;count=4&quot;#specify</a> ttl</p>
<p>curl “<a href="http://localhost:9333/vol/grow?ttl=5d&amp;count=4">http://localhost:9333/vol/grow?ttl=5d&amp;count=4</a>“</p>
<p>产生4个空的volumes</p>
<h3 id="检查系统状态"><a href="#检查系统状态" class="headerlink" title="检查系统状态"></a>检查系统状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;[http://10.0.2.15:9333/cluster/status?pretty=y](http://10.0.2.15:9333/cluster/status?pretty=y)&quot;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;IsLeader&quot;: true,</span><br><span class="line"></span><br><span class="line">&quot;Leader&quot;: &quot;10.0.2.15:9333&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Peers&quot;: [</span><br><span class="line"></span><br><span class="line">&quot;10.0.2.15:9334&quot;,</span><br><span class="line"></span><br><span class="line">&quot;10.0.2.15:9335&quot;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curl &quot;[http://localhost:9333/dir/status?pretty=y](http://localhost:9333/dir/status?pretty=y)&quot;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Topology&quot;: &#123;</span><br><span class="line"></span><br><span class="line">&quot;DataCenters&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 3,</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: &quot;dc1&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;Racks&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;DataNodes&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 3,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;PublicUrl&quot;: &quot;localhost:8080&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Url&quot;: &quot;localhost:8080&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Volumes&quot;: 4</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 3,</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: &quot;DefaultRack&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 7</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 21,</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: &quot;dc3&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 21,</span><br><span class="line"></span><br><span class="line">&quot;Racks&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;DataNodes&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;PublicUrl&quot;: &quot;localhost:8081&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Url&quot;: &quot;localhost:8081&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Volumes&quot;: 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: &quot;rack1&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 7</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;DataNodes&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;PublicUrl&quot;: &quot;localhost:8082&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Url&quot;: &quot;localhost:8082&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Volumes&quot;: 0</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;PublicUrl&quot;: &quot;localhost:8083&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Url&quot;: &quot;localhost:8083&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Volumes&quot;: 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 14,</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: &quot;DefaultRack&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 14</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&quot;Free&quot;: 24,</span><br><span class="line"></span><br><span class="line">&quot;Max&quot;: 28,</span><br><span class="line"></span><br><span class="line">&quot;layouts&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;collection&quot;: &quot;&quot;,</span><br><span class="line"></span><br><span class="line">&quot;replication&quot;: &quot;000&quot;,</span><br><span class="line"></span><br><span class="line">&quot;writables&quot;: [</span><br><span class="line"></span><br><span class="line">1,</span><br><span class="line"></span><br><span class="line">2,</span><br><span class="line"></span><br><span class="line">3,</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: &quot;0.47&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Volume-Server-API"><a href="#Volume-Server-API" class="headerlink" title="Volume Server API"></a>Volume Server API</h2><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>curl -F file=@/home/chris/myphoto.jpg<a href="http://127.0.0.1:8080/3,01637037d6">http://127.0.0.1:8080/3,01637037d6</a></p>
<p>{“size”: 43234}</p>
<p>返回的size值是存储在seaweedfs上的大小，有时候文件会基于MIME类型被自动压缩。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>curl -X DELETE<a href="http://127.0.0.1:8080/3,01637037d6">http://127.0.0.1:8080/3,01637037d6</a></p>
<h3 id="检查volume-server状态"><a href="#检查volume-server状态" class="headerlink" title="检查volume server状态"></a>检查volume server状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl &quot;[http://localhost:8080/status?pretty=y](http://localhost:8080/status?pretty=y)&quot;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: &quot;0.34&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Volumes&quot;: [</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: 1,</span><br><span class="line"></span><br><span class="line">&quot;Size&quot;: 1319688,</span><br><span class="line"></span><br><span class="line">&quot;RepType&quot;: &quot;000&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;FileCount&quot;: 276,</span><br><span class="line"></span><br><span class="line">&quot;DeleteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;DeletedByteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;ReadOnly&quot;: false</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;Size&quot;: 1040962,</span><br><span class="line"></span><br><span class="line">&quot;RepType&quot;: &quot;000&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;FileCount&quot;: 291,</span><br><span class="line"></span><br><span class="line">&quot;DeleteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;DeletedByteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;ReadOnly&quot;: false</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: 3,</span><br><span class="line"></span><br><span class="line">&quot;Size&quot;: 1486334,</span><br><span class="line"></span><br><span class="line">&quot;RepType&quot;: &quot;000&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;FileCount&quot;: 301,</span><br><span class="line"></span><br><span class="line">&quot;DeleteCount&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;DeletedByteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;ReadOnly&quot;: false</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: 4,</span><br><span class="line"></span><br><span class="line">&quot;Size&quot;: 8953592,</span><br><span class="line"></span><br><span class="line">&quot;RepType&quot;: &quot;000&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;FileCount&quot;: 320,</span><br><span class="line"></span><br><span class="line">&quot;DeleteCount&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;DeletedByteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;ReadOnly&quot;: false</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: 5,</span><br><span class="line"></span><br><span class="line">&quot;Size&quot;: 70815851,</span><br><span class="line"></span><br><span class="line">&quot;RepType&quot;: &quot;000&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;FileCount&quot;: 309,</span><br><span class="line"></span><br><span class="line">&quot;DeleteCount&quot;: 1,</span><br><span class="line"></span><br><span class="line">&quot;DeletedByteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;ReadOnly&quot;: false</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: 6,</span><br><span class="line"></span><br><span class="line">&quot;Size&quot;: 1483131,</span><br><span class="line"></span><br><span class="line">&quot;RepType&quot;: &quot;000&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;FileCount&quot;: 301,</span><br><span class="line"></span><br><span class="line">&quot;DeleteCount&quot;: 1,</span><br><span class="line"></span><br><span class="line">&quot;DeletedByteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;ReadOnly&quot;: false</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;Id&quot;: 7,</span><br><span class="line"></span><br><span class="line">&quot;Size&quot;: 46797832,</span><br><span class="line"></span><br><span class="line">&quot;RepType&quot;: &quot;000&quot;,</span><br><span class="line"></span><br><span class="line">&quot;Version&quot;: 2,</span><br><span class="line"></span><br><span class="line">&quot;FileCount&quot;: 292,</span><br><span class="line"></span><br><span class="line">&quot;DeleteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;DeletedByteCount&quot;: 0,</span><br><span class="line"></span><br><span class="line">&quot;ReadOnly&quot;: false</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存储文件以Time-To-Live（TTL）的方式"><a href="#存储文件以Time-To-Live（TTL）的方式" class="headerlink" title="存储文件以Time To Live（TTL）的方式"></a>存储文件以Time To Live（TTL）的方式</h2><h3 id="怎样使用"><a href="#怎样使用" class="headerlink" title="怎样使用"></a>怎样使用</h3><p>比如我们存一个文件其TTL位3分钟。</p>
<p>首先，向master请求分配一个file id 到一个有3分钟TTL的volume：</p>
<p>curl<a href="http://localhost:9333/dir/assign?ttl=3m">http://localhost:9333/dir/assign?ttl=3m</a></p>
<p>{“count”:1,”fid”:”5,01637037d6”,”url”:”127.0.0.1:8080”,”publicUrl”:”localhost:8080”}</p>
<p>然后，使用该file id把文件存储到volume server上</p>
<p>curl -F “<a href="mailto:file=@x.go">file=@x.go</a>“<a href="http://127.0.0.1:8080/5,01637037d6?ttl=3m">http://127.0.0.1:8080/5,01637037d6?ttl=3m</a></p>
<p>写成功之后，该文件在TTL时间耗尽前，可以正常被读到，但是如果TTL时间耗尽了，会报告文件没有并且返回http status为not found</p>
<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>不要求文件的TTL与volume的TTL必须一样，只需要保证volume 的TTL比文件的TTL大就可以了。</p>
<h3 id="支持的TTL格式"><a href="#支持的TTL格式" class="headerlink" title="支持的TTL格式"></a>支持的TTL格式</h3><p>格式是一个整数跟着一个单位，单位可以是分钟，小时，天，周，月，年。</p>
<p>支持的TTL格式例子：</p>
<ul>
<li>3m: 3 minutes</li>
<li>4h: 4 hours</li>
<li>5d: 5 days</li>
<li>6w: 6 weeks</li>
<li>7M: 7 months</li>
<li>8y: 8 years<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3></li>
</ul>
<ol>
<li>当分配file key的时候，master会选一个匹配TTL的TTL volume，如果没有匹配的TTL volume就创建一个新的</li>
<li>Volume servers写入的文件将会带有失效时间，当达到失效时间后，获取文件将会报告文件not found.</li>
<li>Volume servers将会跟踪记录每一个volume的最大失效时间，如果一个volume失效后便停止向master server报告</li>
<li>（没有向master server报告volume）master server会认为先前存在的volumes是死的，并且不再向这些volumes分配请求</li>
<li>在大约10% TTL时间或者最多10分钟后,volume servers将会删除过期的volume</li>
</ol>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>对于生产部署环境，TTL volume 的最大size是需要考虑的。如果写非常频繁，TTL volume 将很快增长到max volume size，所以当磁盘空间不充足的时候，最好减小最大volume size。</p>
<p>不推荐将TTL volumes 和非TTL volumes部署在同一个集群中，这是因为volume max size默认是30GB，是在volume master上以集群level配置的。（这就是说30GB这个默认max size的配置是针对整个cluster的，而不是单个volume）</p>
<p>我们可以实现为每一个TTL配置一个max volume size的功能，然而这可能相当繁琐，可能在以后有强烈的需求后会去着手实现。</p>
<p>个人解读：由于volume max size这一配置是针对整个集群而设置的，不能对单个volume额外设置其max size。而TTL volume的max size通常由于空间原因不用设置到30GB，所以不推荐将TTL volumes 和非TTL volumes部署在同一个集群中。</p>
<h2 id="Master-server故障转移"><a href="#Master-server故障转移" class="headerlink" title="Master server故障转移"></a>Master server故障转移</h2><p>Master servers之间使用raft协议来选主，主负责所有的任务，比如管理volumes，分配file id。</p>
<p>如果主挂了，将会选举出新的主。所有的volume servers将会发生他们的心跳以及他们的volumes信息给新的主。</p>
<p>在转移的过程中，可能有片刻时间，新的主只有所有volume servers的部分信息。这就意味着那些还没有上报心跳的volume servers将暂时不可写。</p>
<p><strong>常规的启动多个多个master servers和多个volume servers的方法</strong>：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">weed master -port=9333 -mdir=./1 -peers=localhost:9333,localhost:9334,localhost:9335</span><br><span class="line"></span><br><span class="line">weed master -port=9334 -mdir=./2 -peers=localhost:9333,localhost:9334,localhost:9335</span><br><span class="line"></span><br><span class="line">weed master -port=9335 -mdir=./3 -peers=localhost:9333,localhost:9334,localhost:9335# now start the volume servers, specifying any one of the master server</span><br><span class="line"></span><br><span class="line">weed volume -dir=./1 -port=8080 -mserver=localhost:9333,localhost:9334,localhost:9335</span><br><span class="line"></span><br><span class="line">weed volume -dir=./2 -port=8081 -mserver=localhost:9333,localhost:9334,localhost:9335</span><br><span class="line"></span><br><span class="line">weed volume -dir=./3 -port=8082 -mserver=localhost:9333,localhost:9334,localhost:9335</span><br><span class="line"></span><br><span class="line">//The full list of masters is recommended, but not required.</span><br><span class="line">//You can only specify any master servers.</span><br><span class="line"></span><br><span class="line">weed volume -dir=./3 -port=8082 -mserver=localhost:9333</span><br><span class="line"></span><br><span class="line">weed volume -dir=./3 -port=8082 -mserver=localhost:9333,localhost:9334</span><br></pre></td></tr></table></figure></p>
<p>FAQ：可以向正在运行的seaweedfs集群中添加一个新的master server吗？</p>
<p>A：可以把master 看做zookeeper节点，并且不要去经常变动。要添加一个master，需要停所有现有的master，然后以新的master列表启动新的masters。</p>
<h2 id="支持EC特性"><a href="#支持EC特性" class="headerlink" title="支持EC特性"></a>支持EC特性</h2><p>支持EC 10+4:即把数据切分成10个原始分片，然后计算出4个校验分片，最多容忍4个分片丢失。</p>
<p><strong>优点</strong>：</p>
<p>● 存储效率</p>
<p>● 高可用</p>
<p>● 灵活的服务器布局</p>
<p><strong>缺点：</strong></p>
<p>● 如果有EC分片丢失，获取这些数据将会慢一些</p>
<p>● 重构丢失的EC分片可能会需要转移整个volume的数据</p>
<p>● 只支持删除操作，不支持更新</p>
<p>目前支持EC 10+4可以通过修改代码来支持其他EC模式：<a href="http://km.vivo.xyz/pages/viewpage.action?pageId=79803993#L17">https://github.com/chrislusf/seaweedfs/blob/master/weed/storage/erasure_coding/ec_encoder.go#L17</a></p>
<h3 id="怎么配置生效"><a href="#怎么配置生效" class="headerlink" title="怎么配置生效"></a>怎么配置生效</h3><p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./weed scaffold -config=master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Put this file to one of the location, with descending priority</span><br><span class="line"></span><br><span class="line">#    ./master.toml</span><br><span class="line"></span><br><span class="line">#    $HOME/.seaweedfs/master.toml</span><br><span class="line"></span><br><span class="line">#    /etc/seaweedfs/master.toml</span><br><span class="line"></span><br><span class="line"># this file is read by master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[master.maintenance]</span><br><span class="line"></span><br><span class="line"># periodically run these scripts are the same as running them from &#x27;weed shell&#x27;</span><br><span class="line"></span><br><span class="line">scripts = &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">ec.encode -fullPercent=95 -quietFor=1h</span><br><span class="line"></span><br><span class="line">ec.rebuild -force</span><br><span class="line"></span><br><span class="line">ec.balance -force</span><br><span class="line"></span><br><span class="line">volume.balance -force</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">sleep_minutes = 17          # sleep minutes between each script execution</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把输出放到文件master.toml中，并将文件放到~/.seaweedfs/或者/etc/seaweedfs/目录下。</p>
<p>输出是一些周期执行的命令，这些命令可以通过weed shell执行，效果也一样。把命令放到文件master.toml中是为了部署方便。</p>
<p>在文件master.toml中的命令是在master上执行的。如果你有大量的EC volumes,在master上处理他们可能消耗一些CPU资源，最好在另一个机器上通过cron 任务用weed shell来执行这些命令。</p>
<h3 id="3个与EC相关的步骤："><a href="#3个与EC相关的步骤：" class="headerlink" title="3个与EC相关的步骤："></a>3个与EC相关的步骤：</h3><p><strong>Erasure Encode Sealed Data EC编码封存数据</strong></p>
<p>ec.encode命令将会找那些几乎满了的volume并且有一段时间都没有活动的volume。</p>
<p>默认的命令是 ec.encode -fullPercent=95 -quietFor=1h。它会找至少95% x  max volume size，通常是30GB，并且有一个小时都没有更新的volume。</p>
<p><strong>数据修复</strong></p>
<p>数据修复的默认命令是 ec.rebuild -force</p>
<p><strong>数据修复是针对整个volume的，而非单个文件</strong>，这样重建丢失的数据分片是比处理单个文件更高效并且更快。</p>
<p><strong>EC数据均衡</strong></p>
<p>随着服务器的添加或者移除，一些数据分片可能就不是最佳布局了。比如，一个volume的5个分片可能是在同一个服务器上，如果该服务器挂掉，那么该volume将会是不可修复的或者说部分数据是永久丢失。</p>
<p>默认的命令是ec.balance -force，该命令会尝试将数据分片尽量均匀分布以减小数据丢失的风险。</p>
<h3 id="Filer"><a href="#Filer" class="headerlink" title="Filer"></a>Filer</h3><p>文件管理器，Filer将数据上传到Weed Volume Servers，并将大文件分成块，将元数据和块信息写入Filer存储区（Filer Store）。</p>
<p>为了获取所有volumes的位置更新，Filer有一个持久化的client连接到master。</p>
<p>对于读文件：</p>
<ol>
<li>Filer从Filer Store中查询元数据，Filer Store可能是Cassandra/Mysql/Postgres/Redis/LevelDB。</li>
<li><p>Filer 从volume server中读数据并返回给读请求。<br><img src="https://z3.ax1x.com/2021/06/19/RPzOc8.png" alt="图片"><br>对于写文件：</p>
</li>
<li><p>Client将文件发送到Filer</p>
</li>
<li>Filer上传数据到volume servers, 并且将大文件切分成chunks</li>
<li>Filer把元数据和chunk信息写到Filer Store<h3 id="Filer-Store"><a href="#Filer-Store" class="headerlink" title="Filer Store"></a>Filer Store</h3></li>
</ol>
<p>各种Filer Store的比较</p>
<table>
<thead>
<tr>
<th style="text-align:left">Filer Store Name</th>
<th style="text-align:left">Lookup</th>
<th style="text-align:left">number of entries in a folder</th>
<th style="text-align:left">Scalability</th>
<th style="text-align:left">Renaming</th>
<th style="text-align:left">TTL</th>
<th style="text-align:left">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">memory</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">limited by memory</td>
<td style="text-align:left">Local, Fast</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">for testing only, no persistent storage</td>
</tr>
<tr>
<td style="text-align:left">leveldb</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">unlimited</td>
<td style="text-align:left">Local, Very Fast</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">Default, fairly scalable</td>
</tr>
<tr>
<td style="text-align:left">leveldb2</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">unlimited</td>
<td style="text-align:left">Local, Very Fast, faster than leveldb</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">Similar to leveldb, part of the lookup key is 128bit MD5 instead of the long full file path</td>
</tr>
<tr>
<td style="text-align:left">Redis</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">limited</td>
<td style="text-align:left">Local or Distributed, Fastest</td>
<td style="text-align:left"></td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">one directory’s sub file names are stored in one key~value entry</td>
</tr>
<tr>
<td style="text-align:left">Cassandra</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">unlimited</td>
<td style="text-align:left">Local or Distributed, Very Fast</td>
<td style="text-align:left"></td>
<td style="text-align:left">Yes</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">MySql</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">unlimited</td>
<td style="text-align:left">Local or Distributed, Fast</td>
<td style="text-align:left">Atomic</td>
<td style="text-align:left"></td>
<td style="text-align:left">Easy to manage, export</td>
</tr>
<tr>
<td style="text-align:left">Postgres</td>
<td style="text-align:left">O(logN)</td>
<td style="text-align:left">unlimited</td>
<td style="text-align:left">Local or Distributed, Fast</td>
<td style="text-align:left">Atomic</td>
<td style="text-align:left"></td>
<td style="text-align:left">Easy to manage, export</td>
</tr>
</tbody>
</table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/chrislusf/seaweedfs">https://github.com/chrislusf/seaweedfs</a></p>
<p><a href="https://github.com/chrislusf/seaweedfs/wiki">https://github.com/chrislusf/seaweedfs/wiki</a></p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>sweedfs</tag>
        <tag>对象存储</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中HugePages的作用</title>
    <url>/2021/08/31/Linux%E4%B8%ADHugePages%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/09/01/hDCA8s.jpg" alt=""></p>
<span id="more"></span>
<p>本文主要阐述Linux中HugePages的作用，当然可能很多人知道HugePages可以提升数据库性能，本文其实是要阐述HugePages为什么可以提升数据库性能。在介绍正式内容之前，先介绍一些前驱知识作为铺垫。想要知道为什么HugePages为什么可以提升数据库性能就需要知道系统是如何进行内存管理的。所以本文先会介绍虚拟内存相关的知识。</p>
<h3 id="早期的内存管理"><a href="#早期的内存管理" class="headerlink" title="早期的内存管理"></a>早期的内存管理</h3><p><img src="https://z3.ax1x.com/2021/09/01/hD9EnK.png" alt=""><br>CPU和内存都是比较宝贵的资源，那么如何利用这些资源呢。我们一个最直观的想法就是CPU直接访问物理内存就好了。确实最早的时候，CPU访问内存确实是访问的物理内存。但是CPU直接访问物理内存会有如下问题：</p>
<ul>
<li>一个程序可能访问另一个程序的内存，造成程序运行错误甚至崩溃</li>
<li>由于都可以直接访问物理内存，甚至可能造成系统崩溃等问题</li>
<li>受限于实际的物理内存的大小，如果一个程序使用内存较大，很可能分给的物理内存是不连续<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3></li>
</ul>
<p>那么现代内存管理技术是如何解决上面的提到的问题的呢？这就要提到虚拟内存技术了。</p>
<p>简单的说，就是在进程和物理内存直接增加了一层虚拟内存，而不是去直接操作物理内存。</p>
<p>虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间。<br><img src="https://z3.ax1x.com/2021/09/01/hD9GB8.png" alt=""><br>使用虚拟内存的意义在于，不仅仅是将内存拓展到了硬盘上，扩大了内存。通常我们看到各种程序使用的内存的总数是大于我们机器的实际内存的，之所以这样，就是因为使用了虚拟内存技术。</p>
<p>使用虚拟内存有如下好处：</p>
<ul>
<li>程序拥有联系的虚拟内存空间，并以为自己独享内存空间，当然实际映射到物理内存上可能是不连续的</li>
<li>由于虚拟内存可以使程序间互相“隔离”，这样更安全</li>
</ul>
<p>于是，这里就引出了两种地址的概念：</p>
<ul>
<li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li>
<li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li>
</ul>
<p>操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：</p>
<p><img src="https://z3.ax1x.com/2021/09/01/hD9d9s.png" alt=""></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>常见的内存管理方式有段式管理和页式管理，具体怎么管理的见<a href="https://www.cnblogs.com/xiaolincoding/p/13213699.html">20 张图揭开「内存管理」的迷雾，瞬间豁然开朗</a>的内存分段和内存分页小节的详细描述，本文不做过多细节介绍。</p>
<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>内存分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。</p>
<p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是<strong>内存分页</strong>（<em>Paging</em>）。</p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p>
<p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p>
<p>内存映射</p>
<p>页表实际上存储在 CPU 的<strong>内存管理单元</strong> （<em>MMU</em>） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<blockquote>
<p>分页是怎么解决分段的内存碎片、内存交换效率低的问题？</p>
</blockquote>
<p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而<strong>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</strong></p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<h3 id="HugePages"><a href="#HugePages" class="headerlink" title="HugePages"></a>HugePages</h3><p>HugePages顾名思义，除了标准的 4KB 大小的页面外，它们还能帮助管理内存中的巨大的页面。使用“大内存页”，你最大可以定义 1GB 的页面大小。</p>
<p>在系统启动期间，你能用“大内存页”为应用程序预留一部分内存。这部分内存，即被“大内存页”占用的这些存储器永远不会被交换出内存。它会一直保留其中，除非你修改了配置。这会极大地提高像 Oracle 数据库这样的需要海量内存的应用程序的性能。</p>
<p>2MB 一般都是 HugePages 的默认大小，在 arm64 和 x86_64 的架构上甚至支持 1GB 的大页面，是 Linux 默认页面大小的 262,144 倍，我们可以使用如下所示的命令查看当前机器上 HugePages 的相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     71680 kB</span><br><span class="line">ShmemHugePages:        0 kB</span><br><span class="line">FileHugePages:         0 kB</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br><span class="line">Hugetlb:               0 kB</span><br></pre></td></tr></table></figure>
<p> 通过上面的输出结果，我们可以看到当前机器上的大页面默认大小为 2MB 并且大页面的数量也为 0，即没有进程在申请或者使用大页。</p>
<h3 id="为什么使用HugePages可以提升数据库的性能？"><a href="#为什么使用HugePages可以提升数据库的性能？" class="headerlink" title="为什么使用HugePages可以提升数据库的性能？"></a>为什么使用HugePages可以提升数据库的性能？</h3><p>通过上文对内存分页的介绍，可以知道：在虚拟内存管理中，内核维护一个将虚拟内存地址映射到物理地址的表，对于每个页面操作，内核都需要加载相关的映射。如果你的内存页很小，那么你需要加载的页就会很多，导致内核会加载更多的映射表。而这会降低性能。</p>
<p>使用“大内存页”，意味着所需要的页变少了。从而大大减少由内核加载的映射表的数量。这提高了内核级别的性能最终有利于应用程序的性能。</p>
<p>简而言之，通过启用“大内存页”，系统具只需要处理较少的页面映射表，从而减少访问/维护它们的开销！</p>
<ul>
<li>HugePages 可以降低内存页面的管理开销，可以减少进程中的页表项</li>
<li>HugePages 提高 TLB 缓存的命中率和内存的访问效率</li>
<li>HugePages 可以锁定内存，禁止操作系统的内存交换和释放，不会被交换到磁盘上为其它请求让出内存</li>
</ul>
<p>正是上面提单的三点原因，所以我们可以<strong>通过使用HugePages来提升数据库这种占用内存大的应用的性能</strong>。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://zhuanlan.zhihu.com/p/82746153">什么是虚拟内存(Virtual Memory)?</a></p>
<p><a href="https://www.cnblogs.com/xiaolincoding/p/13213699.html">20 张图揭开「内存管理」的迷雾，瞬间豁然开朗</a></p>
<p><a href="https://draveness.me/whys-the-design-linux-hugepages/">为什么 HugePages 可以提升数据库性能</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34659353">Linux 中的“大内存页”（hugepage）是个什么？</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>虚拟内存</tag>
        <tag>HugePages，基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph的基本概念和常用命令</title>
    <url>/2021/09/26/Ceph%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/09/26/4c2eSI.png" alt=""></p>
<span id="more"></span>
<p>本文主要简单介绍Ceph的一些基本概念以及常用的一些命令。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Ceph项目最早起源于Sage就读博士期间的工作（最早的成果于2004年发表），并随后贡献给开源社区。在经过了数年的发展之后，目前已得到众多云计算厂商的支持并被广泛应用。RedHat及OpenStack都可与Ceph整合以支持虚拟机镜像的后端存储。<br><img src="https://z3.ax1x.com/2021/09/26/4c23kQ.png" alt=""><br>Ceph 提供了一个可无限伸缩的 <a href="http://docs.ceph.org.cn/glossary/#term-21">Ceph 存储集群</a>，它基于 RADOS ，见论文 <a href="http://ceph.com/papers/weil-rados-pdsw07.pdf">RADOS - A Scalable, Reliable Storage Service for Petabyte-scale Storage Clusters</a> 。</p>
<p>Ceph 存储集群包含两种类型的守护进程：</p>
<ul>
<li><a href="http://docs.ceph.org.cn/glossary/#term-59">Ceph 监视器</a></li>
<li><a href="http://docs.ceph.org.cn/glossary/#term-56">Ceph OSD 守护进程</a></li>
</ul>
<p><img src="https://z3.ax1x.com/2021/09/26/4c2ItH.png" alt="图片"></p>
<p>Ceph 监视器维护着集群运行图的主副本。一个监视器集群确保了当某个监视器失效时的高可用性。存储集群客户端向 Ceph 监视器索取集群运行图的最新副本。</p>
<p>Ceph OSD 守护进程检查自身状态、以及其它 OSD 的状态，并报告给监视器们。</p>
<p>存储集群的客户端和各个 <a href="http://docs.ceph.org.cn/glossary/#term-56">Ceph OSD 守护进程</a>使用 CRUSH 算法高效地计算数据位置，而不是依赖于一个中心化的查询表。它的高级功能包括：基于 librados的原生存储接口、和多种基于 librados 的服务接口。</p>
<p><strong>注：通过上面的介绍可以看出Ceph集群中最主要的两个组件是Monitors和OSDs，MDS是CephFS中用来提供原数据管理的组件，在Ceph对象存储和块存储集群中不需要部署该组件。</strong></p>
<p>不管你是想为<a href="http://docs.ceph.org.cn/glossary/#term-48">云平台</a>提供<a href="http://docs.ceph.org.cn/glossary/#term-30">Ceph 对象存储</a>和/或 <a href="http://docs.ceph.org.cn/glossary/#term-38">Ceph 块设备</a>，还是想部署一个 <a href="http://docs.ceph.org.cn/glossary/#term-45">Ceph 文件系统</a>或者把 Ceph 作为他用，所有 <a href="http://docs.ceph.org.cn/glossary/#term-21">Ceph 存储集群</a>的部署都始于部署一个个 <a href="http://docs.ceph.org.cn/glossary/#term-13">Ceph 节点</a>、网络和 Ceph 存储集群。 Ceph 存储集群至少需要一个 Ceph Monitor 和两个 OSD 守护进程。而运行 Ceph 文件系统客户端时，则必须要有元数据服务器（ Metadata Server ）。</p>
<p><img src="https://z3.ax1x.com/2021/09/26/4c2UXV.png" alt="图片"></p>
<ul>
<li><strong>Ceph OSDs</strong>: <a href="http://docs.ceph.org.cn/glossary/#term-56">Ceph OSD 守护进程</a>（ Ceph OSD ）的功能是存储数据，处理数据的复制、恢复、回填、再均衡，并通过检查其他OSD 守护进程的心跳来向 Ceph Monitors 提供一些监控信息。当 Ceph 存储集群设定为有2个副本时，至少需要2个 OSD 守护进程，集群才能达到 active+clean 状态（ Ceph 默认有3个副本，但你可以调整副本数）。</li>
<li><strong>Monitors</strong>: <a href="http://docs.ceph.org.cn/glossary/#term-ceph-monitor">Ceph Monitor</a>维护着展示集群状态的各种图表，包括监视器图、 OSD 图、归置组（ PG ）图、和 CRUSH 图。 Ceph 保存着发生在Monitors 、 OSD 和 PG上的每一次状态变更的历史信息（称为 epoch ）。</li>
<li><strong>MDSs</strong>: <a href="http://docs.ceph.org.cn/glossary/#term-63">Ceph 元数据服务器</a>（ MDS ）为 <a href="http://docs.ceph.org.cn/glossary/#term-45">Ceph 文件系统</a>存储元数据（也就是说，Ceph 块设备和 Ceph 对象存储不使用MDS ）。元数据服务器使得 POSIX 文件系统的用户们，可以在不对 Ceph 存储集群造成负担的前提下，执行诸如 ls、find 等基本命令。<h2 id="Ceph对象存储"><a href="#Ceph对象存储" class="headerlink" title="Ceph对象存储"></a>Ceph对象存储</h2></li>
</ul>
<p><a href="http://docs.ceph.org.cn/glossary/#term-34">Ceph 对象网关</a>是一个构建在 librados 之上的对象存储接口，它为应用程序访问Ceph 存储集群提供了一个 RESTful 风格的网关 。 <a href="http://docs.ceph.org.cn/glossary/#term-30">Ceph 对象存储</a>支持 2 种接口：</p>
<ol>
<li><strong>兼容S3:</strong> 提供了对象存储接口，兼容 亚马逊S3 RESTful 接口的一个大子集。</li>
<li><strong>兼容Swift:</strong> 提供了对象存储接口，兼容 Openstack Swift 接口的一个大子集。</li>
</ol>
<p>Ceph 对象存储使用 Ceph 对象网关守护进程（ radosgw ），它是个与 Ceph 存储集群交互的 FastCGI 模块。因为它提供了与 OpenStack Swift 和 Amazon S3 兼容的接口， RADOS 要有它自己的用户管理。 Ceph 对象网关可与 Ceph FS 客户端或 Ceph 块设备客户端共用一个存储集群。 S3 和 Swift 接口共用一个通用命名空间，所以你可以用一个接口写如数据、然后用另一个接口取出数据。</p>
<p><img src="https://z3.ax1x.com/2021/09/26/4c2xAg.png" alt="图片"></p>
<p><strong>Note</strong></p>
<p> Ceph 对象存储<strong>不</strong>使用 Ceph 元数据服务器即MDS。</p>
<p>RGW就是提供对象存储的网关，也即对象存储网关。所谓对象存储网关，也就是对象存储的入口，本质上是一个HTTP服务器，与Nginx和Apache无异。通过这个入口，用户可以通过HTTP协议，以RESTful的方式访问Ceph的对象存储。</p>
<p>Ceph RGW的整体架构见上图，对象存储网关实际上是调用librados的API来实现数据的存储和读取。而该网关同时提供了<strong>兼容AWS S3和OpenStack Swift的对象存储访问接口（API）</strong>。</p>
<p>另外，有些同学可能不清楚对象存储的特点。在介绍后续内容之前，我们大概了解一下对象存储是如何存储数据的。对象存储的应用场景通常是互联网场景，一个对象存储通常会给多个<strong>用户</strong>（租户）使用。而在一个用户下面可以创建多个<strong>桶</strong>（swift里面称为容器container）。在桶中可以存储<strong>对象</strong>，对象就是我们存储的数据，比如图片或者是视频等。如果将对象存储与我们常规存储做一个类比，<strong>桶</strong>就好比文件夹，而<strong>对象</strong>就好比文件，但不同之处在于桶里面只能存储对象，而<strong>不能嵌套桶</strong>。如图2是对象存储数据组织形式。</p>
<p><img src="https://z3.ax1x.com/2021/09/26/4cRZEF.png" alt="图片"></p>
<pre><code>图2 对象存储数据组织
</code></pre><h2 id="Ceph-块设备"><a href="#Ceph-块设备" class="headerlink" title="Ceph 块设备"></a>Ceph 块设备</h2><p>块是一个字节序列（例如，一个 512 字节的数据块）。基于块的存储接口是最常见的存储数据方法，它们基于旋转介质，像硬盘、 CD 、软盘、甚至传统的 9 磁道磁带。无处不在的块设备接口使虚拟块设备成为与 Ceph 这样的海量存储系统交互的理想之选。</p>
<p>Ceph 块设备是精简配置的、大小可调且将数据条带化存储到集群内的多个 OSD 。 Ceph 块设备利用 RADOS 的多种能力，如快照、复制和一致性。 Ceph 的 RADOS 块设备（ RBD ）使用内核模块或 librbd 库与 OSD 交互。</p>
<p><img src="https://z3.ax1x.com/2021/09/26/4cRQjx.png" alt="图片"></p>
<p><strong>Note</strong></p>
<p> 内核模块可使用 Linux 页缓存。对基于 librbd 的应用程序， Ceph 可提供 <a href="http://docs.ceph.org.cn/rbd/rbd-config-ref/">RBD 缓存</a>。</p>
<p>Ceph 块设备靠无限伸缩性提供了高性能，如向<a href="http://docs.ceph.org.cn/rbd/rbd-ko/">内核模块</a>、或向 abbr:KVM (kernel virtual machines) （如 <a href="http://docs.ceph.org.cn/rbd/qemu-rbd/">Qemu</a> 、 <a href="http://docs.ceph.org.cn/rbd/rbd-openstack">OpenStack</a> 和 <a href="http://docs.ceph.org.cn/rbd/rbd-cloudstack">CloudStack</a> 等云计算系统通过 libvirt 和 Qemu 可与 Ceph 块设备集成）。你可以用同一个集群同时运行 <a href="http://docs.ceph.org.cn/radosgw/">Ceph RADOS 网关</a>、 <a href="http://docs.ceph.org.cn/cephfs/">Ceph FS 文件系统</a>、和 Ceph 块设备。</p>
<p><strong>Important</strong></p>
<p> 要使用 Ceph 块设备，你必须有一个在运行的 Ceph 集群。</p>
<h2 id="Ceph-文件系统"><a href="#Ceph-文件系统" class="headerlink" title="Ceph 文件系统"></a>Ceph 文件系统</h2><p><a href="http://docs.ceph.org.cn/glossary/#term-45">Ceph 文件系统</a>（ Ceph FS ）是个 POSIX 兼容的文件系统，它使用 Ceph 存储集群来存储数据。 Ceph 文件系统与 Ceph 块设备、同时提供 S3 和 Swift API 的 Ceph 对象存储、或者原生库（ librados ）一样，都使用着相同的 Ceph 存储集群系统。</p>
<p><strong>Important</strong></p>
<p> 当前， CephFS 还缺乏健壮得像 ‘fsck’ 这样的检查和修复功能。存储重要数据时需小心使用，因为灾难恢复工具还没开发完。更多的 CephFS 使用现状见 <a href="http://docs.ceph.org.cn/cephfs/early-adopters/">CephFS 尝鲜</a> 。</p>
<p><img src="https://z3.ax1x.com/2021/09/26/4cRYUe.png" alt="图片"></p>
<p>Ceph 文件系统要求 Ceph 存储集群内至少有一个 <a href="http://docs.ceph.org.cn/glossary/#term-63">Ceph 元数据服务器</a>。</p>
<p><img src="https://z3.ax1x.com/2021/09/26/4cWvWj.png" alt=""><br>见文档<a href="http://docs.ceph.org.cn/cephfs/">http://docs.ceph.org.cn/cephfs/</a></p>
<h2 id="Ceph常用命令"><a href="#Ceph常用命令" class="headerlink" title="Ceph常用命令"></a>Ceph常用命令</h2><h3 id="集群相关命令"><a href="#集群相关命令" class="headerlink" title="集群相关命令"></a>集群相关命令</h3><ol>
<li>查看机器的监控状态</li>
</ol>
<p>[root<a href="http://my.oschina.net/client">@client</a>  ~]# ceph health</p>
<p>HEALTH_OK</p>
<ol start="2">
<li>查看ceph的实时运行状态<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root[@client](http://my.oschina.net/client)  ~]# ceph -w</span><br><span class="line"></span><br><span class="line">    cluster be1756f2-54f7-4d8f-8790-820c82721f17</span><br><span class="line"></span><br><span class="line">     health HEALTH_OK</span><br><span class="line"></span><br><span class="line">     monmap e2: 3 mons at  &#123;node1=10.240.240.211:6789/0,node2=10.240.240.212:6789/0,node3=10.240.240.213:6789/0&#125;,  election epoch 294, quorum 0,1,2 node1,node2,node3</span><br><span class="line"></span><br><span class="line">     mdsmap e95: 1/1/1 up &#123;0=node2=up:active&#125;, 1 up:standby</span><br><span class="line"></span><br><span class="line">     osdmap e88: 3 osds: 3 up, 3 in</span><br><span class="line"></span><br><span class="line">      pgmap v1164: 448 pgs, 4 pools, 10003 MB data, 2520 objects</span><br><span class="line"></span><br><span class="line">            23617 MB used, 37792 MB / 61410 MB avail</span><br><span class="line"></span><br><span class="line">                 448 active+clean</span><br><span class="line">2014-06-30 00:48:28.756948 mon.0 [INF] pgmap v1163: 448 pgs: 448  active+clean; 10003 MB data, 23617 MB used, 37792 MB / 61410 MB avail</span><br></pre></td></tr></table></figure></li>
<li>查看集群的状态 ceph -s</li>
<li>查看ceph存储空间 ceph df</li>
<li>用下列命令可以连 Ceph 安装包一起清除：</li>
</ol>
<p>ceph-deploy purge {ceph-node} [{ceph-node}]</p>
<ol start="6">
<li><p>查看集群健康状态细节 ceph health detail</p>
<h3 id="pool相关命令"><a href="#pool相关命令" class="headerlink" title="pool相关命令"></a>pool相关命令</h3></li>
<li><p>查看ceph集群中的pool数量:ceph osd lspools</p>
</li>
<li>显示集群中pool的详细信息: rados df</li>
<li><p>查看某一个pool的pg数量：ceph osd pool get <strong>pool_name</strong> pg_num（pool_name填真实的pool名称）</p>
<h3 id="mon相关的命令"><a href="#mon相关的命令" class="headerlink" title="mon相关的命令"></a>mon相关的命令</h3></li>
<li><p>查看mon的状态信息：ceph mon stat</p>
</li>
<li>查看mon的选举状态：ceph quorum_status</li>
<li>查看mon的映射信息：ceph mon dump</li>
<li><h3 id="OSD相关命令"><a href="#OSD相关命令" class="headerlink" title="OSD相关命令"></a>OSD相关命令</h3></li>
<li><p>查看ceph osd运行状态：ceph osd stat</p>
</li>
<li>查看osd映射信息：ceph osd dump</li>
<li>查看osd的目录树: ceph osd tree</li>
<li>down掉一个osd硬盘:ceph osd down 0   #down掉osd.0节点</li>
<li>在集群中删除一个osd硬盘:ceph osd rm 0</li>
<li>把一个osd节点逐出集群:ceph osd out osd.3</li>
<li>把逐出的osd加入集群:ceph osd in osd.3<h3 id="MDS命令（略）"><a href="#MDS命令（略）" class="headerlink" title="MDS命令（略）"></a>MDS命令（略）</h3></li>
</ol>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p>ceph -v //查看ceph的版本</p>
<p>ceph -s //查看集群的状态</p>
<p>ceph -w //监控集群的实时更改</p>
<p>ceph health //查看集群是否健康</p>
<p>ceph health detail //先显示集群是否健康的详细信息</p>
<p>ceph time-sync-status //查看mon节点的时间同步情况</p>
<p>ceph osd df //查看osd的使用信息</p>
<p>ceph osd dump //osd的map信息</p>
<p>ceph osd find osd.o//查看osd.0节点ip和主机名 </p>
<p>ceph osd tree //查看osd的状态和编号以及分布情况</p>
<p>ceph osd  metadata 0//查看osd元数据的详细信息</p>
<p>/var/run/ceph //存放所有的sock</p>
<p>运行状态导出集群monmap（集群正常时确认集群monIP和进程名）</p>
<p>ceph mon getmap -o /mnt/monmap</p>
<p>ceph mon dump //查看mon的信息</p>
<p>查看当前集群主mon</p>
<p>ceph quorum_status -f json-pretty|grep ‘leader’</p>
<p>ceph mon stat //查看mon状态</p>
<p>ceph osd stat //查看osd的状态</p>
<p>ceph osd dump //查看osd的map信息</p>
<p>ceph osd pool ls //查看集群中的存储池名称</p>
<p>ceph osd pool set mytest size 3 //可以修改mytest池的副本数为3</p>
<p>ceph osd pool ls detail //查看池的的详细信息</p>
<p>ceph osd pool stats //查看池的IO情况</p>
<p>ceph pg dump  //查看pg的详细信息</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文介绍可以发现Ceph的核心就是OSD和Monitor，搭建好这两个，再根据需求就可以搭建对应的块服务或者对象存储服务以及文件服务，MDS组件是CephFS所需要的，所以在搭建对象和块服务时，其实不需要MDS。在没有看文档之前一直对MDS和Monitor的作用不清楚，还以为Monitor是监控进程的，其实Monitor的作用是维护表示集群状态的各种视图，包括监视器图、 OSD 图、归置组（ PG ）图、和 CRUSH 图（Monitor的作用相当于我们自己开发的KV存储系统中的master的功能）。通过资料可以发现目前文件服务CephFS其实还不是十分的成熟，如果生产环境使用还是得慎重。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://docs.ceph.org.cn">欢迎来到 CEPH 世界</a></p>
<p><a href="https://blog.51cto.com/u_15265005/2888378">Ceph对象存储RGW架构及安装实战</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1411441">ceph 运维常用命令总结</a></p>
<p><a href="https://www.cnblogs.com/blogzjt/p/11978595.html">CEPH 常用命令总结</a></p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph手动安装步骤及安装过程中遇到的问题</title>
    <url>/2021/09/29/Ceph%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/09/30/45zpp8.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍Ceph的手动安装步骤，以及在安装过程遇到的问题和解决办法。<br>文中使用的机器个数是三台机器，每台机器四块盘，一共12个OSD，3个ceph-mon。<br><strong>注：本文操作步骤的实践环境操作系统为debian</strong></p>
<h2 id="Ceph手动安装步骤"><a href="#Ceph手动安装步骤" class="headerlink" title="Ceph手动安装步骤"></a>Ceph手动安装步骤</h2><p>手动安装部署参考文档：<a href="https://docs.ceph.com/en/latest/install/manual-deployment/">https://docs.ceph.com/en/latest/install/manual-deployment/</a></p>
<h3 id="第一个mon节点"><a href="#第一个mon节点" class="headerlink" title="第一个mon节点"></a>第一个mon节点</h3><h4 id="准备要素"><a href="#准备要素" class="headerlink" title="准备要素"></a>准备要素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unique identifier：fsid作为集群的唯一标识</span><br><span class="line">cluster name：集群名字</span><br><span class="line">monitor name：mon节点hostname</span><br><span class="line">mon map：初始的mon-map需要fsid，集群名字，以及最少一个节点</span><br><span class="line">mon keyring：mon节点keyring，为之后的bootstrap做准备</span><br><span class="line">admin keyring：作为ceph-admin的用户的keyring，管理员权限，安装部署以及ceph cli都需要使用到</span><br></pre></td></tr></table></figure>
<h4 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h4><ol>
<li><p>配置文件准备<br>（1）检查目录/etc/ceph<br>（2）在该目录下创建配置文件ceph.conf<br>（3）配置文件示例，参照如下，osd部分暂时不需要用到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">fsid = &#123;cluster-id&#125;  #generate with uuidgen</span><br><span class="line">mon initial members = &#123;hostname&#125;[, &#123;hostname&#125;]</span><br><span class="line">mon host = &#123;ip-address&#125;[, &#123;ip-address&#125;]</span><br><span class="line">public network = &#123;network&#125;[, &#123;network&#125;]</span><br><span class="line">cluster network = &#123;network&#125;[, &#123;network&#125;]</span><br><span class="line">auth cluster required = cephx</span><br><span class="line">auth service required = cephx</span><br><span class="line">auth client required = cephx</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成mon的keyring</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon &#x27;allow *&#x27;</span><br></pre></td></tr></table></figure></li>
<li>生成admin的keyring，client.admin<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --cap mon &#x27;allow *&#x27; --cap osd &#x27;allow *&#x27; --cap mds &#x27;allow *&#x27; --cap mgr &#x27;allow *&#x27;</span><br></pre></td></tr></table></figure></li>
<li>生成bootstrap-osd的keyring，client.bootstrap-osd<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-authtool --create-keyring /var/lib/ceph/bootstrap-osd/ceph.keyring --gen-key -n client.bootstrap-osd --cap mon &#x27;profile bootstrap-osd&#x27; --cap mgr &#x27;allow r&#x27;</span><br></pre></td></tr></table></figure></li>
<li>将刚刚生成的keyring添加到ceph.mon.keyring<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring</span><br><span class="line">sudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /var/lib/ceph/bootstrap-osd/ceph.keyring</span><br></pre></td></tr></table></figure></li>
<li>更改用户<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown ceph:ceph /tmp/ceph.mon.keyring</span><br></pre></td></tr></table></figure></li>
<li>使用hostname，host ip，以及fsid，生成mon_map<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monmaptool --create --add &#123;hostname&#125; &#123;ip-address&#125; --fsid &#123;uuid&#125; /tmp/monmap</span><br><span class="line">monmaptool --create --add cld-mon1-10088 10.248.32.15 --fsid 0bba3be9-0a1c-41db-a619-26ffea20161e /tmp/monmap</span><br></pre></td></tr></table></figure></li>
<li>生成mon默认存放目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -u ceph mkdir /var/lib/ceph/mon/ceph-mon-node1</span><br></pre></td></tr></table></figure></li>
<li>使用更改生成的mon_map以及keyring来为mon daemon生成文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -u ceph ceph-mon [--cluster &#123;cluster-name&#125;] --mkfs -i &#123;hostname&#125; --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring</span><br><span class="line">sudo -u ceph ceph-mon --mkfs -i cld-mon1-10088 --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring</span><br></pre></td></tr></table></figure></li>
<li>确认配置文件无误，并存放在/etc/ceph/目录下</li>
<li>启动monitor<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start ceph-mon@mon-node1</span><br></pre></td></tr></table></figure></li>
<li>检查确认<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph -s</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="添加OSD-使用blustore"><a href="#添加OSD-使用blustore" class="headerlink" title="添加OSD, 使用blustore"></a>添加OSD, 使用blustore</h3><p>Create the OSD.<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh &#123;node-name&#125;</span><br><span class="line">sudo ceph-volume lvm create --data &#123;data-path&#125;</span><br></pre></td></tr></table></figure><br>For example:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh node1</span><br><span class="line">sudo ceph-volume lvm create --data /dev/vdc2</span><br></pre></td></tr></table></figure><br><strong>注意：在使用NVMe盘时，其盘符为/dev/nvme0n1之类的，别忘了前面的/dev</strong><br>添加OSD用上面的命令操作就行，也可以分下面两步来做：<br>Prepare the OSD.<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh &#123;node-name&#125;</span><br><span class="line">sudo ceph-volume lvm prepare --data &#123;data-path&#125; &#123;data-path&#125;</span><br></pre></td></tr></table></figure><br>For example:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh node1</span><br><span class="line">sudo ceph-volume lvm prepare --data /dev/vdc2</span><br></pre></td></tr></table></figure><br>Once prepared, the ID and FSID of the prepared OSD are required for activation. These can be obtained by listing OSDs in the current server:<br>sudo ceph-volume lvm list<br>Activate the OSD:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-volume lvm activate &#123;ID&#125; &#123;FSID&#125;</span><br></pre></td></tr></table></figure><br>For example:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-volume lvm activate 0 a7f64266-0894-4f1e-a635-d0aeaca0e993</span><br></pre></td></tr></table></figure></p>
<h3 id="添加OSD-使用filestore"><a href="#添加OSD-使用filestore" class="headerlink" title="添加OSD, 使用filestore"></a>添加OSD, 使用filestore</h3><p><strong>注意：添加OSD时bluestore与filestore二选一就可以了</strong><br>创建osd<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-volume lvm create --filestore --data &#123;data-path&#125; --journal &#123;journal-path&#125;</span><br></pre></td></tr></table></figure><br>prepare osd<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-volume lvm prepare --filestore --data &#123;data-path&#125; --journal &#123;journal-path&#125;</span><br><span class="line">#prepare完成后，可以查看到他的id以及osd的fsid</span><br><span class="line">sudo ceph-volume lvm list</span><br></pre></td></tr></table></figure><br>activate osd<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-volume lvm activate --filestore &#123;ID&#125; &#123;FSID&#125;</span><br><span class="line">#sudo ceph-volume lvm activate --filestore 0 a7f64266-0894-4f1e-a635-d0aeaca0e993</span><br></pre></td></tr></table></figure></p>
<h3 id="添加mgr"><a href="#添加mgr" class="headerlink" title="添加mgr"></a>添加mgr</h3><ol>
<li>添加密钥  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph auth get-or-create mgr.$name mon &#x27;allow profile mgr&#x27; osd &#x27;allow *&#x27; mds &#x27;allow *&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>创建mgr目录并把密钥写入keyring文件中  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /var/lib/ceph/mgr/ceph-$name</span><br><span class="line">#写入刚刚创建的keyring</span><br><span class="line">vim /var/lib/ceph/mgr/ceph-$name/keyring</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动mgr</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph-mgr -i $name</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="安装dashboard"><a href="#安装dashboard" class="headerlink" title="安装dashboard"></a>安装dashboard</h3><ol>
<li><p>安装ceph-mgr-dashboard包，14版本要单独装这个包  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install ceph-mgr-dashboard  </span><br></pre></td></tr></table></figure>
</li>
<li><p>mgr enable dashboad  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph mgr module enable dashboard</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启self证书  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph dashboard create-self-signed-cert</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置用户名登录密码  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph dashboard set-login-credentials admin admin</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成ssl证书  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -new -nodes -x509   -subj &quot;/O=IT/CN=ceph-mgr-dashboard&quot; -days 3650   -keyout dashboard.key -out dashboard.crt -extensions v3_ca</span><br><span class="line">ceph dashboard set-ssl-certificate -i dashboard.crt</span><br><span class="line">ceph dashboard set-ssl-certificate-key -i dashboard.key</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启dashboard  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph mgr module disable dashboard</span><br><span class="line">ceph mgr module enable dashboard</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Ceph安装过程中遇到的问题"><a href="#Ceph安装过程中遇到的问题" class="headerlink" title="Ceph安装过程中遇到的问题"></a>Ceph安装过程中遇到的问题</h2><p>本节主要介绍手动搭建Ceph集群过程中遇到的问题及其解决办法。<br><strong>注：本文操作步骤的实践环境操作系统为debian</strong></p>
<h3 id="1-三台机器安装成功后的Ceph版本不一致"><a href="#1-三台机器安装成功后的Ceph版本不一致" class="headerlink" title="1. 三台机器安装成功后的Ceph版本不一致"></a>1. 三台机器安装成功后的Ceph版本不一致</h3><p>原因：source源的问题<br>解决办法：更新source源之后，apt-get update后，再重新安装</p>
<h3 id="2-有两台机器Ceph无法安装成功，需要其他依赖组件，具体错误见下图"><a href="#2-有两台机器Ceph无法安装成功，需要其他依赖组件，具体错误见下图" class="headerlink" title="2. 有两台机器Ceph无法安装成功，需要其他依赖组件，具体错误见下图"></a>2. 有两台机器Ceph无法安装成功，需要其他依赖组件，具体错误见下图</h3><p><img src="https://z3.ax1x.com/2021/09/30/45v8KJ.png" alt=""><br>描述：三台机器source源设置一样<br>原因：另外两台机器上ceph相关的组件没有卸载干净，通过命令dpkg -l | grep rados可以看到<br>解决办法：将没有卸载干净的组件都卸载掉(apt-get autoremove –purge librados2)，然后apt-get install ceph即可。</p>
<h3 id="3-ceph-mon-error-opening-mon-data-directory-at-‘-var-lib-ceph-mon-ceph-cld-mon1-12002’-13-Permission-denied"><a href="#3-ceph-mon-error-opening-mon-data-directory-at-‘-var-lib-ceph-mon-ceph-cld-mon1-12002’-13-Permission-denied" class="headerlink" title="3. ceph-mon: error opening mon data directory at ‘/var/lib/ceph/mon/ceph-cld-mon1-12002’: (13) Permission denied"></a>3. ceph-mon: error opening mon data directory at ‘/var/lib/ceph/mon/ceph-cld-mon1-12002’: (13) Permission denied</h3><p>出错原因：没有权限，在上一步操作创建目录时，使用“sudo mkdir /var/lib/ceph/mon/{cluster-name}-{hostname}”<br>改为使用“sudo -u ceph mkdir /var/lib/ceph/mon/{cluster-name}-{hostname}”即可。注意：hostname根据实际需要进行修改。</p>
<h3 id="4-三个机器的ceph-mon进程启动以后，使用ceph-s命令无响应（卡住）"><a href="#4-三个机器的ceph-mon进程启动以后，使用ceph-s命令无响应（卡住）" class="headerlink" title="4. 三个机器的ceph-mon进程启动以后，使用ceph -s命令无响应（卡住）"></a>4. 三个机器的ceph-mon进程启动以后，使用ceph -s命令无响应（卡住）</h3><p>查看/var/log/ceph/ceph-mon目录下的日志，可以看到“BADAUTHORIZER”之类的错误，查看各节点上的keyring信息，发现果然keyring不一致。<br>错误原因：在同一个集群使用了不同的keyring导致认证不通过<br>解决办法：同一个集群使用统一的keyring信息，也就是在安装的时候，不用每个节点都去用<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --cap mon &#x27;allow *&#x27; --cap osd &#x27;allow *&#x27; --cap mds &#x27;allow *&#x27; --cap mgr &#x27;allow *&#x27;</span><br></pre></td></tr></table></figure><br>去生成client.admin.keyring，只用在一个节点上生成一次，其他节点也使用该keyring就可以了。<br>统一keyring后，问题得到解决，解决后的图：<br><img src="https://z3.ax1x.com/2021/09/30/45v02D.png" alt=""></p>
<p>关于认证部分，可以看文档<a href="https://docs.ceph.com/en/pacific/architecture/">https://docs.ceph.com/en/pacific/architecture/</a>的“HIGH AVAILABILITY AUTHENTICATION”高可用认证部分。</p>
<h3 id="5-ceph-s出现3-monitors-have-not-enabled-msgr2"><a href="#5-ceph-s出现3-monitors-have-not-enabled-msgr2" class="headerlink" title="5. ceph -s出现3 monitors have not enabled msgr2"></a>5. ceph -s出现3 monitors have not enabled msgr2</h3><p>解决办法：执行ceph mon enable-msgr2<br>msgr2是什么？msgr2是指 msgr2协议，The messenger v2 protocol, or msgr2, is the second major revision on Ceph’s on-wire protocol.老的 Ceph 底层协议是用 SimpleMessenger 实现的，这个协议是它的修订版，解决了性能和安全问题。<br>参考文档：<a href="https://docs.ceph.com/en/latest/rados/configuration/msgr2/">https://docs.ceph.com/en/latest/rados/configuration/msgr2/</a><br><strong>注意把msgr2和mgr区分开，mgr是Ceph的一个新的模块组件。</strong></p>
<h3 id="6-Error-ENOENT-all-mgr-daemons-do-not-support-module-‘dashboard’-pass-–force-to-force-enablement"><a href="#6-Error-ENOENT-all-mgr-daemons-do-not-support-module-‘dashboard’-pass-–force-to-force-enablement" class="headerlink" title="6. Error ENOENT: all mgr daemons do not support module ‘dashboard’, pass –force to force enablement"></a>6. Error ENOENT: all mgr daemons do not support module ‘dashboard’, pass –force to force enablement</h3><p>现象：节点上已经安装了ceph-mgr-dashboard，使用“ceph mgr module enable dashboard”报上面的错误<br>解决办法：所有mgr节点都需要安装, 参考文章：<a href="http://poweroff.cn/ceph/390.html">CEPH 开启MGR监控模块</a></p>
<p><strong>如果所有节点都已经装了ceph-mgr-dashboard，那就再把–force加上</strong></p>
<h3 id="7-使用ceph-s命令报错：Error-initializing-cluster-client-ObjectNotFound-‘error-calling-conf-read-file’"><a href="#7-使用ceph-s命令报错：Error-initializing-cluster-client-ObjectNotFound-‘error-calling-conf-read-file’" class="headerlink" title="7. 使用ceph -s命令报错：Error initializing cluster client: ObjectNotFound(‘error calling conf_read_file’,)"></a>7. 使用ceph -s命令报错：Error initializing cluster client: ObjectNotFound(‘error calling conf_read_file’,)</h3><p>解决办法：把其他节点上的ceph的配置拷贝到该节点（目录：/etc/ceph/ceph.conf）</p>
<h3 id="8-使用ceph-s命令报错：-errno-2-error-connecting-to-the-cluster"><a href="#8-使用ceph-s命令报错：-errno-2-error-connecting-to-the-cluster" class="headerlink" title="8. 使用ceph -s命令报错：[errno 2] error connecting to the cluster"></a>8. 使用ceph -s命令报错：[errno 2] error connecting to the cluster</h3><p>解决办法：在其他可以执行该命令的节点上找到ceph.client.admin.keyring<br>find / -name ceph.client.admin.keyring<br>把该文件拷贝一份到报错节点即可。</p>
<h3 id="9-Error-ENOENT-all-mgr-daemons-do-not-support-module-‘dashboard’-pass-–force-to-force-enablement"><a href="#9-Error-ENOENT-all-mgr-daemons-do-not-support-module-‘dashboard’-pass-–force-to-force-enablement" class="headerlink" title="9. Error ENOENT: all mgr daemons do not support module ‘dashboard’, pass –force to force enablement"></a>9. Error ENOENT: all mgr daemons do not support module ‘dashboard’, pass –force to force enablement</h3><p>解决办法：没有安装ceph-mgr-dashboard，在所有的mgr的节点上安装<br>如果安装上了还不行，就加“–force”。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.ceph.com/en/latest/install/manual-deployment/">Ceph手动安装</a><br><a href="https://docs.ceph.com/en/latest/rados/configuration/msgr2/">https://docs.ceph.com/en/latest/rados/configuration/msgr2/</a><br><a href="https://drunkard.github.io/dev/msgr2/">msgr2协议</a><br><a href="http://poweroff.cn/ceph/390.html">CEPH 开启MGR监控模块</a><br><a href="https://drunkard.github.io/mgr/administrator/">ceph-mgr 管理员指南</a></p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
        <tag>安装</tag>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>清理Ceph环境</title>
    <url>/2021/10/02/%E6%B8%85%E7%90%86Ceph%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/09/30/45zpp8.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍如何清理Ceph环境。  </p>
<h2 id="清理Ceph环境步骤-debian系统"><a href="#清理Ceph环境步骤-debian系统" class="headerlink" title="清理Ceph环境步骤(debian系统)"></a>清理Ceph环境步骤(debian系统)</h2><h3 id="非正常卸载"><a href="#非正常卸载" class="headerlink" title="非正常卸载"></a>非正常卸载</h3><p>每台节点执行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo su -</span><br><span class="line">/etc/init.d/ceph  stop</span><br><span class="line">或者</span><br><span class="line">ps aux|grep ceph ｜grep -v grep |awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -9</span><br><span class="line">ps aux|grep ceph｜grep -v grep |awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -9</span><br><span class="line">rm -rf /var/lib/ceph/osd/*</span><br><span class="line">rm -rf /var/lib/ceph/mon/*</span><br><span class="line">rm -rf /var/lib/ceph/mds/*</span><br><span class="line">rm -rf /var/lib/ceph/bootstrap-mds/*</span><br><span class="line">rm -rf /var/lib/ceph/bootstrap-osd/*</span><br><span class="line">rm -rf /var/lib/ceph/bootstrap-rgw/*</span><br><span class="line">rm -rf /var/lib/ceph/bootstrap-mgr/*</span><br><span class="line">rm -rf /var/lib/ceph/tmp/*</span><br><span class="line">rm -rf /etc/ceph/*</span><br><span class="line">rm -rf /var/run/ceph/*</span><br><span class="line">列出 Ubuntu 和 Debian 上已安装的与Ceph相关的软件包：</span><br><span class="line">apt list --installed | grep ceph</span><br><span class="line"> 删除Ceph相关的软件包：</span><br><span class="line">apt-get autoremove --purge ceph</span><br></pre></td></tr></table></figure></p>
<h3 id="检查是否卸载干净："><a href="#检查是否卸载干净：" class="headerlink" title="检查是否卸载干净："></a>检查是否卸载干净：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpkg -l | grep rados</span><br><span class="line">如果还有继续卸载：</span><br><span class="line">apt-get autoremove –purge librados2</span><br></pre></td></tr></table></figure>
<h3 id="正常卸载"><a href="#正常卸载" class="headerlink" title="正常卸载"></a>正常卸载</h3><p>如果是为了测试，搭建好的ceph环境而且是正常工作的，那么卸载之前安装环境。<br><strong>查看命令帮助</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ceph-mon1 ~]# ceph-deploy -h</span><br><span class="line">uninstall:    </span><br><span class="line">    Remove Ceph packages from remote hosts.(仅仅会卸载ceph软件包)</span><br><span class="line">purge:       </span><br><span class="line">    Remove Ceph packages from remote hosts and purge allData.(卸载ceph软件包而且还会清除所有数据)</span><br><span class="line">Purgedata:   </span><br><span class="line">    Purge (delete, destroy, discard, shred) any Ceph data from /var/lib/ceph(删除所有关于ceph的数据文件位于/var/lib/ceph下)</span><br><span class="line">Forgetkeys:  </span><br><span class="line">    Remove authentication keys from the local directory.(将卸载节点的认证密钥从本地目录移除)&lt;br&gt;&lt;br&gt;&lt;br&gt;示例：</span><br></pre></td></tr></table></figure></p>
<p>一、安装ceph-deploy软件<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnf install ceph-deploy -y</span><br></pre></td></tr></table></figure></p>
<p>二、软件环境：三个节点环境<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#卸载ceph软件包</span><br><span class="line">ceph-deploy purge controller1</span><br><span class="line">ceph-deploy purge controller2</span><br><span class="line">ceph-deploy purge controller3</span><br><span class="line"> </span><br><span class="line">#删除各种配置文件和生成的数据文件</span><br><span class="line">#controller1上面执行</span><br><span class="line">ceph-deploy purgedata controller1</span><br><span class="line">#controller2上面执行</span><br><span class="line">ceph-deploy purgedata controller2</span><br><span class="line">#controller3上面执行</span><br><span class="line">ceph-deploy purgedata controller3</span><br><span class="line"> </span><br><span class="line">#将卸载节点的认证密钥从本地目录移除</span><br><span class="line"></span><br><span class="line">ceph-deploy forgetkeys&lt;br&gt;&lt;br&gt;#检查ceph-mon是否启动</span><br><span class="line">ps -ef|grep ceph  or ps -A|grep ceph&lt;br&gt;&lt;br&gt;#启动ceph-mon</span><br><span class="line">ceph-mon --id=1</span><br></pre></td></tr></table></figure></p>
<p>三、软件环境：单节点环境<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph-deploy purge controller1</span><br><span class="line">ceph-deploy purgedata controller1</span><br><span class="line">ceph-deploy forgetkeys</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>存储</tag>
        <tag>Ceph</tag>
        <tag>清理</tag>
      </tags>
  </entry>
  <entry>
    <title>关于LVM的概念及相关操作</title>
    <url>/2021/10/03/%E5%85%B3%E4%BA%8ELVM%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/15/58RJk6.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍LVM是什么及相关的操作，文末会介绍如何删除Ceph环境上的vg，pv（至于什么是vg和pv，阅读完本文你自然会知道^_^）。</p>
<h2 id="LVM-是什么"><a href="#LVM-是什么" class="headerlink" title="LVM 是什么"></a>LVM 是什么</h2><p>LVM（Logical Volume Manager）逻辑卷管理，是在硬盘分区和文件系统之间添加的一个逻辑层，为文件系统屏蔽下层硬盘分区布局，并提供一个抽象的盘卷，在盘卷上建立文件系统。管理员利用LVM可以在硬盘不用重新分区的情况下动态调整文件系统的大小，并且利用LVM管理的文件系统可以跨越物理硬盘。当服务器添加了新的硬盘后，管理员不必将原有的文件移动到新的硬盘上，而是通过LVM直接扩展文件系统来跨越物理硬盘。</p>
<p>LVM就是通过将底层的物理硬盘封装，然后以逻辑卷的方式呈现给上层应用。当我们对底层的物理硬盘进行操作时，不再是针对分区进行操作，而是通过逻辑卷对底层硬盘进行管理操作。</p>
<h3 id="LVM中的一些基本概念"><a href="#LVM中的一些基本概念" class="headerlink" title="LVM中的一些基本概念"></a>LVM中的一些基本概念</h3><p>通过 LVM 技术，可以屏蔽掉磁盘分区的底层差异，在逻辑上给文件系统提供了一个卷的概念，然后在这些卷上建立相应的文件系统。下面是 LVM 中主要涉及的一些概念。</p>
<ul>
<li><p><strong>物理存储介质（The physical media）</strong>：LVM存储介质，可以是硬盘分区、整个硬盘、raid阵列或SAN硬盘。设备必须初始化为LVM物理卷，才能与LVM结合使用。</p>
</li>
<li><p><strong>物理卷PV（physical volume）</strong>：物理卷就是LVM的基本存储逻辑块，但和基本的物理存储介质比较却包含与LVM相关的管理参数，创建物理卷可以用硬盘分区，也可以用硬盘本身。</p>
</li>
<li><p><strong>卷组VG（Volume Group）</strong>：LVM卷组类似于非LVM系统中的物理硬盘，一个卷组VG由一个或多个物理卷PV组成。可以在卷组VG上建立逻辑卷LV。</p>
</li>
<li><p><strong>逻辑卷LV（logical volume）</strong>：类似于非LVM系统中的硬盘分区，逻辑卷LV建立在卷组VG之上。在逻辑卷LV之上建立文件系统。</p>
</li>
<li><p><strong>物理块PE（physical Extent）</strong>：物理卷PV中可以分配的最小存储单元，PE的大小可以指定，默认为4MB</p>
</li>
<li><p><strong>逻辑块LE（Logical Extent）</strong>：逻辑卷LV中可以分配的最小存储单元，在同一卷组VG中LE的大小和PE是相同的，并且一一对应。</p>
</li>
</ul>
<p>可以这么理解，LVM 是把硬盘的分区分成了更小的单位(PE)，再用这些单元拼成更大的看上去像分区的东西(PV)，进而用 PV 拼成看上去像硬盘的东西(VG)，最后在这个新的硬盘上创建分区(LV)。文件系统则建立在 LV 之上，这样就在物理硬盘和文件系统中间添加了一层抽象(LVM)。下图大致描述了这些概念之间的关系：<br><img src="https://z3.ax1x.com/2021/10/15/582byd.png" alt=""></p>
<p>对上图中的结构做个简单的介绍：两块物理硬盘 A 和 B 组成了 LVM 的底层结构，这两块硬盘的大小、型号可以不同。PV 可以看做是硬盘上的分区，因此可以说物理硬盘 A 划分了两个分区，物理硬盘 B 划分了三个分区。然后将前三个 PV 组成一个卷组 VG1，后两个 PV 组成一个卷组 VG2。接着在卷组 VG1 上划分了两个逻辑 LV1 和 LV2，在卷组 VG2 上划分了一个逻辑卷 LV3。最后，在逻辑卷 LV1、LV2 和 LV3 上创建文件系统，分别挂载在 /usr、/home 和 /var 目录。</p>
<p>下图展示从pv到lv，然后到我们能看见的目录文件，需要经过的过程（由下到上）示意：<br><img src="https://z3.ax1x.com/2021/10/15/582Nss.png" alt=""></p>
<h2 id="删除LVM："><a href="#删除LVM：" class="headerlink" title="删除LVM："></a>删除LVM：</h2><h3 id="1-删除逻辑卷"><a href="#1-删除逻辑卷" class="headerlink" title="1. 删除逻辑卷"></a>1. 删除逻辑卷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lvs</span><br><span class="line">  LV                                             VG                                        Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert</span><br><span class="line">  osd-block-dde657b7-88c6-4cc6-8e04-fae98b1f5472 ceph-03bdcf51-248a-4f09-a131-fcdc4a9a7398 -wi-a----- &lt;7.28t</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lvdisplay</span><br><span class="line">  LV Path                /dev/ceph-03bdcf51-248a-4f09-a131-fcdc4a9a7398/osd-block-dde657b7-88c6-4cc6-8e04-fae98b1f5472</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lvremove /dev/ceph-03bdcf51-248a-4f09-a131-fcdc4a9a7398/osd-block-dde657b7-88c6-4cc6-8e04-fae98b1f5472</span><br><span class="line">Do you really want to remove and DISCARD active logical volume ceph-03bdcf51-248a-4f09-a131-fcdc4a9a7398/osd-block-dde657b7-88c6-4cc6-8e04-fae98b1f5472? [y/n]: y</span><br><span class="line">  Logical volume &quot;osd-block-dde657b7-88c6-4cc6-8e04-fae98b1f5472&quot; successfully removed</span><br></pre></td></tr></table></figure>
<h3 id="2-删除卷组vg"><a href="#2-删除卷组vg" class="headerlink" title="2. 删除卷组vg"></a>2. 删除卷组vg</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pvs</span><br><span class="line">  PV         VG                                        Fmt  Attr PSize  PFree</span><br><span class="line">  /dev/sda   ceph-03bdcf51-248a-4f09-a131-fcdc4a9a7398 lvm2 a--  &lt;7.28t    0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vgremove ceph-03bdcf51-248a-4f09-a131-fcdc4a9a7398</span><br><span class="line">  Volume group &quot;ceph-03bdcf51-248a-4f09-a131-fcdc4a9a7398&quot; successfully removed</span><br></pre></td></tr></table></figure>
<h3 id="3-删除物理卷"><a href="#3-删除物理卷" class="headerlink" title="3.删除物理卷"></a>3.删除物理卷</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pvremove /dev/sda</span><br><span class="line">  Labels on physical volume &quot;/dev/sda&quot; successfully wiped.</span><br></pre></td></tr></table></figure>
<h2 id="清理Ceph环境上的LVM的方法"><a href="#清理Ceph环境上的LVM的方法" class="headerlink" title="清理Ceph环境上的LVM的方法"></a>清理Ceph环境上的LVM的方法</h2><p>其实跟上面清理LVM的方法一致，不过可以写简单的语句，方便快速清理：  </p>
<ul>
<li>删除卷组vg：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in `pvs | grep ceph | awk &#x27;&#123; print $2 &#125;&#x27;`; do vgremove -y $i; done</span><br></pre></td></tr></table></figure>
<ul>
<li>删除物理卷pv：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in `pvs | grep dev | awk &#x27;&#123; print $1 &#125;&#x27;`; do pvremove -y $i; done</span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>做磁盘分区，创建pv，创建vg，创建lv等等操作，请看下面的参考资料，本文就不赘述了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://linux.cn/article-3218-1.html">Linux LVM简明教程</a><br><a href="https://www.cnblogs.com/sparkdev/p/10130934.html">LVM简介</a><br><a href="https://www.cnblogs.com/diantong/p/10554831.html">LVM管理</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph之RBD及CephFS</title>
    <url>/2021/10/04/Ceph%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8RBD%E5%92%8CCephFS/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/04/4OHOYR.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍如何在搭建好的Ceph环境上创建RBD以及如何创建CephFS。  </p>
<h2 id="创建RBD并将其挂载到操作系统"><a href="#创建RBD并将其挂载到操作系统" class="headerlink" title="创建RBD并将其挂载到操作系统"></a>创建RBD并将其挂载到操作系统</h2><h3 id="1、创建rbd使用的pool"><a href="#1、创建rbd使用的pool" class="headerlink" title="1、创建rbd使用的pool"></a>1、创建rbd使用的pool</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#32 32: PG数和PGP数(PG内包含的对象);PG会随着容量的增加也会动态的扩容；生产上需要提前规划好数量</span><br><span class="line">ceph osd pool create rbd  32 32</span><br><span class="line">#给rbd使用的pool标识成rbd</span><br><span class="line">ceph osd pool application enable rbd rbd </span><br><span class="line"></span><br><span class="line">#查看rbd的pool</span><br><span class="line">[root@cephnode01 my-cluster]# ceph osd pool ls detail</span><br><span class="line">pool 5 &#x27;rbd&#x27; replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 32 pgp_num 32 autoscale_mode warn last_change 68 flags hashpspool stripe_width 0</span><br></pre></td></tr></table></figure>
<h3 id="2、创建一个10G的块设备"><a href="#2、创建一个10G的块设备" class="headerlink" title="2、创建一个10G的块设备"></a>2、创建一个10G的块设备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rbd create --size 10240 image01 </span><br></pre></td></tr></table></figure>
<h3 id="3、查看块设备"><a href="#3、查看块设备" class="headerlink" title="3、查看块设备"></a>3、查看块设备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rbd ls</span><br><span class="line">rbd info image01</span><br><span class="line">rados -p rbd ls --all</span><br></pre></td></tr></table></figure>
<h3 id="4、禁用当前系统内核不支持的feature"><a href="#4、禁用当前系统内核不支持的feature" class="headerlink" title="4、禁用当前系统内核不支持的feature"></a>4、禁用当前系统内核不支持的feature</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rbd feature disable image01 exclusive-lock, object-map, fast-diff, deep-flatten</span><br></pre></td></tr></table></figure>
<h3 id="5、将块设备映射到系统内核"><a href="#5、将块设备映射到系统内核" class="headerlink" title="5、将块设备映射到系统内核"></a>5、将块设备映射到系统内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rbd map image01 </span><br><span class="line">rbd showmapped</span><br></pre></td></tr></table></figure>
<h3 id="6、格式化块设备镜像"><a href="#6、格式化块设备镜像" class="headerlink" title="6、格式化块设备镜像"></a>6、格式化块设备镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs.xfs /dev/rbd0</span><br></pre></td></tr></table></figure>
<h3 id="7、mount到本地"><a href="#7、mount到本地" class="headerlink" title="7、mount到本地"></a>7、mount到本地</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/rbd0 /mnt</span><br></pre></td></tr></table></figure>
<h3 id="8、创建文件并查看"><a href="#8、创建文件并查看" class="headerlink" title="8、创建文件并查看"></a>8、创建文件并查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@cephnode01 my-cluster]# touch /mnt/&#123;a..g&#125;lcx.txt</span><br><span class="line">[root@cephnode01 my-cluster]# rados -p rbd ls --all</span><br><span class="line">    rbd_data.28209e4598ff7.0000000000000500</span><br><span class="line">    rbd_id.image01</span><br><span class="line">    rbd_header.28209e4598ff7</span><br><span class="line">    rbd_data.28209e4598ff7.0000000000000820</span><br><span class="line">    rbd_directory</span><br><span class="line">    rbd_data.28209e4598ff7.0000000000000460</span><br><span class="line">    rbd_data.28209e4598ff7.00000000000006e0</span><br><span class="line">    rbd_info</span><br><span class="line">    rbd_data.28209e4598ff7.00000000000000a0</span><br><span class="line">    rbd_data.28209e4598ff7.00000000000009ff</span><br><span class="line">    rbd_data.28209e4598ff7.00000000000005a0</span><br><span class="line">    rbd_data.28209e4598ff7.0000000000000000</span><br><span class="line">    rbd_data.28209e4598ff7.0000000000000780</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="9、取消块设备和内核映射"><a href="#9、取消块设备和内核映射" class="headerlink" title="9、取消块设备和内核映射"></a>9、取消块设备和内核映射</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">umount /mnt</span><br><span class="line">rbd unmap image01 </span><br></pre></td></tr></table></figure>
<h3 id="10、删除RBD块设备"><a href="#10、删除RBD块设备" class="headerlink" title="10、删除RBD块设备"></a>10、删除RBD块设备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rbd rm image01</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果想在其他机器上使用ceph块设备需要下载ceph-common客户端</p>
</blockquote>
<h2 id="创建CephFS"><a href="#创建CephFS" class="headerlink" title="创建CephFS"></a>创建CephFS</h2><h3 id="启动MDS（MDS是CephFS使用的元数据管理服务）"><a href="#启动MDS（MDS是CephFS使用的元数据管理服务）" class="headerlink" title="启动MDS（MDS是CephFS使用的元数据管理服务）"></a>启动MDS（MDS是CephFS使用的元数据管理服务）</h3><p>创建CephFS需要MDS，首先介绍MDS的启动：</p>
<h4 id="1-创建mds存放目录"><a href="#1-创建mds存放目录" class="headerlink" title="1. 创建mds存放目录"></a>1. 创建mds存放目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/lib/ceph/mds/&#123;cluster-name&#125;-&#123;id&#125;</span><br><span class="line">例如：</span><br><span class="line">mkdir -p /var/lib/ceph/mds/ceph-jchuan-ceph-1</span><br></pre></td></tr></table></figure>
<h4 id="2-创建keyring"><a href="#2-创建keyring" class="headerlink" title="2. 创建keyring"></a>2. 创建keyring</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph-authtool --create-keyring /var/lib/ceph/mds/&#123;cluster-name&#125;-&#123;id&#125;/keyring --gen-key -n mds.&#123;id&#125;</span><br><span class="line">例如：</span><br><span class="line">ceph-authtool --create-keyring /var/lib/ceph/mds/ceph-jchuan-ceph-1/keyring --gen-key -n mds.jchuan-ceph-1</span><br></pre></td></tr></table></figure>
<h4 id="3-导入keyring并设置权限"><a href="#3-导入keyring并设置权限" class="headerlink" title="3. 导入keyring并设置权限"></a>3. 导入keyring并设置权限</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph auth add mds.&#123;id&#125; osd &quot;allow rwx&quot; mds &quot;allow&quot; mon &quot;allow profile mds&quot; -i /var/lib/ceph/mds/&#123;cluster&#125;-&#123;id&#125;/keyring</span><br><span class="line">chmod 644 /var/lib/ceph/mds/&#123;cluster&#125;-&#123;id&#125;/keyring</span><br><span class="line">例如：</span><br><span class="line">ceph auth add mds.jchuan-ceph-1 osd &quot;allow rwx&quot; mds &quot;allow&quot; mon &quot;allow profile mds&quot; -i /var/lib/ceph/mds/ceph-jchuan-ceph-1/keyring</span><br></pre></td></tr></table></figure>
<h4 id="4-添加到ceph-conf"><a href="#4-添加到ceph-conf" class="headerlink" title="4. 添加到ceph.conf"></a>4. 添加到ceph.conf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mds.&#123;id&#125;]</span><br><span class="line">host = &#123;id&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-安装ceph-mds-原文档少了这一步，执行下一步就会启动不成功，因为找不到ceph-mds"><a href="#5-安装ceph-mds-原文档少了这一步，执行下一步就会启动不成功，因为找不到ceph-mds" class="headerlink" title="5. 安装ceph-mds(原文档少了这一步，执行下一步就会启动不成功，因为找不到ceph-mds)"></a>5. 安装ceph-mds(原文档少了这一步，执行下一步就会启动不成功，因为找不到ceph-mds)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install ceph-mds</span><br></pre></td></tr></table></figure>
<h4 id="6-手动启动进程或者直接用systemctl启动"><a href="#6-手动启动进程或者直接用systemctl启动" class="headerlink" title="6. 手动启动进程或者直接用systemctl启动"></a>6. 手动启动进程或者直接用systemctl启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start ceph-mds@jchuan-ceph-1</span><br><span class="line">或者</span><br><span class="line">ceph-mds --cluster &#123;cluster-name&#125; -i &#123;id&#125; -m &#123;mon-hostname&#125;:&#123;mon-port&#125; [-f]</span><br></pre></td></tr></table></figure>
<h3 id="创建启用CephFS"><a href="#创建启用CephFS" class="headerlink" title="创建启用CephFS"></a>创建启用CephFS</h3><p>Ceph文件系统至少需要两个RADOS池，一个用于数据，一个用于元数据</p>
<h4 id="1-创建数据pool"><a href="#1-创建数据pool" class="headerlink" title="1. 创建数据pool"></a>1. 创建数据pool</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph osd pool create cephfs_data 256 256</span><br></pre></td></tr></table></figure>
<h4 id="2-创建Metadata池"><a href="#2-创建Metadata池" class="headerlink" title="2. 创建Metadata池"></a>2. 创建Metadata池</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph osd pool create cephfs_metadata 128 128</span><br></pre></td></tr></table></figure>
<h4 id="3-启用pool"><a href="#3-启用pool" class="headerlink" title="3. 启用pool"></a>3. 启用pool</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ceph fs new cephfs cephfs_metadata cephfs_data</span><br></pre></td></tr></table></figure>
<h4 id="4-挂载CephFS"><a href="#4-挂载CephFS" class="headerlink" title="4. 挂载CephFS"></a>4. 挂载CephFS</h4><p>挂载CephFS可以使用FUSE client或者kernel client(挂载cephfs有两种方式，kernel driver和fuse):<br>FUSE client是最容易访问的，也是最容易升级到存储集群使用的Ceph版本的，而kernel client能够提供更好的性能。<br>当遇到bug或者性能问题时，尝试使用其他客户端通常是有指导意义的，以便查明bug是否属于特定的客户端(然后让开发人员知道)。   </p>
<p><strong>挂载CephFS前的通用先决条件：</strong><br>在挂载CephFS前，确保client机器（将挂载和使用CephFS的那台机器）有一份Ceph配置文件的复本（即ceph.conf）以及一个CephX用户有权限访问MDS的keyring。这两个文件必须已经存在于Ceph MON所在的主机上。<br>（1）为客户端主机生成一个最小的conf文件，并将其放在一个标准位置(如果已经存在ceph.conf就忽略该步骤):<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># on client host</span><br><span class="line">mkdir -p -m 755 /etc/ceph</span><br><span class="line">ssh &#123;user&#125;@&#123;mon-host&#125; &quot;sudo ceph config generate-minimal-conf&quot; | sudo tee /etc/ceph/ceph.conf</span><br></pre></td></tr></table></figure></p>
<p>（2）调整配置文件的权限<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 644 /etc/ceph/ceph.conf</span><br></pre></td></tr></table></figure></p>
<p>(3) 创建一个CephX用户并获取其密钥<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh &#123;user&#125;@&#123;mon-host&#125; &quot;sudo ceph fs authorize cephfs client.foo / rw&quot; | sudo tee /etc/ceph/ceph.client.foo.keyring</span><br></pre></td></tr></table></figure></p>
<p>在上面的命令中，用你自己的CephFS的名字取代“cephfs”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建完成后可以通过ceph auth list 查看keyring跟文件里面是否一致，权限是否正常</span><br><span class="line">chmod 600 /etc/ceph/ceph.client.foo.keyring</span><br></pre></td></tr></table></figure>
<p>(4) 用kernel driver挂载CephFS<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/mycephfs</span><br><span class="line">mount -t ceph :/ /mnt/mycephfs -o name=foo</span><br></pre></td></tr></table></figure><br>使用ceph-fuse挂载参考文档：<a href="https://docs.ceph.com/en/latest/cephfs/mount-using-fuse/">https://docs.ceph.com/en/latest/cephfs/mount-using-fuse/</a></p>
<h4 id="遇到的错误及解决办法"><a href="#遇到的错误及解决办法" class="headerlink" title="遇到的错误及解决办法"></a>遇到的错误及解决办法</h4><ol>
<li><p>遇到错误“unable to get monitor info from DNS SRV with service name: ceph-mon”<br><strong>原因</strong>：配置文件ceph.conf中没有相关的配置信息<br><strong>解决办法</strong>：去其他正常节点拷贝一份配置文件过来即可</p>
</li>
<li><p>遇到错误“[errno 2] error connecting to the cluster”<br><strong>解决办法</strong>：在其他可以执行该命令的节点上找到ceph.client.admin.keyring<br>find / -name ceph.client.admin.keyring<br>把该文件拷贝一份到报错节点即可。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/712e58d36a77">Ceph—RBD块设备介绍与创建</a><br><a href="https://cloud.tencent.com/developer/article/1592961">探索RBD块存储接口</a><br><a href="https://durantthorvalds.top/2021/01/17/2021117-「核心」Ceph学习三部曲之八：分布式文件系统CephFS/">分布式文件系统CephFS</a><br><a href="https://docs.ceph.com/en/latest/cephfs/mount-using-fuse/">ceph-fuse挂载参考文档</a></p>
]]></content>
      <categories>
        <category>分布式存储</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
        <tag>RBD</tag>
        <tag>CephFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（一）基本概念</title>
    <url>/2021/10/07/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/08/5PjK0g.png" alt=""></p>
<span id="more"></span>
<p>从本文开始要介绍一些ZFS的特性。<br>本文主要介绍ZFS中的VDEVs概念和存储池，并提供了几个使用不同VDEVs创建zpool的实例。</p>
<h2 id="虚拟设备介绍（Virtual-Device-Introduction）"><a href="#虚拟设备介绍（Virtual-Device-Introduction）" class="headerlink" title="虚拟设备介绍（Virtual Device Introduction）"></a>虚拟设备介绍（Virtual Device Introduction）</h2><p>首先，我们需要理解虚拟设备(或VDEVs)的概念，因为ZFS在内部广泛使用它们。如果您已经熟悉RAID，那么这个概念对您来说并不新鲜，尽管您可能没有将其称为“VDEVs”。基本上，我们有一个元设备，它代表一个或多个物理设备。在Linux软件RAID中，您可能有一个“/dev/md0”设备，它表示由4个磁盘组成的RAID-5阵列。在本例中，“/dev/md0”将是您的“VDEV”。</p>
<p>ZFS中有七种类型的VDEVs:  </p>
<ol>
<li>disk(默认)–系统中的物理硬盘驱动器。 </li>
<li>file–预分配文件/映像的绝对路径。 </li>
<li>mirror–标准软件RAID-1镜像。 </li>
<li>raidz1/2/3–非标准的分布式基于校验的软件RAID级别。 </li>
<li>spare–标记为ZFS软件RAID的“hot spare”的硬盘。</li>
<li>cache–用于2级自适应读缓存(L2ARC)的设备。</li>
<li>log – 一个单独的日志(SLOG)称为“ZFS intent log”或ZIL。</li>
</ol>
<p>需要注意的是，VDEVs总是动态条带的。理解这一点，当我们讨论下面的命令时，您将更容易看懂。举个例子，假设一个ZFS条带中有4个磁盘。条带大小是根据磁盘个数和阵列中磁盘的大小计算的。如果增加了更多的磁盘，可以根据需要调整条带大小。因此，条纹具有动态属性。</p>
<h2 id="存储池ZFS-pool-zpool"><a href="#存储池ZFS-pool-zpool" class="headerlink" title="存储池ZFS pool(zpool)"></a>存储池ZFS pool(zpool)</h2><p>与大多数文件系统不同，ZFS 结合了文件系统和卷系统管理器的功能。这意味着与其他文件系统不同，ZFS 可以创建跨越一系列驱动器或池的文件系统。不仅如此，还可以通过添加另一个驱动器将存储添加到池中。</p>
<h3 id="一些zpool的注意事项"><a href="#一些zpool的注意事项" class="headerlink" title="一些zpool的注意事项"></a>一些zpool的注意事项</h3><ul>
<li>一旦一个设备被添加到VDEV后，它将不能被移除</li>
<li>你不能缩小zpool，只能增大它。 </li>
<li>RAID-0比RAID-1快，RAID-1比RAIDZ-1快，RAIDZ-2比RAIDZ-3快。 </li>
<li>热备份(hot spares)不会动态添加，除非启用该设置，默认情况下该设置是关闭的。 </li>
<li>当更大的磁盘填满池时，zpool不会动态调整大小，除非在第一次替换磁盘之前启用了设置，该设置在默认情况下是关闭的。 </li>
<li>当且仅当驱动器报告“高级格式”4K扇区驱动器时，zpool才知道。 </li>
<li>重复数据删除非常昂贵，如果没有安装足够的RAM，将导致性能下降，而且是池范围的，而不是本地文件系统。</li>
<li>另一方面，压缩在CPU上非常便宜，但默认情况下是禁用的。 </li>
<li>ZFS受到碎片的严重影响，完整的zpool将“感受到”性能下降。 </li>
<li>ZFS本身支持加密，但它不是自由软件。它是由甲骨文公司拥有的专有版权。</li>
</ul>
<h3 id="一些zpool例子"><a href="#一些zpool例子" class="headerlink" title="一些zpool例子"></a>一些zpool例子</h3><p>对于下一个例子，我们将假设4个驱动器:/dev/sde， /dev/sdf， /dev/sdg和/dev/sdh，都是8gb USB u盘。在每个命令之间，如果您正在执行下面的操作，那么请确保在每个部分的末尾执行清理步骤。</p>
<h4 id="一个简单的zpool"><a href="#一个简单的zpool" class="headerlink" title="一个简单的zpool"></a>一个简单的zpool</h4><p>用4个盘创建一个名叫“tank”的zpool，命令如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool create tank sde sdf sdg sdh</span><br></pre></td></tr></table></figure><br>在这个例子中，使用了4个硬盘VDEVs（虚拟设备）。注意，我没有使用完整的设备路径（也可以使用完整路径）。由于VDEVs总是动态地条带化，这实际上是四个盘之间的RAID-0(没有冗余)。<br>我们可以用如下命令检查zpool的状态:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool status tank</span><br><span class="line"> pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">	NAME        STATE     READ WRITE CKSUM</span><br><span class="line">	tank        ONLINE       0     0     0</span><br><span class="line">	  sde       ONLINE       0     0     0</span><br><span class="line">	  sdf       ONLINE       0     0     0</span><br><span class="line">	  sdg       ONLINE       0     0     0</span><br><span class="line">	  sdh       ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>销毁zpool用如下命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destory tank</span><br></pre></td></tr></table></figure></p>
<h4 id="一个简单的镜像池"><a href="#一个简单的镜像池" class="headerlink" title="一个简单的镜像池"></a>一个简单的镜像池</h4><p>在这个例子中，我希望镜像所有四个驱动器(/dev/sde， /dev/sdf， /dev/sdg和/dev/sdh)。因此，我将使用“镜像”，而不是使用磁盘VDEV。命令如下:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create tank mirror sde sdf sdg sdh</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">	NAME        STATE     READ WRITE CKSUM</span><br><span class="line">	tank        ONLINE       0     0     0</span><br><span class="line">	  mirror-0  ONLINE       0     0     0</span><br><span class="line">	    sde     ONLINE       0     0     0</span><br><span class="line">	    sdf     ONLINE       0     0     0</span><br><span class="line">	    sdg     ONLINE       0     0     0</span><br><span class="line">	    sdh     ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>注意，“mirror-0”现在是VDEV，由它管理每个物理设备。如前所述，这类似于Linux软件RAID“/dev/md0”设备表示四个物理设备。现在让我们清理我们的池，并创建另一个。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy tank</span><br></pre></td></tr></table></figure></p>
<h4 id="虚拟设备嵌套"><a href="#虚拟设备嵌套" class="headerlink" title="虚拟设备嵌套"></a>虚拟设备嵌套</h4><p>VDEVs可以嵌套。RAID10是一个完美的例子。RAID10就是先镜像然后再条带化。为了指定VDEVs嵌套，可以执行如下命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create tank mirror sde sdf mirror sdg sdh</span><br><span class="line"># zpool status</span><br><span class="line">  pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">	NAME        STATE     READ WRITE CKSUM</span><br><span class="line">	tank        ONLINE       0     0     0</span><br><span class="line">	  mirror-0  ONLINE       0     0     0</span><br><span class="line">	    sde     ONLINE       0     0     0</span><br><span class="line">	    sdf     ONLINE       0     0     0</span><br><span class="line">	  mirror-1  ONLINE       0     0     0</span><br><span class="line">	    sdg     ONLINE       0     0     0</span><br><span class="line">	    sdh     ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>第一个VDEV是“mirror-0”，它管理/dev/sde和/dev/sdf，这是通过调用“mirror sde sdf”来实现的。第二个VDEV是“mirror-1”，它管理/dev/sdg和/dev/sdg。这是通过“mirror sdg sdh”实现的。因为VDEVs总是动态地条带化，所以“mirror-0”和“mirror-1”都是条带化的，因此创建了RAID-1+0设置。在继续之前不要忘记清理:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy tank</span><br></pre></td></tr></table></figure></p>
<h4 id="文件虚拟设备"><a href="#文件虚拟设备" class="headerlink" title="文件虚拟设备"></a>文件虚拟设备</h4><p>如上所述，在现有的ext4文件系统(或其他文件系统)的预分配的文件可以用来设置zpool。需要注意的是，这完全是为了测试目的，而不是为了存储生产数据。<br>使用文件是一个用沙箱的好方法，在沙箱中，您可以测试压缩比、重复数据删除表的大小或其他东西，而无需实际向其提交生产数据。在创建文件VDEVs时，不能使用相对路径，必须使用绝对路径。此外，映像文件必须是预分配的，而不是稀疏文件或瘦配置文件。让我们看看它是如何工作的:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># for i in &#123;1..4&#125;; do dd if=/dev/zero of=/tmp/file$i bs=1G count=4 &amp;&gt; /dev/null; done</span><br><span class="line"># zpool create tank /tmp/file1 /tmp/file2 /tmp/file3 /tmp/file4</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">	NAME          STATE     READ WRITE CKSUM</span><br><span class="line">	tank          ONLINE       0     0     0</span><br><span class="line">	  /tmp/file1  ONLINE       0     0     0</span><br><span class="line">	  /tmp/file2  ONLINE       0     0     0</span><br><span class="line">	  /tmp/file3  ONLINE       0     0     0</span><br><span class="line">	  /tmp/file4  ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>在本例中，我们创建了一个RAID-0。我们使用使用/dev/zero的预分配文件，每个文件的大小为4GB。因此，在可用空间中，zpool的大小是16 GB。与使用磁盘的第一个示例一样，每个文件都是VDEV。当然，您可以将这些文件视为磁盘，并将它们放入镜像配置，比如RAID-1+0、RAIDZ-1(将在下一篇文章中介绍)等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy tank</span><br></pre></td></tr></table></figure>
<h4 id="混合池"><a href="#混合池" class="headerlink" title="混合池"></a>混合池</h4><p>最后一个示例应该向您展示可以通过使用不同的vdev设置的复杂池。使用前面示例中的四个文件VDEVs和四个磁盘VDEVs /dev/sde到/dev/sdh，让我们创建一个带有缓存和日志驱动器的混合池。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create tank mirror /tmp/file1 /tmp/file2 mirror /tmp/file3 /tmp/file4 log mirror sde sdf cache sdg sdh</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">	NAME            STATE     READ WRITE CKSUM</span><br><span class="line">	tank            ONLINE       0     0     0</span><br><span class="line">	  mirror-0      ONLINE       0     0     0</span><br><span class="line">	    /tmp/file1  ONLINE       0     0     0</span><br><span class="line">	    /tmp/file2  ONLINE       0     0     0</span><br><span class="line">	  mirror-1      ONLINE       0     0     0</span><br><span class="line">	    /tmp/file3  ONLINE       0     0     0</span><br><span class="line">	    /tmp/file4  ONLINE       0     0     0</span><br><span class="line">	logs</span><br><span class="line">	  mirror-2      ONLINE       0     0     0</span><br><span class="line">	    sde         ONLINE       0     0     0</span><br><span class="line">	    sdf         ONLINE       0     0     0</span><br><span class="line">	cache</span><br><span class="line">	  sdg           ONLINE       0     0     0</span><br><span class="line">	  sdh           ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>这里有很多东西，我们来分析一下。首先，我们使用四个预先分配的映像文件创建一个RAID-1+0。请注意vdev“mirror-0”和“mirror-1”，以及它们管理的是什么。其次，我们创建了名为“mirror-2”的第三个VDEV，它实际上并不用于在池中存储数据，而是用作ZFS intent log或ZIL。我们将在另一篇文章中更详细地讨论ZIL。然后我们创建了两个用于缓存数据的vdev，分别称为“sdg”和“sdh”。这些是我们已经了解过的标准磁盘vdev。但是，它们也由“cache”VDEV管理。因此，在本例中，我们使用了上面列出的7个vdev中的6个，唯一缺少的是“spare”。</p>
<p>注意缩进将帮助您了解VDEV在管理什么。“tank”池由用于长期持久存储的“mirror-0”和“mirror-1”VDEVs组成。ZIL由“mirror-2”镜像，它由/dev/sde和/dev/sdf组成。只读cache VDEV由两个磁盘管理:/dev/sdg和/dev/sdg。“日志”和“缓存”都不是池的长期存储，因此创建了一个“混合池”设置。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy tank</span><br></pre></td></tr></table></figure></p>
<h4 id="真实环境中的例子"><a href="#真实环境中的例子" class="headerlink" title="真实环境中的例子"></a>真实环境中的例子</h4><p>在生产中，文件将是物理磁盘，而ZIL和缓存将是快速ssd。这里是我当前的zpool设置：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool status pool</span><br><span class="line">  pool: pool</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: scrub repaired 0 in 2h23m with 0 errors on Sun Dec  2 02:23:44 2012</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME                                              STATE     READ WRITE CKSUM</span><br><span class="line">        pool                                              ONLINE       0     0     0</span><br><span class="line">          raidz1-0                                        ONLINE       0     0     0</span><br><span class="line">            sdd                                           ONLINE       0     0     0</span><br><span class="line">            sde                                           ONLINE       0     0     0</span><br><span class="line">            sdf                                           ONLINE       0     0     0</span><br><span class="line">            sdg                                           ONLINE       0     0     0</span><br><span class="line">        logs</span><br><span class="line">          mirror-1                                        ONLINE       0     0     0</span><br><span class="line">            ata-OCZ-REVODRIVE_OCZ-33W9WE11E9X73Y41-part1  ONLINE       0     0     0</span><br><span class="line">            ata-OCZ-REVODRIVE_OCZ-X5RG0EIY7MN7676K-part1  ONLINE       0     0     0</span><br><span class="line">        cache</span><br><span class="line">          ata-OCZ-REVODRIVE_OCZ-33W9WE11E9X73Y41-part2    ONLINE       0     0     0</span><br><span class="line">          ata-OCZ-REVODRIVE_OCZ-X5RG0EIY7MN7676K-part2    ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>请注意，我的“日志”和“缓存”VDEV是OCZ Revodrive ssd，而四个盘片磁盘位于RAIDZ-1 VDEV中(RAIDZ将在下一篇文章中讨论)。但是，请注意，ssd的名称是“ata-OCZ-REVODRIVE_OCZ-33W9WE11E9X73Y41-part1”等等。可以在/dev/disk/by-id/中找到。我选择这些而不是“sdb”和“sdc”的原因是缓存和日志设备不一定存储相同的ZFS元数据。因此，当在引导时创建池时，它们可能不会进入池，并且可能会丢失。或者，主板可能以不同的顺序分配驱动器号。这在主池的不是个什么大问题，但在有日志和缓存设备的GNU/Linux上是一个大问题。使用/dev/disk/by-id/下的设备名称可以确保更大的持久性和唯一性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍的基本概念是了解zpool和VDEVs基本知识的好的开始。掌握了基本概念，剩下的知识都会比较容易些。你已经克服了理解ZFS如何处理池存储的“大障碍”。后面单独的文章我们需要进一步讨论RAIDZ级别，还需要更深入地讨论日志和缓存设备，以及池设置(如重复数据删除和压缩)。然后我们可以进入ZFS文件系统数据集、了解它们的设置以及优缺点。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/04/zfs-administration-part-i-vdevs/">https://pthree.org/2012/12/04/zfs-administration-part-i-vdevs/</a>  </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>初探ZFS</title>
    <url>/2021/10/06/%E5%88%9D%E6%8E%A2ZFS/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/08/5PjK0g.png" alt=""></p>
<span id="more"></span>
<p>从本文主要简单介绍ZFS，从本文起，将开始一个新的系列，我把这个系列叫ZFS系列，本文只是一个引子。  </p>
<h2 id="ZFS是什么"><a href="#ZFS是什么" class="headerlink" title="ZFS是什么"></a>ZFS是什么</h2><p>ZFS 是一个先进的文件系统。因此，它有一些有趣的特性。比如：</p>
<ul>
<li>存储池</li>
<li>写时拷贝</li>
<li>快照</li>
<li>数据完整性验证和自动修复</li>
<li>RAID-Z</li>
<li>最大单个文件大小为 16 EB（1 EB = 1024 PB）</li>
<li>最大 256 千万亿（256*1015 ）的 ZB（1 ZB = 1024 EB）的存储</li>
</ul>
<p>ZFS的命名来源发想于”Zettabyte File System”的首字母缩写。但ZFS本身并不具备任何的缩写意涵，只是作者想阐述做为一个具备高扩展容量文件系统且还有支持许多延伸功能的一个产品。</p>
<h2 id="ZFS的历史"><a href="#ZFS的历史" class="headerlink" title="ZFS的历史"></a>ZFS的历史</h2><p>ZFS（以前是：Zettabyte文件系统）结合了一个文件系统和一个卷管理器。它在2001年开始作为Sun Microsystems Solaris操作系统的一部分。Solaris的大部分内容–包括ZFS–从2005年起在开放源码许可下作为OpenSolaris发布了大约5年，然后在2009/2010年甲骨文公司收购Sun时被置于一个封闭源码许可下。在2005年至2010年期间，ZFS的开源版本被移植到Linux、Mac OS X（继续作为MacZFS）和FreeBSD。2010年，illumos项目fork了OpenSolaris的一个最新版本，以继续其作为一个开源项目的发展，包括ZFS。2013年，OpenZFS成立，以协调开源ZFS的发展。OpenZFS维护和管理核心的ZFS代码，而使用ZFS的组织维护特定的代码和验证过程，以使ZFS集成到他们的系统中。OpenZFS被广泛用于类似Unix的系统中。</p>
<h2 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h2><h3 id="存储池"><a href="#存储池" class="headerlink" title="存储池"></a>存储池</h3><p>与大多数文件系统不同，ZFS 结合了文件系统和卷管理器的特性。这意味着，它与其他文件系统不同，ZFS 可以创建跨越一系列硬盘或池的文件系统。不仅如此，你还可以通过添加硬盘来增大池的存储容量。此外，ZFS还可以进行分区和格式化。<br><img src="https://z3.ax1x.com/2021/10/15/510qMT.png" alt=""></p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>写时拷贝(Copy-on-write)是另一个有趣并且很酷的特性。在大多数文件系统上，当数据被重写时，它将永久丢失。而在 ZFS 中，新数据会写到不同的块。写完成之后，更新文件系统元数据信息，使之指向新的数据块（译注：COW也是实现快照的一种方式）。这确保了如果在写新数据的时候系统崩溃（或者发生其它事，比如突然断电），那么原数据将会保存下来。这也意味着，在系统发生崩溃之后，不需要运行 fsck 来检查和修复文件系统。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>写时拷贝使得 ZFS 有了另一个特性： 快照(snapshots)。ZFS 使用快照来跟踪文件系统中的更改。快照包含文件系统的原始版本（文件系统的一个只读版本），实时文件系统则包含了自从快照创建之后的任何更改。没有使用额外的空间。因为新数据将会写到实时文件系统新分配的块上。如果一个文件被删除了，那么它在快照中的索引也会被删除。所以，快照主要是用来跟踪文件的更改，而不是文件的增加和创建。</p>
<p>快照可以挂载成只读的，以用来恢复一个文件的过去版本。实时文件系统也可以回滚到之前的快照。回滚之后，自从快照创建之后的所有更改将会丢失。</p>
<h3 id="数据完整性验证和自动修复"><a href="#数据完整性验证和自动修复" class="headerlink" title="数据完整性验证和自动修复"></a>数据完整性验证和自动修复</h3><p>当向 ZFS 写入新数据时，会创建该数据的校验和。在读取数据的时候，使用校验和进行验证。如果前后校验和不匹配，那么就说明检测到了错误，然后，ZFS 会尝试自动修正错误。</p>
<h3 id="RAID-Z"><a href="#RAID-Z" class="headerlink" title="RAID-Z"></a>RAID-Z</h3><p>ZFS 不需要任何额外软件或硬件就可以处理 RAID（磁盘阵列）。毫不奇怪，因为 ZFS 有自己的 RAID 实现：RAID-Z 。RAID-Z 是 RAID-5 的一个变种，不过它克服了 RAID-5 的写漏洞：意外重启之后，数据和校验信息会变得不同步（译注：RAID-5 的条带在正写入数据时，如果这时候电源中断，那么奇偶校验数据将跟该部分数据不同步，因此前边的写无效；RAID-Z 用了 “可变宽的 RAID 条带” 技术，因此所有的写都是全条带写入）。为了使用基本级别的 RAID-Z（RAID-Z1），你需要至少三块磁盘，其中两块用来存储数据，另外一块用来存储奇偶校验信息。而 RAID-Z2 需要至少两块磁盘存储数据以及两块磁盘存储校验信息。RAID-Z3 需要至少两块磁盘存储数据以及三块磁盘存储校验信息。另外，只能向 RAID-Z 池中加入偶数倍的磁盘，而不能是奇数倍的。</p>
<h3 id="巨大的存储潜力"><a href="#巨大的存储潜力" class="headerlink" title="巨大的存储潜力"></a>巨大的存储潜力</h3><p>创建 ZFS 的时候，它是作为最后一个文件系统而设计的 。那时候，大多数文件系统都是 64 位的，ZFS 的创建者决定直接跳到 128 位，等到将来再来证明这是对的。这意味着 ZFS 的容量大小是 32 位或 64 位文件系统的 1600 亿亿倍。事实上，Jeff Bonwick（其中一个创建者）说：“完全填满一个 128 位的存储池所需要的能量，从字面上讲，比煮沸海洋需要的还多。”</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是简要介绍ZFS是什么和一些特性，更详细的解析请看ZFS系列后面的文章，也可以看本文列出的参考资料。<br>其中<a href="https://segmentfault.com/a/1190000040585071">存储大师班 | ZFS存储池块管理与事务模型</a>介绍得比较全面，还涉及到了一些具体的细节，也列出了很多参考资料，值得一看。<br><a href="https://farseerfc.me/zhs/zfs-layered-architecture-design.html">ZFS 分层架构设计</a>这篇文章讲了ZFS的整体架构和多个特性，此外文章中还有ZFS的创始人的视频，可以一看（视频是YouTube上的,你懂的）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/ZFS">ZFS维基百科</a>  </p>
<p><a href="https://zhuanlan.zhihu.com/p/45137745">初学者指南：ZFS 是什么，为什么要使用 ZFS？</a></p>
<p><a href="https://segmentfault.com/a/1190000040585071">存储大师班 | ZFS存储池块管理与事务模型</a></p>
<p><a href="https://farseerfc.me/zhs/zfs-layered-architecture-design.html">ZFS 分层架构设计</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>FUSE介绍</title>
    <url>/2021/10/05/FUSE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/08/5PILFK.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍：</p>
<ul>
<li>FUSE的基本概念</li>
<li>为什么需要FUSE</li>
<li>FUSE的原理</li>
<li>如何使用FUSE</li>
<li>常见的FUSE实现有哪些</li>
</ul>
<h2 id="FUSE-是什么？"><a href="#FUSE-是什么？" class="headerlink" title="FUSE 是什么？"></a>FUSE 是什么？</h2><p> FUSE 是 Filesystem in Userspace 的缩写，也就是常说的<strong>用户态文件系统</strong>。<br><a href="https://www.kernel.org/doc/html/latest/filesystems/fuse.html">Linux内核官方文档</a>对 FUSE 的解释如下：</p>
<blockquote>
<p>What is FUSE?FUSE is a userspace filesystem framework. It consists of a kernel module (fuse.ko), a userspace library (libfuse.*) and a mount utility (fusermount).</p>
</blockquote>
<p><strong>划重点：FUSE 是一个用户空间文件系统的框架</strong>，这套框架包含3个组件：</p>
<ol>
<li><strong>内核模块 fuse.ko</strong> ：用来接收VFS传递下来的IO请求，并且把这个IO封装之后通过管道发送到用户态；</li>
<li><strong>用户态 lib 库 libfuse</strong> ：解析内核态转发出来的协议包，拆解成常规的 IO 请求；</li>
<li><strong>mount 工具 fusermount</strong> ；</li>
</ol>
<p>这 3 个组件一起完成一件事：可以在用户态实现文件系统，并且让IO在内核态和用户态文件系统之间自由穿梭。</p>
<h2 id="为什么会需要FUSE"><a href="#为什么会需要FUSE" class="headerlink" title="为什么会需要FUSE"></a>为什么会需要FUSE</h2><p>FUSE被称为用户空间文件系统，为什么要强调用户空间呢？接触过Linux内核的同学大概会知道，早期的文件系统开发只能在内核中。文件系统一般是实现在内核里面的，比如，Ext4、Fat32、NTFS(Kernel原生版)等常见的文件系统，其代码都在内核中，内核开发的难点在于调试和排查故障，而FUSE特殊之处就是，其文件系统的<strong>核心逻辑</strong>是在<strong>用户空间</strong>实现的。</p>
<p>有了FUSE之后，我们就可以在用户态空间实现文件系统。<br>其优点是：开发调试效率高，不会出现内核态那种出现bug很容易就导致OS重启的情况。<br>缺点是：会损失性能</p>
<h3 id="内核文件系统"><a href="#内核文件系统" class="headerlink" title="内核文件系统"></a>内核文件系统</h3><p>早期的文件系统是位于内核之中， 处于VFS之下，块设备之上的一个位置。对上呈现文件存储实现，对下管理裸块设备。也就是说早期文件系统是内核的一个模块。那就可以理解了，内核模块的开发之所以艰难就是难在<strong>调试和排障</strong>，用户态的程序你可以随意 debug，出问题最多也就是 panic，coredump，内核态的程序出了问题就是宕机（我早期在做存储驱动开发的时候受够了内核驱动开发的苦，一出问题存储设备重启，要差不多20分钟才能重启起来，然后再去dmesg看日志信息，排查问题很麻烦），所有现场都丢失，你只能通过日志，kdump 等手段来排查。</p>
<h4 id="没有FUSE的IO流程示意图"><a href="#没有FUSE的IO流程示意图" class="headerlink" title="没有FUSE的IO流程示意图"></a>没有FUSE的IO流程示意图</h4><p>下图是没有FUSE的时候，IO经过内核文件系统的一个大概流程<br><img src="https://z3.ax1x.com/2021/10/08/5PocXd.gif" alt=""></p>
<p>比较详细的流程图<br><img src="https://z3.ax1x.com/2021/10/08/5PTLxe.png" alt=""></p>
<h4 id="带FUSE的IO流程示意图"><a href="#带FUSE的IO流程示意图" class="headerlink" title="带FUSE的IO流程示意图"></a>带FUSE的IO流程示意图</h4><p>注意：图中简化了用户态之上的逻辑处理。</p>
<p><img src="https://z3.ax1x.com/2021/10/08/5P7td1.gif" alt=""></p>
<h2 id="FUSE-原理"><a href="#FUSE-原理" class="headerlink" title="FUSE 原理"></a>FUSE 原理</h2><p>首先看一眼 wiki 上有对 FUSE 的 ls -l /tmp/fuse 命令的演示图：<br><img src="https://z3.ax1x.com/2021/10/08/5P70zD.png" alt=""><br>这个图的意思是：</p>
<ol>
<li>背景：一个用户态文件系统，挂载点为 /tmp/fuse ，用户二进制程序文件为 ./hello（该二进制程序可以理解为用户自己根据自身需求实现的文件系统）; </li>
<li>当执行 ls -l /tmp/fuse 命令的时候，流程如下：<br>(1) IO 请求先进内核，经VFS传递给内核 FUSE 文件系统模块；<br>(2) 内核 FUSE 模块把请求发给到用户态，由 ./hello 程序接收并且处理。处理完成之后，响应原路返回；</li>
</ol>
<p>简化的 IO 动画示意图：<br><img src="https://z3.ax1x.com/2021/10/08/5P7OYV.gif" alt=""><br>通过这两张图，对 FUSE IO 的流程应该就清晰了，内核 FUSE 模块在内核态中间做协议封装和协议解析的工作，它接收从VFS下来的请求并按照 FUSE 协议转发到用户态，然后接收用户态的响应，并随后回复给用户。<br>FUSE在这条IO路径是做了一个透明中转站的作用，用户完全不感知这套框架。我们把中间的 FUSE 当作一个黑盒遮住，就更容易理解了。</p>
<h3 id="fuse-ko和libfuse库的作用"><a href="#fuse-ko和libfuse库的作用" class="headerlink" title="fuse.ko和libfuse库的作用"></a>fuse.ko和libfuse库的作用</h3><p>这两个模块一个位于内核，一个位于用户态，是配套使用的，最核心的功能是<strong>协议封装和解析</strong>。</p>
<p>举个例子，内核 fuse.ko用于接收VFS下来的IO请求，然后封装成 FUSE 数据包，转发给用户态。这个时候，用户态文件系统收到这个 FUSE 数据包，它如果想要看懂这个数据包，就必须实现一套FUSE协议的代码，这套代码是公开透明的，属于FUSE框架的公共的代码，这种代码不需要让所有的用户文件系统都重复实现一遍，于是libfuse库就诞生了。</p>
<h3 id="FUSE-协议格式"><a href="#FUSE-协议格式" class="headerlink" title="FUSE 协议格式"></a>FUSE 协议格式</h3><p>接下来我们看下FUSE数据传输的数据格式（FUSE协议的格式），请求包和响应包是什么样子的？</p>
<h4 id="FUSE-请求包"><a href="#FUSE-请求包" class="headerlink" title="FUSE 请求包"></a>FUSE 请求包</h4><p>FUSE 请求包分为两部分：  </p>
<ol>
<li>Header ： 这个是所有请求共用的，比如 open 请求，read 请求，write 请求，getxattr 请求，头部都至少有这个结构体，Header 结构体能描述整个 FUSE 请求，其中字段能区分请求类型；  </li>
<li>Payload ：这个东西是每个 IO 类型会是不同的，比如 read 请求就没这个，write 请求就有这个，因为 write 请求是携带数据的；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type inHeader struct &#123;  </span><br><span class="line">Len    uint32</span><br><span class="line">Opcode uint32  </span><br><span class="line">Unique uint64  </span><br><span class="line">Nodeid uint64  </span><br><span class="line">Uid    uint32  </span><br><span class="line">Gid    uint32  </span><br><span class="line">Pid    uint32  </span><br><span class="line">_      uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Len: 是整个请求的字节数长度（Header + Payload）</li>
<li>Opcode: 请求的类型，比如区分 open、read、write 等等；</li>
<li>Unique: 请求唯一标识（和响应中要对应）</li>
<li>Nodeid: 请求针对的文件 nodeid，目标文件或者文件夹的 nodeid；</li>
<li>Uid: 文件/文件夹操作的进程的用户 ID</li>
<li>Gid: 文件/文件夹操作的进程的用户组 ID</li>
<li>Pid: 文件/文件夹操作的进程的进程 ID</li>
</ul>
<h4 id="FUSE-响应包"><a href="#FUSE-响应包" class="headerlink" title="FUSE 响应包"></a>FUSE 响应包</h4><p>FUSE 响应包也分为两部分：  </p>
<ol>
<li>Header ：这个结构体也是在数据头部的，所有 IO 类型的响应都至少有这个结构体。该结构体用于描述整个响应请求；   </li>
<li>Payload ：每个请求的类型可能不同，比如 read 请求就会有这个，因为要携带 read 出来的用户数据，write 请求就不会有；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type outHeader struct &#123;  </span><br><span class="line">Len    uint32  </span><br><span class="line">Error  int32  </span><br><span class="line">Unique uint64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>Len: 整个响应的字节数长度（ Header + Payload ）；</li>
<li>Error: 响应错误码，成功返回 0，其他对应着系统的错误代码，负数；</li>
<li>Unique: 对应者请求的唯一标识，和请求对应；</li>
</ul>
<h3 id="内核态、用户态的纽带"><a href="#内核态、用户态的纽带" class="headerlink" title="内核态、用户态的纽带"></a>内核态、用户态的纽带</h3><p>现在对数据协议的格式，转发和转运的模块我们也知道了。现在还差一个关键的点：数据包的通道，换句话说，内核模块的“包裹”发到哪里？用户程序又从哪里读取拿到这个“包裹”。</p>
<p><strong>答案是：/dev/fuse ，这个虚设备文件就是内核模块和用户程序的桥梁</strong>。</p>
<p>这样一切都顺理成章了，整个过程中，用户的IO通过正常的系统调用进来，走到内核文件系统FUSE，FUSE文件系统把这个IO请求按照FUSE协议封装起来，打包成特定的格式，通过 /dev/fuse 这个管道传递到用户态。在此之前有守护进程监听这个管道，看到有消息出来之后，立马读出来，然后利用libfuse库解析协议，之后就是用户文件系统的代码逻辑了。</p>
<p>该过程示意图如下（省略了拆解包的步骤）：<br><img src="https://z3.ax1x.com/2021/10/08/5PLFkn.gif" alt=""></p>
<h2 id="FUSE-的使用"><a href="#FUSE-的使用" class="headerlink" title="FUSE 的使用"></a>FUSE 的使用</h2><p>现在我们知道了 FUSE 框架的 3 大组件，FUSE 的数据包协议，现在就尝试着使用一下 FUSE 文件系统。</p>
<blockquote>
<p>以下命令在 ubuntu 16 版本上执行的。</p>
</blockquote>
<h3 id="Linux-内核是否支持？"><a href="#Linux-内核是否支持？" class="headerlink" title="Linux 内核是否支持？"></a>Linux 内核是否支持？</h3><p>前面说过内核里面也有一个 fuse.ko 模块，这个模块是公用的，内核的位置也是位于文件系统层。我们想要自制一个文件系统，那么第一步需要确保内核支持这个模块。可以直接运行如下命令，如果没有报错，说明你的 Linux 机器支持 fuse 模块，并且已经加载。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# modprobe fuse</span><br></pre></td></tr></table></figure></p>
<p>如果当前 Linux 不支持这个内核模块，那么就会报错，比如（ubuntu16）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# modprobe xyz</span><br><span class="line">modprobe: FATAL: Module xyz not found in directory /lib/modules/4.4.0-142-generic</span><br></pre></td></tr></table></figure></p>
<p>或者也可以去目录<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/lib/modules/4.4.0-142-generic/kernel/fs/ </span><br></pre></td></tr></table></figure><br>里看是否有 fuse 这个目录。</p>
<h3 id="挂载FUSE内核文件系统，便于管理"><a href="#挂载FUSE内核文件系统，便于管理" class="headerlink" title="挂载FUSE内核文件系统，便于管理"></a>挂载FUSE内核文件系统，便于管理</h3><p>FUSE这个内核文件系统其实是可以挂载，也可以不挂载，挂载了主要是方便管理多个用户系统而已，FUSE内核文件系统的 Type 名称为 fusectl，挂载命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t fusectl none /sys/fs/fuse/connections</span><br></pre></td></tr></table></figure></p>
<p>可以用 df -aT 命令查看：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# df -aT|grep -i fusectl</span><br><span class="line">fusectl                     fusectl              0        0         0    - /sys/fs/fuse/connections</span><br></pre></td></tr></table></figure></p>
<p>通过挂载内核 fuse 文件系统，可以看到所有实现的用户文件系统，如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# ls -l /sys/fs/fuse/connections/</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 root root 0 May 29 19:58 39</span><br><span class="line">dr-x------ 2 root root 0 May 29 20:00 42</span><br></pre></td></tr></table></figure></p>
<p>在 /sys/fs/fuse/connections 对应两个目录，目录名为 Unique ID，能够唯一标识一个用户文件系统。这里表示内核 fuse 模块通过 /dev/fuse 设备文件，建立了两个通信管道，分别对应了两个用户文件系统，可以在用 df -aT 对照确认：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# df -aT|grep -i fuse</span><br><span class="line">fusectl                     fusectl              0        0         0    - /sys/fs/fuse/connections</span><br><span class="line">lxcfs                       fuse.lxcfs           0        0         0    - /var/lib/lxcfs</span><br><span class="line">helloworld                  fuse.hellofs         0        0         0    - /mnt/myfs</span><br></pre></td></tr></table></figure></p>
<p>每个 Uniqe ID 名录下，有若干个文件，通过这些文件，我们可以获取到当前用户文件系统的状态，或跟 fuse 文件系统交互，比如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# ls -l /sys/fs/fuse/connections/42/</span><br><span class="line">total 0</span><br><span class="line">--w------- 1 root root 0 May 29 20:00 abort</span><br><span class="line">-rw------- 1 root root 0 May 29 20:00 congestion_threshold</span><br><span class="line">-rw------- 1 root root 0 May 29 20:00 max_background</span><br><span class="line">-r-------- 1 root root 0 May 29 20:00 waiting</span><br></pre></td></tr></table></figure></p>
<ul>
<li>waiting 文件：cat 一下就能获取到当前正在处理的 IO 请求数；</li>
<li>abort 文件：该文件写入任何字符串，都会终止这个用户文件系统和上面所有的请求；</li>
</ul>
<h3 id="用户文件系统怎么挂载？"><a href="#用户文件系统怎么挂载？" class="headerlink" title="用户文件系统怎么挂载？"></a>用户文件系统怎么挂载？</h3><p>用户文件系统怎么挂载（比如上面的 hellofs 和 lxcfs ）？</p>
<p>这就需要用到了 FUSE 框架的第3个组件了，fusermount 工具，这个工具就是专门用来方便挂载用户文件系统才诞生的。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fusermount -o fsname=helloworld,subtype=hellofs -- /mnt/myfs/</span><br></pre></td></tr></table></figure></p>
<p>FUSE 的作用在于使用户能够绕开内核代码来编写文件系统，但是请注意，文件系统要实现对具体的设备的操作的话必须要使用设备驱动提供的接口，而设备驱动位于内核空间，这时可以直接读写块设备文件，就相当于只把文件系统摘到用户态，用户直接管理块设备空间。</p>
<h2 id="FUSE-能做什么？"><a href="#FUSE-能做什么？" class="headerlink" title="FUSE 能做什么？"></a>FUSE 能做什么？</h2><p>通过上面的介绍，这个问题应该很好回答，就是有了FUSE后，理论上我们能在用户态实现我们想实现的文件系统。<br>FUSE 能够把VFS 下来的IO请求转发到用户态，用户程序处理之后，经由 FUSE 框架回应给用户。有了FUSE后，我们就可以把文件系统的实现全部放到用户态实现了。</p>
<h2 id="FUSE-的实现有哪些？"><a href="#FUSE-的实现有哪些？" class="headerlink" title="FUSE 的实现有哪些？"></a>FUSE 的实现有哪些？</h2><p>实现了 FUSE 的用户态文件系统有非常多的例子，比如，GlusterFS，SSHFS，CephFS，Lustre，GmailFS，EncFS，S3FS等等</p>
<p>上面这些都是实现了 fuse 的用户态程序：</p>
<ul>
<li>GmailFS 可以让我们管理文件一样，管理邮件；</li>
<li>S3FS 可以让我们管理文件一样，管理对象；</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章，我们了解了 FUSE 的知识点，总结如下：</p>
<ol>
<li>FUSE框架就是内核开发者为了能在用户态进行文件系统开发的需求开发出来的；</li>
<li>FUSE 框架的3大组件分别是：内核 fuse 模块，用户态 libfuse 库，fusermount 挂载工具；</li>
<li>内核FUSE模块用于接收VFS的请求，并且通过 /dev/fuse 建立的管道，把封装后的请求发往用户态；</li>
<li>libfuse 则是用户态封装用来解析 FUSE 数据包协议的库代码，服务于所有的用户态文件系统；</li>
<li>/dev/fuse 就是连接内核 fuse 和用户态文件系统的纽带；</li>
<li>fusermount 则是用户态文件系统用来挂载的工具</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.kernel.org/doc/html/latest/filesystems/fuse.html">Linux内核官方FUSE介绍</a><br><a href="https://xie.infoq.cn/article/655c0893ed150ff65f2b7a16f">FUSE 文件系统</a><br><a href="https://www.jianshu.com/p/c2b77d0bbc43">FUSE(Filesystem in Userspace)</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>用户态</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（二）ZAIDZ</title>
    <url>/2021/10/08/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89ZAIDZ/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/09/5k68JJ.png" alt=""></p>
<span id="more"></span>
<p>介绍RAIDZ之前，首先需要我们对标准的RAID有一个了解，知道它有什么问题。如果标准的RAID很完美，那么就不需要再搞一个RAIDZ出来了。<br>本文主要介绍标准的RAID存在什么问题，然后介绍RAIDZ有什么特点，以及几种常见的RAIDZ和如何创建RAIDZ的zpool。</p>
<h2 id="标准的基于奇偶检验的RAID"><a href="#标准的基于奇偶检验的RAID" class="headerlink" title="标准的基于奇偶检验的RAID"></a>标准的基于奇偶检验的RAID</h2><p>为了理解RAIDZ，首先需要理解基于奇偶检验的RAID级别，比如RAID5和RAID6。先看一下标准RAID-5的布局。RAID-5至少需要3块硬盘。在2个硬盘上，数据被条带化。然后计算一个奇偶校验位，其结果是集合中所有三个条带的异或，然后将奇偶校验写入磁盘。这种情况允许一个磁盘故障，并可以重新计算恢复数据。此外，在RAID-5中，阵列中没有单个硬盘专门用于校验数据。而是把奇偶校验分布在所有的磁盘上。因此，任何磁盘都可能发生故障，但数据仍然可以恢复。<br>然而，还是有个问题。假设在RAID-5分条中写入数据，但在写入奇偶校验之前发生了断电。您现在有了不一致的数据。ZFS的创建者Jeff Bonwick将此称为“RAID-5 write hole”。实际上，对于所有基于奇偶校验的RAID阵列来说，无论多小，这都是一个问题。如果存在写入数据块而不写入奇偶位的任何可能性，那么我们就有“write hole”。糟糕的是，基于软件的RAID不知道存在这个问题。现在，有一些软件可以识别奇偶校验与数据不一致，但它们很慢并且也不可靠。因此，基于软件的RAID已经不再受到存储管理员的青睐。相反，昂贵(而且容易发生故障)的且带有备份电源的硬件卡，已经变得司空见惯。</p>
<p>除了上面的问题，还有一个很大的性能问题需要处理。如果正在写入分条的数据小于分条的大小，则必须从分条的其余部分读取数据，并重新计算奇偶校验。这将导致您读写与应用程序无关的数据。<br>不是只读取活的、运行的数据，而是花大量时间读取“死的”或旧的数据。因此，昂贵的电池支持的NVRAM硬件RAID卡可以向用户隐藏这个延迟，然而NVRAM缓冲区只有在这个条带数据被刷到磁盘前有效。</p>
<p>由于有这两种缺陷：RAID-5写入漏洞和将数据写入小于条带大小的磁盘，ZFS的原子事务性质不喜欢硬件解决方案，因为这是不可能的，也不喜欢现有的软件解决方案，因为它可能导致数据损坏。因此，需要重新考虑基于奇偶校验的RAID。</p>
<h2 id="ZFS-RAIDZ"><a href="#ZFS-RAIDZ" class="headerlink" title="ZFS RAIDZ"></a>ZFS RAIDZ</h2><p>RAIDZ与RAID5不同，RAIDZ不是在创建时静态设置条带宽度，而是动态设置条带宽度。每个以事务方式刷新到磁盘的块都有自己的条带宽度。每次RAIDZ写都是一次全分条写。并且，奇偶校验位与条带同时刷新，完全消除RAID-5“write hole”问题。所以，在停电的情况下，你要么有最新的数据刷新，要么没有。但是，磁盘不会是不一致的。</p>
<p><img src="https://z3.ax1x.com/2021/10/09/5k6rJH.png" alt=""></p>
<p>然而，这里有一个陷阱。使用标准化的基于奇偶校验的RAID，逻辑就像“每个磁盘XORs为零”一样简单。对于动态可变条带宽度(如RAIDZ)，这是不行的。相反，我们必须提取ZFS元数据来确定每次读取时的RAIDZ条带大小等信息。如果您注意的话，您会注意到，如果文件系统和RAID是独立的产品，那么这种情况是不可能的;您的RAID卡不知道您的文件系统，反之亦然。这就是ZFS胜出的原因。</p>
<p>而且，由于ZFS了解底层RAID，除非磁盘已满，否则性能不会成为问题。读取文件系统元数据以构建RAID分条意味着只读取实时运行的数据。不需要担心读取“死”数据或未分配的空间。因此，文件系统的元数据遍历在许多方面实际上可以更快。您不需要昂贵的NVRAM来缓冲写操作，也不需要它作为RAID “write hole”时的电池备份。因此，ZFS又回到了“廉价磁盘冗余阵列”的老承诺。事实上，强烈建议您使用便宜的SATA磁盘，而不是昂贵的光纤通道或用于ZFS的SAS磁盘。</p>
<h3 id="有自愈能力的RAID"><a href="#有自愈能力的RAID" class="headerlink" title="有自愈能力的RAID"></a>有自愈能力的RAID</h3><p>假设由于某种原因，阵列中的磁盘上有坏数据。ZFS可以检测无声错误，并动态地修复它们。这就是我成为ZFS粉丝的最大原因。当应用程序请求数据时，ZFS构造我们上面了解到的条带，并将每个块与元数据中的默认校验值(当前为fletcher4)进行比较。如果读到的条带校验值不匹配，ZFS会找到损坏的块，然后读取奇偶校验，并通过组合重构修复它。然后它将修复的数据返回给应用程序。这一切都是在ZFS本身中完成的，无需特殊硬件的帮助。</p>
<p>RAIDZ级别的另一个方面是，如果条带比阵列中的磁盘长，如果出现磁盘故障，则没有足够的具有奇偶校验的数据可以重建数据。因此，ZFS将在条带中镜像一些数据，以防止这种情况发生。</p>
<p>同样，如果您的RAID和文件系统是独立的产品，那么它们并不知道彼此，因此检测和修复静默数据错误是不可能的。因此，解决了RAIDZ的基本概念问题之后，让我们构建一些RAIDZ池。和我之前的文章一样，我将使用5个USB u盘/dev/sde， /dev/sdf， /dev/sdg， /dev/sdh和/dev/sdi，它们的大小都是8GB。</p>
<h3 id="RAIDZ-1"><a href="#RAIDZ-1" class="headerlink" title="RAIDZ-1"></a>RAIDZ-1</h3><p>RAIDZ-1类似于RAID-5，它有一个分布在阵列中所有磁盘上的奇偶校验位。条带宽度是可变的，可以覆盖阵列中磁盘的某一确切宽度，可以覆盖更少的磁盘，也可以覆盖更多的磁盘，如上面的图所示。RAIDZ-1能容忍一个磁盘损坏而不丢失数据。2个硬盘故障，可能导致数据丢失。RAIDZ-1要求硬盘数不少于3块。存储的容量将是数组中的磁盘数量乘以最小磁盘的存储容量，减去一个奇偶校验磁盘(我将在另一篇文章中讨论zpool存储容量大小的注意事项)。所以在我的例子中，我应该有大约16GB的可用磁盘。<br> 为了设置一个带有raidz1的zpool，我们使用“raidz1”VDEV，在本例中只使用3个USB驱动器:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create tank raidz1 sde sdf sdg</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: pool</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME          STATE     READ WRITE CKSUM</span><br><span class="line">        pool          ONLINE       0     0     0</span><br><span class="line">          raidz1-0    ONLINE       0     0     0</span><br><span class="line">            sde       ONLINE       0     0     0</span><br><span class="line">            sdf       ONLINE       0     0     0</span><br><span class="line">            sdg       ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>继续之前清理刚创建的zpool<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy tank</span><br></pre></td></tr></table></figure></p>
<h3 id="RAIDZ-2"><a href="#RAIDZ-2" class="headerlink" title="RAIDZ-2"></a>RAIDZ-2</h3><p>RAIDZ-2与RAID-6相似，在阵列中的所有磁盘上都有一个双奇偶校验位。条带宽度是可变的，可以覆盖阵列中磁盘的某一确切宽度，可以覆盖更少的磁盘，也可以覆盖更多的磁盘。RAIDZ-2能容忍最多两盘故障。如果出现3盘故障，将导致数据丢失。RAIDZ-2至少需要4块硬盘。<br>存储的容量将是阵列中的磁盘数量乘以最小磁盘的存储容量，减去两个奇偶校验磁盘。所以在我的例子中，我应该有大约16GB的可用磁盘。<br>为了使用RAIDZ-2设置zpool，我们使用“raidz2”VDEV:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create tank raidz2 sde sdf sdg sdh</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: pool</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME          STATE     READ WRITE CKSUM</span><br><span class="line">        pool          ONLINE       0     0     0</span><br><span class="line">          raidz2-0    ONLINE       0     0     0</span><br><span class="line">            sde       ONLINE       0     0     0</span><br><span class="line">            sdf       ONLINE       0     0     0</span><br><span class="line">            sdg       ONLINE       0     0     0</span><br><span class="line">            sdh       ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>清理环境<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy tank</span><br></pre></td></tr></table></figure></p>
<h3 id="RAIDZ-3"><a href="#RAIDZ-3" class="headerlink" title="RAIDZ-3"></a>RAIDZ-3</h3><p>RAIDZ-3没有可以与之比较的标准化RAID级别。但是，它是RAIDZ-1和RAIDZ-2的逻辑延续，因为在阵列中的所有磁盘上都有一个三重奇偶校验位。条带宽度是可变的，可以覆盖阵列中磁盘的确切宽度，也可以覆盖更少的磁盘，也可以覆盖更多的磁盘，如上图所示。RAIDZ-3能容忍3盘故障。4块硬盘故障，会导致数据丢失。 RAIDZ-3至少需要5块硬盘。存储的容量将是阵列中的磁盘数量乘以最小磁盘的存储，减去3个奇偶校验磁盘。所以在我的例子中，我应该有大约16GB的可用磁盘。<br> 为了使用RAIDZ-3设置zpool，我们使用“raidz3”VDEV:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create tank raidz3 sde sdf sdg sdh sdi</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: pool</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME          STATE     READ WRITE CKSUM</span><br><span class="line">        pool          ONLINE       0     0     0</span><br><span class="line">          raidz3-0    ONLINE       0     0     0</span><br><span class="line">            sde       ONLINE       0     0     0</span><br><span class="line">            sdf       ONLINE       0     0     0</span><br><span class="line">            sdg       ONLINE       0     0     0</span><br><span class="line">            sdh       ONLINE       0     0     0</span><br><span class="line">            sdi       ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>清理环境<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy tank</span><br></pre></td></tr></table></figure></p>
<h3 id="混合RAIDZ"><a href="#混合RAIDZ" class="headerlink" title="混合RAIDZ"></a>混合RAIDZ</h3><p>不幸的是，基于奇偶校验的RAID速度很慢，特别是在单个条带中有许多磁盘时(例如48磁盘的JBOD)。为了提高速度，将单个大型RAIDZ VDEV分割为多个RAIDZ VDEV的条带可能不是一个坏主意。这将消耗您可用的磁盘空间来存储，但可以极大地提高性能。当然，与前面的RAIDZ VDEV一样，每个嵌套的RAIDZ VDEV中的条带宽度是可变的。对于每个RAIDZ级别，您可以在每个VDEV中丢失最多这么多磁盘。因此，如果您有一个由三个RAIDZ-1 VDEV组成的条带，那么您总共可以容忍三个磁盘故障，每个VDEV一个磁盘故障。可用空间的计算方法类似。在本例中，由于每个VDEV中的奇偶校验存储，您将减去三个磁盘空间（因为用来存储校验数据了）。</p>
<p> 为了说明这个概念，让我们假设我们有一个12磁盘的存储服务器，我们希望在最大化条带性能的同时损失尽可能少的磁盘。因此，我们将创建4个RAIDZ-1 vdev，每个RAIDZ-1包含3个磁盘。这将使占用我们4个可用于存储数据的磁盘（用于存储校验数据），但它也将使我们能够承受4个磁盘故障，并且跨4个vdev的条带将会提高性能。</p>
<p>为了设置一个带有4个raidz1 VDEV的zpool，我们在命令中使用了4次“raidz1”VDEV。注意，为了清晰起见，我强调了什么时候在命令中输入”raidz1”:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create tank raidz1 sde sdf sdg raidz1 sdh sdi sdj raidz1 sdk sdl sdm raidz1 sdn sdo sdp</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: pool</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME          STATE     READ WRITE CKSUM</span><br><span class="line">        pool          ONLINE       0     0     0</span><br><span class="line">          raidz1-0    ONLINE       0     0     0</span><br><span class="line">            sde       ONLINE       0     0     0</span><br><span class="line">            sdf       ONLINE       0     0     0</span><br><span class="line">            sdg       ONLINE       0     0     0</span><br><span class="line">          raidz1-1    ONLINE       0     0     0</span><br><span class="line">            sdh       ONLINE       0     0     0</span><br><span class="line">            sdi       ONLINE       0     0     0</span><br><span class="line">            sdj       ONLINE       0     0     0</span><br><span class="line">          raidz1-2    ONLINE       0     0     0</span><br><span class="line">            sdk       ONLINE       0     0     0</span><br><span class="line">            sdl       ONLINE       0     0     0</span><br><span class="line">            sdm       ONLINE       0     0     0</span><br><span class="line">          raidz1-3    ONLINE       0     0     0</span><br><span class="line">            sdn       ONLINE       0     0     0</span><br><span class="line">            sdo       ONLINE       0     0     0</span><br><span class="line">            sdp       ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>注意，现在有四个RAIDZ-1 VDEVs。正如在之前的文章中提到的，ZFS条带跨多个VDEVs。因此，这个设置本质上是RAIDZ-1+0。每个RAIDZ-1 VDEV将接收发送到池的数据的1/4，然后每个条带块将在每个VDEV中的磁盘上进一步条带化。嵌套的VDEVs可以在池被大规模分段之后很长一段时间保持良好的性能。</p>
<p>清理环境<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy tank</span><br></pre></td></tr></table></figure></p>
<h3 id="关于RAIDZ的一些想法"><a href="#关于RAIDZ的一些想法" class="headerlink" title="关于RAIDZ的一些想法"></a>关于RAIDZ的一些想法</h3><p>关于何时使用RAIDZ-1/2/3，何时不使用，存在各种建议。有人说RAIDZ-1和RAIDZ-3应该使用奇数个硬盘。RAIDZ-1至少3块硬盘，且不超过7块硬盘;RAIDZ-3可以7用块盘，且不超过15块硬盘。RAIDZ-2应该使用偶数个磁盘，从6个磁盘开始，不能超过12个。这是为了确保实际写入数据的磁盘数量是偶数，并最大化阵列的性能。</p>
<p>如果超出这些建议，我个人会使用RAID-1+0设置。这很大程度上是由于重建数据所需要的时间(称为“resilvering”——后面会有文章介绍这个)。由于计算奇偶校验位非常昂贵，因此与RAID-1+0相比，RAIDZ数组中的磁盘越多，该操作的成本就越高。</p>
<p>此外，我还看到了关于磁盘大小的建议，说RAIDZ-1每个磁盘不超过1TB, RAIDZ-2每个磁盘不超过2TB, RAIDZ-3每个磁盘不超过3TB。对于超过这些值的大小的，应该使用带条纹的2路或3路镜像。我不能确定这些说法是否有效。但是，我可以告诉您，在磁盘数量较少的情况下，您应该使用能够适应您的缺点的RAID级别。在4盘RAID阵列中，如前所述，计算多个奇偶校验位会降低性能。此外，4盘RAID最多能容忍两个磁盘故障(如果使用RAID-1+0或RAIDZ-2)。RAIDZ-1介于两者之间，在这种情况下，可以容忍单个磁盘故障，同时仍然保持良好的性能水平。如果数组中有12个磁盘，那么可能更适合RAIDZ-1+0或RAIDZ-3，因为出现多个磁盘故障的几率会增加。</p>
<p> 最后，您需要理解你的存储问题并对你的硬盘进行基准测试。将它们放在不同的RAID配置中，并使用IOZone 3等工具对阵列进行基准测试和压力测试。你需要知道要在磁盘上存储什么数据。你要知道磁盘安装在什么类型的硬件上。你要知道你需要什么样的性能表现。这是你的决定，如果你花时间做研究、作业和调查，你会得出正确的决定。可能有“最佳实践”，但它们只适用于某种具体情况。<strong>总之，就是说每个人需要根据自己的性能需求，硬盘性能和硬件能力来选择最适合他们自己的RAID配置</strong>。</p>
<p>最后，在性能方面，镜像的读和写总是优于RAIDZ级别。此外，RAIDZ-1将优于RAIDZ-2，而RAIDZ-2将优于RAIDZ-3。需要计算的奇偶校验位越多，读取和写入数据所需的时间就越长。当然，您总是可以在VDEVs中添加条带以最大化某些性能。嵌套的RAID级别(如RAID-1+0)被认为是“RAID级别中的凯迪拉克”，这是由于可以在没有奇偶校验的情况下丢失磁盘的灵活性和从条带获得的吞吐量。因此，简而言之，从最快到最慢的排序如下：</p>
<ul>
<li>RAID-0 (fastest)</li>
<li>RAID-1</li>
<li>RAIDZ-1</li>
<li>RAIDZ-2</li>
<li>RAIDZ-3 (slowest)</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RAIDZ尽管和RAID5有很多地方类似，但是RAIDZ并不是RAID5.<br>RAID5的缺陷：  </p>
<ol>
<li>RAID5最显著的缺点就是<strong>“write hole”</strong>，因为他无法提供任何安全的机制保证写校验码的时候不出现故障。而如果此时断电，那么将造成parity是错误的，当然后期利用这个错误的parity更新的新的数据块将更是错误的。而此时用户并不知道。  </li>
<li>RAID5另一个问题是性能问题。如果正在写入分条的数据小于分条的大小，则必须从分条的其余部分读取数据，并重新计算奇偶校验。这将导致读写与应用程序无关的数据。</li>
</ol>
<p>RAIDZ具有两个显著的特点<br><strong>特点一</strong>：<br>避免了读旧数据-修改parity-写数据的RAID写磁盘模式，而是通过full stripe write的方式完成写数据操作。这样一次性写入 保证了即使断电，也不会出现不一致的状况。要么写成功，要么什么都没做。<br><strong>特点二</strong>：<br>就是动态条带化的特点。抛弃的传统的stripe都是固定长度的特点。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/05/zfs-administration-part-ii-raidz/">https://pthree.org/2012/12/05/zfs-administration-part-ii-raidz/</a>  </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（三）ZFS intent log</title>
    <url>/2021/10/09/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89ZFS%20intent%20log/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/09/5kRU9e.png" alt=""></p>
<span id="more"></span>
<p>本文介绍ZFS intent log（ZIL），SLOG，以及如何往zpool添加SLOG虚拟设备。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>在开始之前，我们需要弄清楚一些术语，这些术语出现在论坛、博客文章、邮件列表和一般讨论中似乎会让人们感到困惑。直到写这篇文章之前，尽管我明白最终目标是什么，这些术语有时也让我很困惑。所以，让我们来看看这些术语:</p>
<ul>
<li>ZFS Intent Log或者叫ZIL，一种日志记录机制，其中存储所有要写入的数据，然后作为事务性写入刷新。功能类似于日志文件系统(如ext3或ext4)的日志。通常存储在盘片磁盘上。包含一个ZIL头，它指向一个记录列表、ZIL块和一个ZIL trailer。对于不同的写入，ZIL的行为是不同的。对于小于64KB(默认情况下)的写操作，ZIL直接存储写入的数据。对于较大的写操作，写操作不存储在ZIL中，而ZIL维护指向存储在日志记录中的同步数据的指针。</li>
<li>Separate Intent Log, or SLOG，一个单独的日志记录设备，在将ZIL的同步部分刷新到较慢的磁盘之前缓存它们。这设备是一个电池支持的DRAM驱动器或者是快速SSD。SLOG只缓存同步数据，不缓存异步数据。异步数据将直接刷新到旋转磁盘。而且，块是一次写入块，而不是作为同步事务写入SLOG。如果已经存在SLOG，则ZIL将被移动到它上面，而不是驻留在硬盘上。SLOG中的所有内容都将始终保存在系统内存中。</li>
</ul>
<p>当你在网上读到有人提到“添加一个SSD的ZIL到池中”，他们是指添加一个SSD的SLOG，ZIL将驻留在SSD盘上。在本例中，ZIL是SLOG的一个子集。<strong>SLOG是设备，ZIL是设备上的数据</strong>。此外，并不是所有的应用程序都使用了ZIL。数据库(MySQL、PostgreSQL、Oracle)、NFS和iSCSI targets等应用都使用了ZIL。典型的文件系统数据复制不会使用ZIL。最后，通常不会读取ZIL，除非在引导时查看是否有丢失的事务。ZIL基本上是“只写”的，并且是非常密集的写。</p>
<h2 id="SLOG设备"><a href="#SLOG设备" class="headerlink" title="SLOG设备"></a>SLOG设备</h2><p>哪种设备最适合SLOG?按照最快到最慢的顺序如下：</p>
<ol>
<li>NVRAM，  由电池支持的DRAM驱动器，如STEC的ZeusRAM SSD。最快也是最可靠的，也是最昂贵的。</li>
<li>SSD，带有损耗均衡算法的NAND闪存芯片。比如PCI-Express OCZ固态硬盘或英特尔。最好是SLC，尽管SLC和MLC ssd之间的差距正在缩小。</li>
<li>10k+的SAS盘， 企业级，旋转盘片。SAS和光纤通道驱动器推动IOPS超过吞吐量，通常是消费级SATA的两倍。在列出来的这三种中是最慢也是最不可靠的。也最便宜。</li>
</ol>
<p>重要的是要确定上面列出的所有三个设备在断电期间都能保持数据持久性。SLOG和ZIL在将数据传输到旋转盘过程中是非常关键的。如果发生停电，并且您有一个volatile SLOG，最糟糕的情况是新数据没有刷新，只剩下旧数据。然而，重要的是要注意，在断电的情况下，您不会有损坏的数据，只有丢失的数据，您的数据在磁盘上仍然是一致的。</p>
<h2 id="SLOG性能"><a href="#SLOG性能" class="headerlink" title="SLOG性能"></a>SLOG性能</h2><p>因为SLOG是快速磁盘，所以我期望看到的应用程序或系统的性能是怎样的呢?您将看到改进的磁盘延迟、磁盘利用率和系统负载。您不会看到吞吐量的提高。请记住，SLOG设备仍然每5秒将数据刷新到磁盘。因此，在添加了SLOG设备之后对磁盘进行基准测试没有多大意义，除非基准测试的目标是测试同步磁盘写延迟。所以，我没有足够的数据供你参考。不过，我有一些图表。</p>
<p>我有一个磁盘写密集的虚拟机。它是ZFS数据集上的GlusterFS复制文件系统上的磁盘映像。我在管理程序中有足够的RAM，一个快速的CPU，但很慢的SATA磁盘。由于这个虚拟机上的应用程序想要频繁地将许多图写入磁盘，随着图的数量的增加，我看到了大约5-10秒的磁盘延迟。磁盘上的吞吐量非常高。因此，在VM中进行任何写操作都很痛苦。系统升级，修改配置文件，甚至登录，一切都非常非常缓慢。<br>因此，我对ssd进行了分区，并添加了SLOG。立即，我的磁盘延迟下降到大约200毫秒。磁盘利用率从繁忙的50%左右下降到5%左右。系统负载从1-2下降到几乎不存在。与磁盘相关的一切都处于更加健康的状态，VM也更加高兴。为了证明这一点，请看下面从<a href="http://zen.ae7.st/munin/保存下来的图表。">http://zen.ae7.st/munin/保存下来的图表。</a></p>
<p>第一张图片从系统管理程序的角度显示了我的磁盘。请注意，每个设备的吞吐量大约是800KBps。添加SSD SLOG后，吞吐量降至400KBps。这意味着池中的底层磁盘执行的工作更少，因此持续时间更长。<br><img src="https://z3.ax1x.com/2021/10/09/5kWF8e.md.png" alt=""></p>
<p>下一张图片从虚拟机的角度显示了我的磁盘。注意磁盘延迟和利用率是如上所述下降的，包括系统负载。</p>
<p><img src="https://z3.ax1x.com/2021/10/09/5kWuUf.md.png" alt=""></p>
<p>几天前，我在<a href="http://pthree.org/2012/12/03/how-a-zil-improves-disk-latencies/上写了一篇关于这个的博客。">http://pthree.org/2012/12/03/how-a-zil-improves-disk-latencies/上写了一篇关于这个的博客。</a></p>
<h2 id="添加一个SLOG"><a href="#添加一个SLOG" class="headerlink" title="添加一个SLOG"></a>添加一个SLOG</h2><p><strong>警告</strong>:一些主板在重新启动时不会以一致的方式向Linux内核提供磁盘。因此，在一次引导时标识为/dev/sda的磁盘可能在下一次引导时标识为/dev/sdb。对于存储数据的主池，这不是问题，因为ZFS可以基于元数据几何结构重建VDEVs。然而，对于您的L2ARC和SLOG设备，不存在这样的元数据。那么，与其通过它们的/dev/sd?名字，将它们添加到池中，还不如用/dev/disk/by-id/*名称将其加入池中，因为这些是符号指针，指向不断变化的/dev/sd?文件。如果您没有注意到这个警告，那么您的SLOG设备可能根本就不会被添加到您的混合池中，您需要稍后重新添加它。这可能会极大地影响应用程序的性能，这取决于是否存在一个快速的SLOG。</p>
<p> 将SLOG添加到现有的zpool中并不困难。然而，对SLOG做镜像被认为是SLOG的最佳实践。因此，在本例中，我将遵循最佳实践。假设我的池中有4个普通硬盘，一个OCZ Revodrive SSD向系统提供两个60GB驱动器。我将在SSD上对驱动器进行分区，分区大小为5 GB，然后将分区镜像为我的SLOG。这就是如何将SLOG添加到池中。在这里，我使用GNU parted首先创建分区，然后添加ssd。“/dev/disk/by-id/”中的设备分别指向“/dev/sda”和“/dev/sdb”。仅供参考。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># parted /dev/sda mklabel gpt mkpart primary zfs 0 5G</span><br><span class="line"># parted /dev/sdb mklabel gpt mkpart primary zfs 0 5G</span><br><span class="line"># zpool add tank log mirror \</span><br><span class="line">/dev/disk/by-id/ata-OCZ-REVODRIVE_OCZ-69ZO5475MT43KNTU-part1 \</span><br><span class="line">/dev/disk/by-id/ata-OCZ-REVODRIVE_OCZ-9724MG8BII8G3255-part1</span><br><span class="line"># zpool status</span><br><span class="line">  pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: scrub repaired 0 in 1h8m with 0 errors on Sun Dec  2 01:08:26 2012</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME                                              STATE     READ WRITE CKSUM</span><br><span class="line">        pool                                              ONLINE       0     0     0</span><br><span class="line">          raidz1-0                                        ONLINE       0     0     0</span><br><span class="line">            sdd                                           ONLINE       0     0     0</span><br><span class="line">            sde                                           ONLINE       0     0     0</span><br><span class="line">            sdf                                           ONLINE       0     0     0</span><br><span class="line">            sdg                                           ONLINE       0     0     0</span><br><span class="line">        logs</span><br><span class="line">          mirror-1                                        ONLINE       0     0     0</span><br><span class="line">            ata-OCZ-REVODRIVE_OCZ-69ZO5475MT43KNTU-part1  ONLINE       0     0     0</span><br><span class="line">            ata-OCZ-REVODRIVE_OCZ-9724MG8BII8G3255-part1  ONLINE       0     0     0</span><br></pre></td></tr></table></figure></p>
<h2 id="SLOG预期生命周期"><a href="#SLOG预期生命周期" class="headerlink" title="SLOG预期生命周期"></a>SLOG预期生命周期</h2><p>因为您可能会在GNU/Linux服务器中为您的SLOG使用消费级SSD，所以我们需要提到SSD在写密集型场景中的损耗。当然，这将在很大程度上取决于制造商，但我们可以设置一些概括性。</p>
<p>首先，ZFS拥有先进的磨损均衡算法，可以均匀地磨损SSD上的每个芯片，这不需要TRIM支持。由于文件系统的写时复制特性，ZFS的损耗是固有的。</p>
<p>其次，不同的硬盘采用不同的纳米工艺。纳米过程越小，SSD的寿命就越短。例如，Intel 320是一个25纳米的MLC 300GB SSD，额定P/E周期约为5000。这意味着如果使用磨损均衡算法，您可以写入整个SSD 5000次。这将产生总计1500000 GB的写入数据，即1500TB。我的ZIL每秒维护大约3 MB的数据。因此，我每年可以维护大约95 TB的写入数据。这给了我这个英特尔固态硬盘大约15年的寿命。</p>
<p>然而，英特尔335是一个20纳米MLC 240GB SSD，额定约3000 P/E周期。在损耗均衡的情况下，这意味着您可以写入整个SSD 3000次，这将产生总写入数据的720TB。对于3MBps 的ZIL来说，这仅仅是能用7年，这还不到Intel 320预期寿命的1/2。重点是，在规划存储池zpool的时候，你需要注意这些事情。</p>
<p>现在，如果您使用的是电池支持的DRAM驱动器，那么磨损水平不是问题，内存可能跟您的服务器的耐用时间差不多的。同样的说法也适用于10k以上的SAS或FC硬盘。</p>
<h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>只是一个简短的说明，您可能不需要一个大的ZIL。我将我的ZIL分区为仅4GB的可用空间，它几乎只占用了一到两MB的空间。我将所有虚拟机都放在同一个管理程序上，运行操作系统升级，同时它们也在做大量的工作，但也仅仅看到ZIL达到大约100 MB的缓存数据。我无法想象您需要什么样的工作负载才能使您的ZIL超过1 GB已用空间，更不用说4 GB了。这里有一个命令，你可以运行来检查你的ZIL的大小:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool iostat -v tank</span><br><span class="line">                                                     capacity     operations    bandwidth</span><br><span class="line">tank                                              alloc   free   read  write   read  write</span><br><span class="line">------------------------------------------------  -----  -----  -----  -----  -----  -----</span><br><span class="line">tank                                               839G  2.81T     76      0  1.86M      0</span><br><span class="line">  raidz1                                           839G  2.81T     73      0  1.81M      0</span><br><span class="line">    sdd                                               -      -     52      0   623K      0</span><br><span class="line">    sde                                               -      -     47      0   620K      0</span><br><span class="line">    sdf                                               -      -     50      0   623K      0</span><br><span class="line">    sdg                                               -      -     47      0   620K      0</span><br><span class="line">logs                                                  -      -      -      -      -      -</span><br><span class="line">  mirror                                          1.46M  3.72G     20      0   285K      0</span><br><span class="line">    ata-OCZ-REVODRIVE_OCZ-69ZO5475MT43KNTU-part1      -      -     20      0   285K      0</span><br><span class="line">    ata-OCZ-REVODRIVE_OCZ-9724MG8BII8G3255-part1      -      -     20      0   285K      0</span><br><span class="line">------------------------------------------------  -----  -----  -----  -----  -----  -----</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快速SLOG可以为需要较低同步事务延迟的应用程序提供惊人的好处。这对于数据库服务器或其他时间敏感的应用程序很有效。然而，将SLOG添加到您的池中会增加成本。电池驱动的DRAM芯片非常非常昂贵。通常是每8GB DDR3内存2500美元，而40GB MLC SSD只需要100美元，600GB 15k SAS需要200美元。不过，容量确实不是问题，性能才是。我希望SSD上的IOPS更快，容量更小。除非你想分区它，并在同一个驱动器上共享L2ARC，这是个好主意，我将在下一篇文章中讨论。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li>ZIL是ZFS的写入日志，即使没有添加独立高速ZIL，它也存在于储存池内。</li>
<li>ARC和L2ARC才是缓存，读和写的缓存。</li>
<li><strong>不添加ZIL也可以设置后实现极高的写入性能</strong>。</li>
<li>非要配ZIL，至少16G傲腾起步，SATA固态都是废物。</li>
</ol>
<p>ZIL起到的作用是，对于<strong>同步写</strong>而言，写入ZIL就视为落盘写，返回写成功。然后ZFS再视情况把ZIL的写入同步到数据盘上去。因此高速ZIL可以有效加速写入。此外ZIL还必须要高可靠，起到在意外断电等情况下保护还未写入数据的作用。</p>
<p>但是家用NAS的使用场景（如SMB共享等）绝大部分是<strong>异步写</strong>，这时候写入会直接进内存ARC排队，而无需关心是否落盘。问题是一旦停电，那么还在内存里排队的写入就全都凉了，因此不够安全。</p>
<p>至于性能上，在不同步时有没有ZIL几乎无影响；强制同步时即使有傲腾900P做独立ZIL，随机写入速度也惨不忍睹。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/06/zfs-administration-part-iii-the-zfs-intent-log/">https://pthree.org/2012/12/06/zfs-administration-part-iii-the-zfs-intent-log/</a><br><a href="https://zhuanlan.zhihu.com/p/63991068">ZIL不是ZFS的写缓存</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
        <tag>ZIL</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（四）The Adjustable Replacement Cache</title>
    <url>/2021/10/10/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89ARC/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/11/5eCE1f.png" alt=""></p>
<span id="more"></span>
<p>本文继续ZFS管理系列文章，这里将介绍另一个zpool VDEV，叫做可调整可替换缓存(简称ARC，当然也有翻译为自适应缓存的)。</p>
<h2 id="传统缓存"><a href="#传统缓存" class="headerlink" title="传统缓存"></a>传统缓存</h2><p> Linux和其他操作系统上的缓存机制使用的是最近最少使用的缓存算法。LRU算法的工作方式是，当应用程序读取数据块时，它们被放到缓存中。当越来越多的数据被读取并放入缓存时，缓存将被填满。然而，缓存是先进先出(FIFO)算法。因此，当缓存已满时，较旧的页面将被推出缓存。即使那些旧页面被更频繁地访问。把整个过程想象成一条传送带。块被放在缓存中最近使用的部分。当读取更多的块时，将旧块推到缓存中最近使用最少的部分，直到它们从传送带上脱落，或者换句话说被逐出。<br><img src="https://z3.ax1x.com/2021/10/11/5eClhq.png" alt=""></p>
<p>当从磁盘读取较大的顺序读并将其放入缓存时，它倾向于从缓存中逐出更频繁请求的页面。即使这些新读取的数据只需要一次。因此，从缓存的角度来看，它最终会产生大量无用的、不再需要的数据。当然，当请求更新的数据块时，它最终会被替换。</p>
<p>当然除了LRU，还有最少使用频率(LFU)缓存。但是，LFU会遇到一个问题，即如果较新的数据读取的频次不够多，很可能会从缓存中淘汰。因此，如果还要读取这些新数据将会有大量的磁盘请求，这就违背了使用缓存的初衷。因此，似乎最明显的方法就是以某种方式将两者结合起来——同时拥有一个LRU和一个LFU。</p>
<h2 id="ZFS-ARC"><a href="#ZFS-ARC" class="headerlink" title="ZFS ARC"></a>ZFS ARC</h2><p>ZFS可调替换缓存(ARC)就是这样一种缓存机制，它既缓存最近的块请求，也缓存频繁的块请求。它是IBM专利“adaptive replacement cache”的实现，经过一些修改和扩展。</p>
<p>在开始之前，我应该提一下，我从<a href="http://www.c0t0d0s0.org/archives/5329-Some-insight-into-the-read-cache-of-ZFS-or-The-ARC.html">http://www.c0t0d0s0.org/archives/5329-Some-insight-into-the-read-cache-of-ZFS-or-The-ARC.html</a><br>学到了很多关于ZFS ARC的知识。下面是我在这里重复使用的那篇文章的图片。谢谢Joerg的精彩帖子。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>Adjustable Replacement Cache(ARC) -驻留在物理RAM中的缓存。它是使用两个缓存构建的——最常用的缓存和最近使用的缓存。缓存目录索引指向缓存的指针，包括指向称为ghost常用缓存和ghost最近使用缓存的磁盘的指针。</li>
<li>缓存目录-组成MRU, MFU，ghost MRU和ghost MFU缓存的指针的一个索引目录。 </li>
<li>MRU缓存- ARC最近使用的缓存。文件系统中最近请求的块被缓存在这里。</li>
<li>MFU缓存- ARC中最频繁使用的缓存。文件系统中最频繁请求的块都缓存在这里。</li>
<li>Ghost MRU-将MRU缓存中的页面移回磁盘，以节省MRU的空间。指针仍然跟踪被逐出的页面在磁盘上的位置。</li>
<li>Ghost MFU-将页面从MFU缓存中驱逐回磁盘，以节省MFU中的空间。指针仍然跟踪被逐出的页面在磁盘上的位置。</li>
<li>2级Adjustable Replacement Cache(L2ARC)——位于物理内存之外的缓存，通常位于快速SSD上。它是RAM ARC字面上的、物理上的扩展。</li>
</ul>
<h2 id="ARC算法"><a href="#ARC算法" class="headerlink" title="ARC算法"></a>ARC算法</h2><p>这是IBM ARC工作方式的简化版本，但是它可以帮助您理解MRU和MFU的优先级是如何分配的。首先，让我们假设缓存中有8个页面。缓存中的四页将用于MRU，另外四页用于MFU。此外，还将有四个指针的ghost MRU和四个指针的ghost MFU。因此，缓存目录将引用16页的活动缓存或被淘汰的缓存。</p>
<p><img src="https://z3.ax1x.com/2021/10/11/5eCNB4.md.png" alt=""></p>
<ol>
<li>正如预期的那样，当从文件系统中读取块A时，它将被缓存到MRU中。缓存目录中的一个索引指针将引用该MRU页面。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/10/11/5eCD9x.png" alt=""></p>
<ol start="2">
<li>现在假设从文件系统中读取了一个不同的块(块B)。它也将被缓存到MRU中，并且缓存目录中的索引指针将引用第二个MRU页面。因为块B比块A读得更晚，所以它在MRU缓存中比块A有更高的优先级。现在MRU缓存中有两个页面。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/10/11/5eCsgK.png" alt=""></p>
<ol start="3">
<li>现在假设块A再次从文件系统中读取。这将是对块A的第二次读取。结果，它被频繁地读取，所以它将被存储在MFU中。一个块必须被至少读两次才能存储在这里。此外，这也是最近的请求。因此，块不仅缓存在MFU中，它还在缓存目录的MRU中被引用。因此，尽管缓存中有两个页面，但缓存目录中有三个指针指向缓存中的两个块。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/10/11/5eCfUA.png" alt=""></p>
<ol start="4">
<li>最终，缓存被上述类似的步骤填满，我们在MRU和缓存目录的MFU中都有指针。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/10/11/5ePe8x.png" alt=""></p>
<ol start="5">
<li>这就是有趣的地方。假设我们现在需要从没有缓存的文件系统中读取一个新的块。由于鸽笼原理，我们要缓存的页面比存储的页面要多。因此，我们需要从缓存中取出一个页面。MRU中最老的页面(被称为最近最少使用的- LRU)会得到驱逐通知，并被ghost MRU引用。MRU中将有一个新的页面用于新读块。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/10/11/5ePnxK.png" alt=""></p>
<ol start="6">
<li>当新的读块被从文件系统中读取后，如预期的那样，它被存储在MRU中并被引用。这样，我们就有了一个ghost MRU页面引用和一个已填满的缓存。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/10/11/5ePMrD.png" alt=""></p>
<ol start="7">
<li>为了搅乱整个过程，让我们假设从文件系统中重新读取了最近被逐出的页面。因为ghost MRU知道它最近被从缓存中移除，我们称之为“幽灵缓存命中”。因为ZFS知道它最近被缓存了，所以我们需要将它带回MRU缓存中;而不是MFU缓存，因为它没有被MFU ghost引用。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/10/11/5ePtRP.png" alt=""></p>
<ol start="8">
<li>不幸的是，我们的缓存太小，无法存储该页面。所以，我们必须把MRU增加一页来存储这个新的“幽灵命中的页面”。但是，我们的缓存只有这么大，所以我们必须将MFU的大小减少1，以便为MRU腾出空间。当然，该算法以类似的方式工作在MFU和ghost MFU。ghost MFU的“幽灵命中”会增大MFU，当然同时需要缩小MRU来为新页面腾出空间。<br><img src="https://z3.ax1x.com/2021/10/15/5850oR.png" alt=""></li>
</ol>
<p>所以，想象一下两种截然相反的工作f负载。第一种工作负载从磁盘读取大量随机数据，几乎没有重复。MRU可能会占缓存的大部分，而MFU只占很小的一部分。缓存已经根据系统所承受的负载调整了自己。但是，考虑第二种工作负载，它不断地反复读取相同的数据，只有很少的新读取数据。在这种情况下，MFU可能会占据大部分缓存，而MRU不会。因此，缓存被调整来适应系统所承受的负载。</p>
<p> 还记得我们前面提到的传统缓存方案吗?Linux内核使用LRU方案将缓存的页面交换到磁盘。因此，它总是倾向于最近的缓存命中，而不是频繁的缓存命中。如果您只需要一次读取大量块，那么这可能会产生严重的后果。您将把频繁缓存的页面交换到磁盘，即使新读取的数据只需要一次。因此，您可能会以THE SWAP OF DEATH结束，因为频繁请求的页面必须从交换区域返回磁盘。使用ARC，我们修改缓存以适应这种负载(因此，它被称为“Adaptive Read cache”)。</p>
<h2 id="ZFS-ARC扩展"><a href="#ZFS-ARC扩展" class="headerlink" title="ZFS ARC扩展"></a>ZFS ARC扩展</h2><p>前面的算法是IBM设计的ARC算法的简化版本。ZFS做了如下扩展:</p>
<ul>
<li>ZFS ARC将占用1/2的可用RAM。然而，这并不是静态的。如果您的服务器中有32GB的RAM，这并不意味着缓存总是16GB。相反，总缓存将根据内核的决定调整其大小。如果内核需要为调度的进程提供更多的RAM，则会调整ZFS ARC，以便为内核需要的任何内容腾出空间。但是，如果有ZFS ARC可以占用的空间，它就会占用它。</li>
<li>ZFS ARC可以使用多种块大小，而IBM实现使用静态块大小。</li>
<li>页面可以锁定在MRU或MFU，以防止驱逐。IBM实现没有这个特性。因此，在选择页面何时从缓存中被移除时，ZFS ARC算法会稍微复杂一些。</li>
</ul>
<h2 id="L2ARC"><a href="#L2ARC" class="headerlink" title="L2ARC"></a>L2ARC</h2><p> 2级ARC或L2ARC应该使用快速磁盘（比如SSD）。正如我在之前关于ZIL的文章中提到的，ZIL应该使用DRAM内存(不一定需要电池支持)，快速SSD，或10k以上的企业SAS或FC硬盘。如果您决定为您的ZIL和L2ARC使用相同的设备(这当然是可以接受的)，那么您应该对它进行分区，使ZIL占用很少的空间，比如512 MB或1 GB，并将其余的作为条带(RAID-0) L2ARC给池。在L2ARC中不需要持久化，因为缓存将在引导时被擦除。<br><img src="https://z3.ax1x.com/2021/10/11/5ePcR0.png" alt=""></p>
<p> L2ARC是ARC在RAM中的扩展，当有L2ARC存在时，之前的算法保持不变。这意味着随着MRU或MFU的增长，它们不会同时共享RAM中的ARC和SSD中的L2ARC。这将对性能产生巨大的影响。相反，当一个页面即将被逐出时，一个遍历算法将MRU和MFU页面逐出到一个8 MB的缓冲区中，这个缓冲区稍后被设置为一个到L2ARC的原子写事务。这里的明显优势是，从缓存中删除页面的延迟不会受到影响。此外，如果大量的数据块被读到缓存中，这些块在L2ARC遍历之前被驱逐，而不是被发送到L2ARC。这将最大限度地减少大量顺序读取对L2ARC的污染。根据对数据的访问情况，填充L2ARC可能会非常慢，也可能非常快。</p>
<h2 id="添加一个L2ARC"><a href="#添加一个L2ARC" class="headerlink" title="添加一个L2ARC"></a>添加一个L2ARC</h2><p><strong>警告</strong>:一些主板在重新启动时不会以一致的方式向Linux内核提供磁盘。因此，在一次引导时标识为/dev/sda的磁盘可能在下一次引导时标识为/dev/sdb。对于存储数据的主池，这不是问题，因为ZFS可以基于元数据几何结构重建VDEVs。然而，对于您的L2ARC和SLOG设备，不存在这样的元数据。那么，与其通过它们的/dev/sd?名字，将它们添加到池中，还不如用/dev/disk/by-id/*名称将其加入池中，因为这些是符号指针，指向不断变化的/dev/sd?文件。如果您没有注意到这个警告，那么您的L2ARC设备可能根本就不会被添加到您的混合池中，您需要稍后重新添加它。这可能会极大地影响应用程序的性能，这取决于是否存在一个快速的L2ARC。</p>
<p>您可以使用“缓存”VDEV添加L2ARC。建议对L2ARC进行分条处理，使大小和速度都最大化。对于L2ARC来说，持久化数据是不必要的，所以它可以是不稳定的内存。假设我的池中有4个盘片磁盘，一个OCZ Revodrive SSD向系统提供两个60GB驱动器。我将在SSD上对驱动器进行分区，将4 GB给ZIL，其余留给L2ARC。这是如何将L2ARC添加到池中。在这里，我使用GNU parted首先创建分区，然后添加ssd。“/dev/disk/by-id/”中的设备分别指向“/dev/sda”和“/dev/sdb”。仅供参考。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># parted /dev/sda unit s mklabel gpt mkpart primary zfs 2048 4G mkpart primary zfs 4G 109418255</span><br><span class="line"># parted /dev/sdb unit s mklabel gpt mkpart primary zfs 2048 4G mkpart primary zfs 4G 109418255</span><br><span class="line"># zpool add tank cache \</span><br><span class="line">/dev/disk/by-id/ata-OCZ-REVODRIVE_OCZ-33W9WE11E9X73Y41-part2 \</span><br><span class="line">/dev/disk/by-id/ata-OCZ-REVODRIVE_OCZ-X5RG0EIY7MN7676K-part2 \</span><br><span class="line">log mirror \</span><br><span class="line">/dev/disk/by-id/ata-OCZ-REVODRIVE_OCZ-69ZO5475MT43KNTU-part1 \</span><br><span class="line">/dev/disk/by-id/ata-OCZ-REVODRIVE_OCZ-9724MG8BII8G3255-part1</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: scrub repaired 0 in 1h8m with 0 errors on Sun Dec  2 01:08:26 2012</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME                                              STATE     READ WRITE CKSUM</span><br><span class="line">        tank                                              ONLINE       0     0     0</span><br><span class="line">          raidz1-0                                        ONLINE       0     0     0</span><br><span class="line">            sdd                                           ONLINE       0     0     0</span><br><span class="line">            sde                                           ONLINE       0     0     0</span><br><span class="line">            sdf                                           ONLINE       0     0     0</span><br><span class="line">            sdg                                           ONLINE       0     0     0</span><br><span class="line">        logs</span><br><span class="line">          mirror-1                                        ONLINE       0     0     0</span><br><span class="line">            ata-OCZ-REVODRIVE_OCZ-69ZO5475MT43KNTU-part1  ONLINE       0     0     0</span><br><span class="line">            ata-OCZ-REVODRIVE_OCZ-9724MG8BII8G3255-part1  ONLINE       0     0     0</span><br><span class="line">        cache</span><br><span class="line">          ata-OCZ-REVODRIVE_OCZ-69ZO5475MT43KNTU-part2    ONLINE       0     0     0</span><br><span class="line">          ata-OCZ-REVODRIVE_OCZ-9724MG8BII8G3255-part2    ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br> 此外，我可以用如下命令在任何时候检查L2ARC的大小:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#zpool iostat -v</span><br><span class="line">                                                     capacity     operations    bandwidth</span><br><span class="line">pool                                              alloc   free   read  write   read  write</span><br><span class="line">------------------------------------------------  -----  -----  -----  -----  -----  -----</span><br><span class="line">pool                                               824G  2.82T     11     60   862K  1.05M</span><br><span class="line">  raidz1                                           824G  2.82T     11     52   862K   972K</span><br><span class="line">    sdd                                               -      -      5     29   289K   329K</span><br><span class="line">    sde                                               -      -      5     28   289K   327K</span><br><span class="line">    sdf                                               -      -      5     29   289K   329K</span><br><span class="line">    sdg                                               -      -      7     35   289K   326K</span><br><span class="line">logs                                                  -      -      -      -      -      -</span><br><span class="line">  mirror                                          1.38M  3.72G      0     19      0   277K</span><br><span class="line">    ata-OCZ-REVODRIVE_OCZ-69ZO5475MT43KNTU-part1      -      -      0     19      0   277K</span><br><span class="line">    ata-OCZ-REVODRIVE_OCZ-9724MG8BII8G3255-part1      -      -      0     19      0   277K</span><br><span class="line">cache                                                 -      -      -      -      -      -</span><br><span class="line">  ata-OCZ-REVODRIVE_OCZ-69ZO5475MT43KNTU-part2    2.34G  49.8G      0      0    739  4.32K</span><br><span class="line">  ata-OCZ-REVODRIVE_OCZ-9724MG8BII8G3255-part2    2.23G  49.9G      0      0    801  4.11K</span><br><span class="line">------------------------------------------------  -----  -----  -----  -----  -----  -----</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，我在L2ARC中使用了大约5GB的缓存数据(记住，它是条带的)，有足够的空间。事实上，上面的执行结果来自一个正在运行的32GB DDR2 RAM的系统。L2ARC在一周前修改并重新添加。这显示了我在我的系统上填充L2ARC的速度。你的情况可能有所不同，但花这么长时间也就不足为奇了。Ben Rockwood有一个Perl脚本，可以分解ARC和L2ARC的MRU, MFU，和ghost，以及其他。请访问<a href="http://www.cuddletech.com/blog/pivot/entry.php?id=979">http://www.cuddletech.com/blog/pivot/entry.php?id=979 </a> (我对这个脚本没有任何经验)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ZFS可调可替换缓存改进了IBM的原始Adaptive Read Cache，同时保持了IBM设计的原形。然而，与传统的LRU和LFU缓存相比，ZFS ARC有巨大的优势。而且，通过在快速SSD或磁盘上添加L2ARC，我们可以快速检索大量数据，同时仍然允许主机内核根据需要调整内存需求。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/07/zfs-administration-part-iv-the-adjustable-replacement-cache/">https://pthree.org/2012/12/07/zfs-administration-part-iv-the-adjustable-replacement-cache/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（五）数据清理和数据重建</title>
    <url>/2021/10/11/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/11/5eEI8s.png" alt=""></p>
<span id="more"></span>
<h2 id="标准校验"><a href="#标准校验" class="headerlink" title="标准校验"></a>标准校验</h2><p>在GNU/Linux中，有许多的文件系统检测工具来检测磁盘上数据的完整性。通常是通过“fsck”工具完成的。然而，该工具有几个主要缺点。<br>首先，如果您打算修复数据错误，则必须脱机fsck磁盘，这意味着停机时间。因为在执行fsck之前，必须使用“umount”命令卸载磁盘。对于根分区，这进一步意味着要从其他介质(如CDROM或u盘)启动。停机时间的长短跟磁盘容量大小有关，大容量的磁盘在修复时，其停机时间可能长达几小时。<br>其次，诸如ext3或ext4的文件系统，对底层数据结构(如LVM或RAID)一无所知。您可能在一个磁盘上只有一个坏块，但在另一个磁盘上有一个好的块。不幸的是,Linux软件RAID从ext3的角度或ext4,不知道哪一块数据是好的，哪一块数据是坏的，它可能得到好的数据如果从磁盘读取到包含好的数据的块；也可能得到损坏的数据如果从磁盘读到那个坏块。这个过程没有从哪块磁盘读取数据的控制，也没有修复损坏的数据。这些错误被称为“静默数据错误”，使用标准的GNU/Linux文件系统对此类错误实际上无能为力。</p>
<h2 id="ZFS-Scrubbing（ZFS数据清理）"><a href="#ZFS-Scrubbing（ZFS数据清理）" class="headerlink" title="ZFS Scrubbing（ZFS数据清理）"></a>ZFS Scrubbing（ZFS数据清理）</h2><p>在Linux上使用ZFS，可以通过磁盘数据清理来检测和纠正静默数据错误。这在技术上类似于ECC RAM，如果错误驻留在ECC DIMM中，您可以找到另一个包含好的数据的寄存器，并使用它来修复坏寄存器。这是一种已经使用了一段时间的老技术，所以令人惊讶的是，在日志文件系统的标准套件中没有这种技术。此外，就像您可以在不停机的情况下在实时运行的系统上清除ECC RAM一样，有了ZFS，您也可以能够在不停机的情况下进行磁盘数据清理。</p>
<p><strong>译者注：也就是说ZFS Scrubbing是ZFS的一种数据清理手段，主要用途是用来修复由于磁盘静默故障导致的数据损坏</strong></p>
<p>当ZFS对您的存储池进行数据清理（scrub）时，它将根据其已知的校验值和逐一检查存储池中的每个块。默认情况下，从上到下的每个块都使用适当的算法进行校验。当前是使用的“fletcher4”算法，它是256位的算法，速度很快。当然你也可以更改为使用SHA-256算法，但不推荐这样做，因为计算SHA-256校验和的开销比fletcher4更大。然而，由于SHA-256，您有1 / 2^256或1 / 10^77的概率损坏块哈希到相同的SHA-256校验值。这个概率是0.00000000000000000000000000000000000000000000000000000000000000000000000000001%。作为参考，使用市场上最可靠的硬件，未经校正的ECC内存错误将更频繁地发生的概率是这个概率的约50个数量级。所以当你清理数据时，这个概率是要么校验和匹配，你大概率有一个好的数据块，要么不匹配，你有一个损坏的数据块。</p>
<p>ZFS存储池中数据清理不是自动发生的事情。你需要手动去做，并且强烈建议你定期去做。推荐的数据清理的频率取决于底层磁盘的质量。如果您使用的是SAS或FC硬盘，那么每月一次就足够了。如果你使用的是消费级的SATA或SCSI，你应该每周做一次。你可以使用以下命令轻松地安排一次数据清理:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool scrub tank</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line"> scan: scrub in progress since Sat Dec  8 08:06:36 2012</span><br><span class="line">    32.0M scanned out of 48.5M at 16.0M/s, 0h0m to go</span><br><span class="line">    0 repaired, 65.99% done</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME        STATE     READ WRITE CKSUM</span><br><span class="line">        tank        ONLINE       0     0     0</span><br><span class="line">          mirror-0  ONLINE       0     0     0</span><br><span class="line">            sde     ONLINE       0     0     0</span><br><span class="line">            sdf     ONLINE       0     0     0</span><br><span class="line">          mirror-1  ONLINE       0     0     0</span><br><span class="line">            sdg     ONLINE       0     0     0</span><br><span class="line">            sdh     ONLINE       0     0     0</span><br><span class="line">          mirror-2  ONLINE       0     0     0</span><br><span class="line">            sdi     ONLINE       0     0     0</span><br><span class="line">            sdj     ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br> 如您所见，您可以在执行数据清理的过程中获取它的状态。执行擦除操作会严重影响磁盘性能。因此，如果出于任何原因需要停止scrub，可以将”-s”参数传递给scrub子命令。但是，一般情况应该让数据清理继续完成。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool scrub -s tank</span><br></pre></td></tr></table></figure><br> 你也可以在你的root用户的crontab中放入类似以下内容，这样将在每周日凌晨02:00执行一次数据清理:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2 * * 0 /sbin/zpool scrub tank</span><br></pre></td></tr></table></figure></p>
<h2 id="数据的自愈"><a href="#数据的自愈" class="headerlink" title="数据的自愈"></a>数据的自愈</h2><p>如果您的存储池正在使用某种冗余，那么ZFS不仅会在一次数据清理中检测到静默数据错误，如果另一个磁盘上存在好的数据时，还会去纠正这些错误。这就是所谓的“自愈”，如下图所示。在前面的介绍RAIDZ的文章中，讨论了如何使用RAIDZ修复数据。我要简化一下，用一个两路镜像。假设一个应用程序需要一些数据块，而在这些数据块中，有一些数据块损坏了。ZFS如何知道数据已损坏? 正如前面所述，通过检查块的SHA-256校验值。如果一个块的校验值不匹配，它将查看镜像中的其他磁盘，看看是否能找到一个好的块。如果能找到，则将好的块传递给应用程序，然后ZFS将修复镜像中的坏块，以便它可以通过SHA-256校验。这样应用程序将始终获得好的数据，而您的存储池将始终处于良好、干净、一致的状态。<br><img src="https://z3.ax1x.com/2021/10/11/5eEj54.png" alt=""></p>
<h2 id="Resilvering-Data（重建数据）"><a href="#Resilvering-Data（重建数据）" class="headerlink" title="Resilvering Data（重建数据）"></a>Resilvering Data（重建数据）</h2><p>Resilvering data跟重建数据或者重新同步数据到磁盘阵列中的新盘的概念是一样的。然而在Linux 软件RAID，硬件RAID控制器以及其他RAID实现，活动的块（有数据的块）和没有数据的块是无法区分的。所以，这种重建将会从磁盘开头开始，直到磁盘的末尾才结束（也就是这种情况下重建，是整个磁盘重建，这样可能会做大量的无用功）。因为ZFS知道RAID结构和文件系统的元数据，所以ZFS在重建数据这块会比较灵活，而不会浪费时间在没有数据的磁盘上，只需要关心有数据的地方。如果您的存储池只被部分填满，那么这可以大大节省时间（因为不需要整个存储池重建）。如果池只被填满了10%，那么这意味着只在10%的磁盘上工作。因此，为了区别与传统的数据重建，对于ZFS，我们需要一个新的术语，而不是“重建”、“重新同步”或“重建”。在本例中，我们将重建数据的过程称为“resilvering”。</p>
<p> 不幸的是，磁盘会坏，并需要更换。如果您的存储池中有冗余，并且能够承受某种程度的故障，那么您仍然可以向应用程序发送数据和从应用程序接收数据，即使存储池处于“降级”模式。如果您的运行的系统中有昂贵的支持热插拔的磁盘，那么您可以在不停机的情况下更换磁盘(您很幸运)。如果不是，您仍然需要识别坏盘，并替换它。如果您的磁盘池中有许多磁盘(比如24个)，那么这可能是一件苦差事。然而，大多数GNU/Linux操作系统供应商，如Debian或Ubuntu，提供了一个名为“hdparm”的工具，它允许您发现存储池中所有磁盘的序列号。当然，磁盘控制器通常也会将这些信息呈现给Linux内核。所以，你可以执行如下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># for i in a b c d e f g; do echo -n &quot;/dev/sd$i: &quot;; hdparm -I /dev/sd$i | awk &#x27;/Serial Number/ &#123;print $3&#125;&#x27;; done</span><br><span class="line">/dev/sda: OCZ-9724MG8BII8G3255</span><br><span class="line">/dev/sdb: OCZ-69ZO5475MT43KNTU</span><br><span class="line">/dev/sdc: WD-WCAPD3307153</span><br><span class="line">/dev/sdd: JP2940HD0K9RJC</span><br><span class="line">/dev/sde: /dev/sde: No such file or directory</span><br><span class="line">/dev/sdf: JP2940HD0SB8RC</span><br><span class="line">/dev/sdg: S1D1C3WR</span><br></pre></td></tr></table></figure><br>看起来/dev/sde是坏盘。系统里有所有其他磁盘的序列号，但唯独/dev/sde没有。所以，通过排除，我可以到存储阵列，找到哪个序列号没有被打印出来。那就是坏盘。在这个例子中，我找到序列号“JP2940HD01VLMC”。我拔出磁盘，将其替换为一个新的磁盘，并查看是否重新填充了/dev/sde，并且其他的磁盘仍然在线。如果是，那么我已经找到了我的磁盘，可以将它添加到池中。实际上，在我的个人管理程序上，这种情况已经发生过两次了。更换起来很容易，不到10分钟就重新online了。</p>
<p>要用新磁盘替换存储池中的坏盘，可以使用”replace”子命令。假设新磁盘也将自己标识为/dev/sde，那么我将用以下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool replace tank sde sde</span><br><span class="line"># zpool status tank</span><br><span class="line">  pool: tank</span><br><span class="line"> state: ONLINE</span><br><span class="line">status: One or more devices is currently being resilvered.  The pool will</span><br><span class="line">        continue to function, possibly in a degraded state.</span><br><span class="line">action: Wait for the resilver to complete.</span><br><span class="line"> scrub: resilver in progress for 0h2m, 16.43% done, 0h13m to go</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">        NAME          STATE       READ WRITE CKSUM</span><br><span class="line">        tank          DEGRADED       0     0     0</span><br><span class="line">          mirror-0    DEGRADED       0     0     0</span><br><span class="line">            replacing DEGRADED       0     0     0</span><br><span class="line">            sde       ONLINE         0     0     0</span><br><span class="line">            sdf       ONLINE         0     0     0</span><br><span class="line">          mirror-1    ONLINE         0     0     0</span><br><span class="line">            sdg       ONLINE         0     0     0</span><br><span class="line">            sdh       ONLINE         0     0     0</span><br><span class="line">          mirror-2    ONLINE         0     0     0</span><br><span class="line">            sdi       ONLINE         0     0     0</span><br><span class="line">            sdj       ONLINE         0     0     0</span><br></pre></td></tr></table></figure><br>resilver类似于Linux软件RAID的重建。它正在新磁盘上重建数据块，直到镜像(在本例中)处于完全健康状态。查看resilver的状态将帮助您了解resilver何时将完成。</p>
<h2 id="识别存储池的问题"><a href="#识别存储池的问题" class="headerlink" title="识别存储池的问题"></a>识别存储池的问题</h2><p>通过传递“-x”参数，可以快速确定存储池一切是否正常运行，而不需要“zpool status”命令的完整输出。这对于脚本在没有复杂逻辑的情况下进行解析很有用，并且在出现故障时可以发出警告:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool status -x</span><br><span class="line">all pools are healthy</span><br></pre></td></tr></table></figure><br>“zpool status”命令结果中的每一字段，都为您提供关于池的重要信息，其中大部分字段的含义是不言自明的。它们的定义如下:</p>
<ul>
<li>pool – 存储池名字</li>
<li>state – 存储池当前的健康状态。 此信息仅指存储池提供必要复制级别的能力。</li>
<li>status –  对存储池问题的描述。如果没有发现问题，则省略此字段。</li>
<li>action – 修复错误的建议操作。该字段是一个缩写表单，引导用户进入以下部分之一。如果没有发现问题，则省略此字段。</li>
<li>see – 包含详细修理信息的知识文章的参考。在线文章的更新比本指南的更新更频繁，并且应该经常参考最新的修理程序。如果没有发现问题，则省略此字段。</li>
<li>scrub – 标识一个数据清理操作的当前状态，这可能包括最近一次数据清理操作完成的日期和时间、正在进行的数据清理的当前状态，或者没有如果没有请求数据清理的话。</li>
<li>errors – 标识已知数据错误或不存在已知数据错误。</li>
<li>config – 描述组成池的设备的配置布局，以及它们的状态和从设备生成的任何错误。状态包括:ONLINE、FAULTED、DEGRADED、UNAVAILABLE和OFFLINE。如果状态不是ONLINE，则池的容错能力已被破坏。</li>
</ul>
<p>zpool status命令输出结果的列，比如“READ”、“WRITE”和“CHKSUM”的定义如下:</p>
<ul>
<li>NAME – 存储池中每个VDEV的名称，按嵌套顺序显示。</li>
<li>STATE –  池中每个VDEV的状态。状态可以是上面介绍的“config”中的任何一种状态。</li>
<li>READ – 发出读请求时发生的I/O错误。</li>
<li>WRITE – 在发出写请求时发生的I/O错误。</li>
<li>CHKSUM – 校验错误。设备返回损坏的数据作为读请求的结果。</li>
</ul>
<h2 id="scrub和resilver-data的区别"><a href="#scrub和resilver-data的区别" class="headerlink" title="scrub和resilver data的区别"></a>scrub和resilver data的区别</h2><p>简单的来说，scrub可以理解为数据扫描并修复损坏数据，在扫描的过程中，会去校验数据是否有损坏，发现数据有损坏，会去修复数据，这个修复是在数据损坏的盘上修复，不用替换硬盘。<br>resilver data可以理解为重建数据，重建的过程需要一个新的盘，把数据重建（恢复）到新盘的过程，这个叫resilver data。但是跟传统的重建数据不同，这个resilver data不是全盘重建。</p>
<p>所以scrub和resilver data是两个不同的概念，而且适用场景和用途也不同。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>定期扫描数据进行数据清理将确保存储池中的数据保持一致。尽管数据扫描（数据清理）可能会给正在读写数据的应用程序带来压力，但它可以在未来避免更大的麻烦。 此外，由于您随时可能有一个“损坏的设备”(有关使用ZFS的损坏设备，请参阅<a href="http://docs.oracle.com/cd/E19082-01/817-2271/gbbvf/index.html">http://docs.oracle.com/cd/E19082-01/817-2271/gbbvf/index.html</a>)，因此正确地了解如何修复该设备，以及在更换一个设备时将会发生什么，这对存储管理至关重要。当然，关于这个主题，我还有很多可以讨论的内容，但这篇文章至少让您了解了数据清理（scrub data）和重建数据（resilver data）的概念。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/11/zfs-administration-part-vi-scrub-and-resilver/">https://pthree.org/2012/12/11/zfs-administration-part-vi-scrub-and-resilver/</a>  </p>
<p><a href="https://serverfault.com/questions/1007438/zfs-scrub-vs-resilver-are-they-equivalent">zfs: scrub vs resilver (are they equivalent?)</a></p>
<p><a href="https://blog.csdn.net/Androidlushangderen/article/details/87897475">分布式存储系统中的Data Scrubbing机理</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（六）存储池属性、最佳实践和注意事项</title>
    <url>/2021/10/12/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E5%AD%98%E5%82%A8%E6%B1%A0%E5%B1%9E%E6%80%A7%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/12/5n5dGd.png" alt=""></p>
<span id="more"></span>
<p>在前一篇文章讲完数据清理和数据重建之后，<br>本文是ZFS存储池管理系列的最后一篇文章。在此之后，我们继续讨论一些关于ZFS的理论主题，这些主题将为ZFS数据集奠定基础。本文我们将讨论：</p>
<ul>
<li>ZFS存储池的属性</li>
<li>ZFS存储池的最佳实践</li>
<li>构建存储池之前必须了解的注意事项</li>
</ul>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>对于ext4和GNU/Linux中的许多文件系统，我们有办法来调优文件系统中的各种参数。比如设置标签、默认挂载选项和其他可调参数。对于ZFS，它也没有什么不同，事实上，它要详细得多。这些属性允许我们修改所有类型的变量，包括存储池的变量和存储池中包含的数据集的变量。因此，我们可以根据自己的喜好或需要“调优”文件系统。然而，并不是每个属性都是可调的。有些属性是只读的。但是，我们将定义每个属性是什么以及它们如何影响存储池。注意，当前我们只查看zpool属性，当我们访问数据集子主题时，我们将访问ZFS数据集属性。</p>
<h2 id="Zpool-属性"><a href="#Zpool-属性" class="headerlink" title="Zpool 属性"></a>Zpool 属性</h2><ul>
<li>allocated ：所有ZFS数据集已提交到存储池中的数据量。该设置是只读的。</li>
<li>altroot: 标识一个备用的根目录。如果已设置，则该目录将可以被附加到池中的任何挂载点上。当检查未知存储池时(如果挂载点不受信任)，或者在替代引导环境中(其中典型路径无效)，可以使用此属性。设置altroot默认使用”cachefile=none”，当然可以使用显式设置覆盖该项配置。</li>
<li>ashift: <strong>只能在创建池时设置</strong>。存储池扇区大小为2的指数。I/O操作将按指定的大小边界对齐。默认值是”9”，即2^9 = 512，这是操作系统工具用于读写数据的标准扇区大小。对于具有4个KiB边界的高级格式硬盘（指扇区大小为4KB的4K盘），该值应设置为“asshift =12”，即2^12 = 4096。</li>
<li>autoexpand: <strong>在更换池中的第一个驱动器之前必须设置</strong>。控制存储池自动扩容的设置。默认设置是“关闭”。当池中的所有驱动器都被更大的磁盘替换后，存储池将自动增长到新的大小。该设置是一个布尔值，值为“on”或“off”。</li>
<li>autoreplace: 控制存储池中“spare”VDEV的自动设备替换。<strong>默认设置为“off”</strong>。因此，此时必须使用“zpool replace”命令手动启动设备替换。这个设置是一个布尔值，值为“on”或“off”。</li>
<li>bootfs: 在存储池中定义可引导ZFS数据集的只读设置。这通常由安装程序设置。</li>
<li>cachefile:  控制存储池缓存配置的位置。当在系统上导入zpool时，ZFS可以使用磁盘上的元数据检测到硬盘的分布情况。但是，在一些集群环境中，不会自动导入存储池，这时可能需要将缓存文件存储在不同的位置。可以将缓存配置设置为任何字符串，但对于大多数ZFS的安装来说，默认位置为“/etc/zfs/zpool.cache”应该足够了。</li>
<li>capacity: 只读值，标识已使用池空间的百分比。</li>
<li>comment: 由不超过32个可打印ASCII字符组成的文本字符串，即使存储池出现故障，它也可用。管理员可以使用此设置提供有关池的附加信息。</li>
<li>dedupditto: 设置块重复数据删除阈值，如果重复数据删除块的引用计数超过该阈值，则自动存储该块的重复副本。默认值为0。可以是任何正数。</li>
<li>dedupratio: 为存储池指定的重复数据删除率（即重删率，只读）</li>
<li>delegation: 控制是否可以授予非特权用户访问指定的数据集。该设置是一个布尔值，默认值为“on”，可以是“on”或“off”。</li>
<li>expandsize:  存储池或设备中可用于增加存储池总容量的未初始化空间的数量。该空间是动态扩展LUN时产生的。</li>
<li>failmode:  在发生灾难性故障时控制系统行为。这种情况通常是由于与底层存储设备的连接丢失或池内所有设备故障造成的。该事件的行为如下所示:<br>  （1）wait: 阻塞所有I/O访问，直到设备连接恢复和错误清除。这是默认行为。<br>  （2）continue: 返回任何新的写I/O请求的EIO，但允许读任何剩余的健康设备。任何尚未提交到磁盘的写请求都将被阻塞。<br>  （3）panic:  将消息打印到控制台并crash dump。 </li>
<li>free:  只读值，用于标识池中未分配的块的数量。</li>
<li>guid:  标识存储池的唯一标识符的只读属性。类似于ext4文件系统的UUID字符串。</li>
<li>health:  只读属性，标识池的当前运行状况为“在线”、“降级”、“故障”、“离线”、“已删除”或“不可用”（ONLINE, DEGRADED, FAULTED, OFFLINE, REMOVED, or UNAVAIL）。</li>
<li>listsnapshots:  控制在使用“zfs list”命令时是否显示与此存储池关联的快照信息。如果禁用该属性，则可以使用“zfs list -t snapshot”命令显示快照信息。默认值为“off”。布尔值，可以是“off”或“on”。</li>
<li>readonly:  布尔值，可以是“off”或“on”。默认值为“off”。控制将存储池设置为只读模式，以防止写或数据损坏。</li>
<li>size: 只读属性，用于标识存储池的总大小。</li>
<li>version: 可写设置，用于标识存储池的当前版本。可以是从1到“zpool upgrade -v”命令输出的任意值。当需要向后兼容特定版本时，可以使用此属性。</li>
</ul>
<h2 id="获取和设置属性"><a href="#获取和设置属性" class="headerlink" title="获取和设置属性"></a>获取和设置属性</h2><p>有几种方法可以获取池的属性——可以一次获取所有属性，也可以一次获取一个属性，或者多个属性(以逗号分隔)。例如，假设我只想获取池的健康状况。可以用如下命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool get health tank</span><br><span class="line">NAME  PROPERTY  VALUE   SOURCE</span><br><span class="line">tank  health    ONLINE  -</span><br></pre></td></tr></table></figure><br>如果我想要获得多个设置，比如系统的健康状况、有多少空闲以及分配了多少，可以用如下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool get health,free,allocated tank</span><br><span class="line">NAME  PROPERTY   VALUE   SOURCE</span><br><span class="line">tank  health     ONLINE  -</span><br><span class="line">tank  free       176G    -</span><br><span class="line">tank  allocated  32.2G   -</span><br></pre></td></tr></table></figure><br>当然，如果我想获得所有可用的设置，可以用如下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool get all tank</span><br><span class="line">NAME  PROPERTY       VALUE       SOURCE</span><br><span class="line">tank  size           208G        -</span><br><span class="line">tank  capacity       15%         -</span><br><span class="line">tank  altroot        -           default</span><br><span class="line">tank  health         ONLINE      -</span><br><span class="line">tank  guid           1695112377970346970  default</span><br><span class="line">tank  version        28          default</span><br><span class="line">tank  bootfs         -           default</span><br><span class="line">tank  delegation     on          default</span><br><span class="line">tank  autoreplace    off         default</span><br><span class="line">tank  cachefile      -           default</span><br><span class="line">tank  failmode       wait        default</span><br><span class="line">tank  listsnapshots  off         default</span><br><span class="line">tank  autoexpand     off         default</span><br><span class="line">tank  dedupditto     0           default</span><br><span class="line">tank  dedupratio     1.00x       -</span><br><span class="line">tank  free           176G        -</span><br><span class="line">tank  allocated      32.2G       -</span><br><span class="line">tank  readonly       off         -</span><br><span class="line">tank  ashift         0           default</span><br><span class="line">tank  comment        -           default</span><br><span class="line">tank  expandsize     0           -</span><br></pre></td></tr></table></figure><br>设置属性也很简单。然而，有一个问题。对于需要字符串参数的属性，没有办法将其恢复为默认值，至少据我所知没有。对于其余的属性，如果您试图将属性设置为无效参数，则会在屏幕上显示一个错误，让您知道哪些是可用的，但它不会通知您哪些是默认的。不过，您可以查看“SOURCE”列。如果该列中的值是”default”，那么它就是default。如果它是“local”，那么它是用户定义的。<br>假设我想要改变“comment”属性，我是这样做的:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool set comment=&quot;Contact admins@example.com&quot; tank</span><br><span class="line"># zpool get comment tank</span><br><span class="line">NAME  PROPERTY  VALUE                       SOURCE</span><br><span class="line">tank  comment   Contact admins@example.com  local</span><br></pre></td></tr></table></figure><br>如您所见，SOURCE对于“comment”属性是“本地的”。因此，它是用户定义的。如上所述，我不知道如何在设置完字符串属性后将其恢复为默认值。此外，可以在创建池时使用“-o”参数设置任何可修改的属性，如下所示:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool create -o ashift=12 tank raid1 sda sdb</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这些zpool属性是应用于整个存储池的，这意味着ZFS数据集将从存储池继承这些属性。您在ZFS数据集上设置的一些属性(将在本系列的最后讨论)将应用于整个存储池。例如，如果您为一个ZFS数据集启用了块重复数据删除功能，那么它将重删在整个池中找到的块，而不仅仅是在您的数据集中。然而，只有该数据集中的块将被主动重删，而其他ZFS数据集可能不会。此外，设置属性是不可追溯的。在你的“autoexpand”zpool属性的情况下，自动扩展zpool大小时，所有驱动器已经被替换，如果你在启用该属性之前替换了一个驱动器，该驱动器将被认为是一个更小的驱动器，即使它的物理上不是（也就是说，你在设置“autoexpand”属性为on之前用一块更大容量的盘替换了一个小的盘，也不会自动扩容，默认也会把这个盘认为是原来的小盘，即使后面你开了“autoexpand”属性也不会把之前操作进行扩容了）。设置属性只对设置后属性后面的操作生效。</p>
<p>尽管有这些注意事项，但是作为GNU/Linux存储管理员，能够更改池的一些参数以满足您的需要，这使您能够更好地控制其他文件系统所没有的功能。而且，正如我们到目前为止所发现的，所有事情都可以用一个命令“zpool”的子命令来处理。我们将再写一篇文章，讨论在创建池之前你想要考虑的注意事项，然后我们将转而研究ZFS数据集，这是ZFS的整体支柱。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>和所有的建议一样，这些指南中有一些很重要，而另一些可能没那么重要。你甚至可能无法像你想的那样严格地遵循它们。无论如何，你应该意识到它们。我将尝试为每一项提供一个理由。它们没有特定的顺序。“最佳实践”的目的是为了优化空间效率、性能并确保最大程度的数据完整性。</p>
<ul>
<li>在64位内核上运行ZFS。它具有特定于64位的代码，32位内核无法使用这些代码。</li>
<li>只在大内存的系统上安装ZFS。1 GB是最小值，2 GB更好，启动时首选4 GB。记住，ZFS将为ARC使用1/2的可用RAM。</li>
<li>使用ECC RAM，在可能的情况下，会对寄存器中的数据进行数据清理并保持数据一致性。ARC是RAM中真正的只读数据缓存。</li>
<li>使用整个磁盘而不是分区。因此，ZFS可以更好地利用磁盘上的缓存。如果必须使用分区，则备份分区表，并在将数据重新安装到其他分区时要小心，这样才不会损坏池中的数据。</li>
<li>保持存储池中的每个VDEV的大小相同。如果VDEV的大小不同，ZFS将倾向于更大的VDEV，这可能会导致性能瓶颈。</li>
<li>尽可能使用冗余，因为ZFS可以并且希望纠正池中存在的数据错误。如果池中的其他地方没有冗余的良好副本，则无法修复这些错误。镜像和RAID-Z级别实现了这一点。</li>
<li>优先考虑使用RAIDZ-2或者RAIDZ-3，而不是RAIDZ-1。你一定听过“祸不单行”这句话。对于磁盘故障也是如此。如果RAIDZ-1中的某个硬盘故障，并且热备盘正在进行数据重建处理（resilver），直到数据完全复制完成，则在数据重建期间（resilver data）无法承受另一个硬盘故障，否则将丢失数据。使用RAIDZ-2，您可能会遇到两个磁盘故障，而不是一个磁盘故障，这增加了在第二个甚至第三个磁盘故障之前完全恢复必要数据的可能性。</li>
<li>对整个存储池执行定期备份(至少每周)。这不是备份，除非你有多个复本。硬盘冗余不能保证在断电、硬件故障或线缆断开的情况下，仍有数据能提供服务。</li>
<li>使用热备盘快速恢复损坏的磁盘。将存储池的“autoreplace”属性设置为开启。</li>
<li>当使用多种设备的混合存储池时，需要对SLOG进行镜像，并对L2ARC进行分条（条带化）。</li>
<li>如果使用混合存储池，并对快速SSD或NVRAM驱动器进行分区，除非您明确知道自己需要多大的空间，否则1GB可能已经足够用于您的SLOG了。将剩余的SSD或NVRAM驱动器用于L2ARC，L2ARC的存储空间越大越好。</li>
<li>为了获得最佳性能，请将存储池容量保持在80%以下。由于ZFS的写时复制特性，文件系统变得非常碎片化。至少每月通过电子邮件等方式报告容量情况。</li>
<li>如果可能，建议每周对消费级SATA和SCSI硬盘进行一次数据清理，每月对企业级SAS和FC硬盘进行一次数据清理。数据清理的频率这取决于很多因素，有时这可能是不可能的，所以你可以根据自己业务的具体情况去制定数据清理的频次。但是，基本上，你应该尽可能频繁地进行数据清理。</li>
<li>对于冗余阵列，每周发送存储池运行状况的电子邮件报告，对于非冗余阵列，每两周发送一次。</li>
<li>当使用高级格式化磁盘读写4KB扇区数据时，为了获得最佳性能，在创建池时应该把“ashift”值设为12。对于512字节扇区，默认值是9。（简单的说，用4K盘时，为了获得最佳性能就应该把“ashift”值设为12，普通盘一般是512字节扇区，用这种盘，把“ashift”的值设为9就可以了）。</li>
<li>将“autoexpand”设置为“on”，当存储池中的磁盘全部替换为更大的磁盘后，存储池将自动扩容。默认是关闭的。</li>
<li>记得先导出存储池，当将磁盘从一个物理系统移动到另一个物理系统时。</li>
<li>在考虑性能时，要知道对于顺序写，镜像总是优于RAID-Z级别。对于顺序读取，RAID-Z级别在较小的数据块上执行得比镜像慢，在较大的数据块上执行得更快。对于随机的读写，镜像和RAID-Z性能相差无几。在顺序和随机读写方面，条带镜像的性能都优于镜像和RAID-Z。</li>
<li>压缩在默认情况下是禁用的，这对于今天的硬件来说没有多大意义。ZFS压缩非常便宜、非常快，几乎不增加读写延迟。事实上，在某些情况下，启用压缩的磁盘响应速度比禁用压缩的磁盘响应速度更快。压缩另一个好处是节约存储空间。</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意事项的条条框框并不是为了阻止你使用ZFS。相反，作为规划存储服务器的存储管理员，你需要注意这些事情，以免出现丢掉数据的严重事故。如果您不理解，不重视这些警告，您可能会得到损坏的数据。上述的“最佳实践”列表可能会模糊这一界限。我已经试着列出了所有关于数据损坏的列表。阅读并理解这些说明，应该对你使用ZFS大有裨益。</p>
<ul>
<li>您的VDEV决定存储的IOPS，而该VDEV中最慢的磁盘将决定整个VDEV的IOPS。</li>
<li>ZFS将可用的原始存储容量的1/64用于元数据。因此，如果您购买了一个1TB的硬盘，那么实际的原始大小是976 GiB。在ZFS使用它之后，您将拥有961 GiB的可用空间。“zfs list”命令将显示可用存储的准确表示。规划存储容量的时候，需要记住这一点。</li>
<li>ZFS会控制整个块。它校验、恢复实时数据而不是整个磁盘（resilver data）、自我修复损坏的块，以及许多其他独特的功能。如果使用RAID卡，请确保将其配置为真正的JBOD(或“直通模式”)，这样ZFS就可以控制这些磁盘。如果您的RAID卡不能这样做，就不要使用它。请使用真正的HBA卡。</li>
<li>不要使用ZFS下的其他卷管理软件。如果ZFS能够控制整个块设备，那么它性能更好，并更能确保数据的完整性。因此，避免在ZFS下使用dm-crypt、mdadm或LVM。</li>
<li>不要跨池共享SLOG或L2ARC设备。每个存储池应该有自己的物理设备，而不是逻辑驱动器，就像一些PCI-Express SSD卡的情况一样。在一个存储池上使用全卡，在另一个池子上使用另外一张物理卡。如果您共享一个物理设备，就创建了竞争条件，并最终可能导致数据损坏。</li>
<li>不要在不同的服务器上共享单个存储池。ZFS不是集群文件系统。如果您希望拥有一个共享存储后端，可以在池的顶部使用GlusterFS、Ceph、Lustre或其他一些集群文件系统。</li>
<li>混合池中的除了spare，SLOG和L2ARC之外，不要在单个池中混合VDEVs。如果一个VDEV是镜像，则所有VDEV都应该是镜像。如果一个VDEV是RAIDZ-1，则所有VDEV都应该是RAIDZ-1。当然，除非你知道自己在做什么，并愿意承担后果。ZFS试图在VDEVs之间平衡数据。拥有不同冗余的VDEV可能会导致性能问题和空间效率问题，并且在发生故障时很难恢复。</li>
<li>不要在单个VDEV中混合不同容量或者不同转速的硬盘。但是，<strong>务必混合制造日期，以防止大规模硬盘故障</strong>（也就是集群中要用不同生产日期的硬盘，因为硬盘的使用寿命是差不多的，如果用同一批次，那么很可能出现某一段时间大规模出现硬盘故障的问题）。</li>
<li>事实上，最好完全不要在存储池中混合不同容量或者不同转速的硬盘。</li>
<li>不要在不同VDEVs之间混合磁盘个数。如果一个VDEV使用4个硬盘，则所有VDEV都应该使用4个硬盘。</li>
<li>请勿将单个控制器下的所有硬盘放入同一个VDEV中。规划存储的时候，需要考虑到，当一个控制器故障时，它只影响保持数据在线所需的磁盘数量。</li>
<li>当使用4K盘的时候，必须在创建池时将ashift值设置为12。这是事后无法改变的。创建时参考例子“zpool create -o asshift =12 tank mirror sda sdb”。</li>
<li>默认情况下，热备盘不会被添加到VDEV中来替换故障的硬盘。您必须启用此功能。将“autoreplace”功能设置为on。以“zpool set autoreplace=on tank”为例。</li>
<li>当池中所有较小的硬盘都被较大的硬盘替换时，存储池不会自动调整自己的大小。您必须启用该特性，并且必须在更换第一个磁盘之前启用该特性。以”zpool set autoexpand=on tank”为例。</li>
<li>ZFS不会在VDEV中重新条带化数据，也不会跨多个VDEV重新条带化数据。通常，当向RAID阵列添加新设备时，RAID控制器将通过创建新的条带宽度重建数据。这将释放池中的硬盘上的一些空间，因为它将数据复制到新磁盘。ZFS没有这样的机制。最终，随着时间的推移，磁盘会由于写而平衡，但即使是一次数据清理也不会重建条带宽度。</li>
<li>你不能缩小zpool，只能增大它。这意味着不能从存储池中移除vdev。</li>
<li>你只能用命令“zpool detach”来从镜像VDEV中移除硬盘。不过在RAIDZ和镜像VDEVs中你可以一块盘替换另一块盘。</li>
<li>Do not create a storage pool of files or ZVOLs from an existing zpool. Race conditions will be present, and you will end up with corrupted data. Always keep multiple pools separate.</li>
<li>Linux内核可能不会在每次启动时给一个驱动器分配相同的驱动器号。因此，您应该为您的SLOG和L2ARC使用/dev/disk/by-id/来作为约定。如果不这样做，您的zpool设备可能最终成为SLOG设备，这将反过来可能会破坏您的ZFS数据。</li>
<li>不要“仅仅因为有能力”就创建大规模存储池。尽管ZFS可以创建78位的存储池大小，但这并不意味着您需要创建一个。</li>
<li>不要直接将生产环境放到zpool中，而是放到ZFS数据集上。</li>
<li>不要将生产数据提交到文件VDEVs。只使用文件VDEVs来测试脚本或学习ZFS的细节。<br>如果我遗漏了什么，或者有什么需要改正的地方，请在下面的评论中添加。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/12/zfs-administration-part-vii-zpool-properties/">https://pthree.org/2012/12/12/zfs-administration-part-vii-zpool-properties/</a></p>
<p><a href="https://pthree.org/2012/12/13/zfs-administration-part-viii-zpool-best-practices-and-caveats/">https://pthree.org/2012/12/13/zfs-administration-part-viii-zpool-best-practices-and-caveats/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
        <tag>存储池</tag>
        <tag>最佳实践</tag>
        <tag>注意事项</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（七）写时复制</title>
    <url>/2021/10/13/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/12/5nX7cD.png" alt=""></p>
<span id="more"></span>
<p>在开始实际介绍管理ZFS数据集之前，我们需要确切地理解ZFS是如何存储数据的。所以，这篇文章将是理论性的，涵盖了一些你需要理解的概念：也就是默克尔树和写时复制。我将尝试将它在一个更容易理解的纬度来介绍它们，而不涉及到具体的C代码。</p>
<h2 id="Merkle-Trees（默克尔树）"><a href="#Merkle-Trees（默克尔树）" class="headerlink" title="Merkle Trees（默克尔树）"></a>Merkle Trees（默克尔树）</h2><p> 默克尔树不过是加密哈希树，由拉尔夫·默克尔（Ralph Merkle）发明。为了理解一棵默克尔树，我们将从树的底部开始，并按照我们的方式往上爬。假设你有4个数据块，块0，块1，块2和块3。每个块都经过加密哈希处理，它们的哈希存储在一个节点或“哈希块”中。每个数据块与其散列块之间都有一对一的关系。让我们假设使用的哈希是SHA-256加密哈希算法。进一步假设我们的四个块散列如下:</p>
<ul>
<li>Block 0- 888b19a43b151683c87895f6211d9f8640f97bdc8ef32f03dbe057c8f5e56d32 (hash block 0-0)</li>
<li>Block 1- 4fac6dbe26e823ed6edf999c63fab3507119cf3cbfb56036511aa62e258c35b4 (hash block 0-1)</li>
<li>Block 2- 446e21f212ab200933c4c9a0802e1ff0c410bbd75fca10168746fc49883096db (hash block 1-0)</li>
<li>Block 3- 0591b59c1bdd9acd2847a202ddd02c3f14f9b5a049a5707c3279c1e967745ed4 (hash block 1-1)</li>
</ul>
<p>我们对每个区块进行加密哈希的原因是为了确保数据的完整性。如果区块故意改变，那么它的SHA-256哈希值也应该改变。如果块已损坏，则哈希不会改变。因此，我们可以用SHA-256算法对块进行加密哈希，并检查它是否与其父哈希块匹配。如果是匹配，那么我们就可以确定这个区块很大概率没有被破坏。但是，如果哈希不匹配，那么在相同的前提下，块很可能已损坏。</p>
<p>哈希树通常是二叉树(一个节点最多有2个子节点)，尽管没有必要这样做。假设在我们的例子中，哈希树是一棵二叉树。在这种情况下，哈希块0-0和0-1将有一个共同的父节点，哈希块0。哈希块1-0和1-1将有一个共同的父节点，哈希块1(如下所示)。哈希块0是将哈希块0-0和哈希块0-1连接在一起的SHA-256哈希值。哈希块1也是类似的。因此，我们将得到以下输出:</p>
<ul>
<li>Hash block 0- 8a127ef29e3eb8079aca9aa5fc0649e60edcd0a609dd0285d1f8b7ad9e49c74d</li>
<li>Hash block 1- 69f1a2768dd44d11700ef08c1e4ece72c3b56382f678e6f20a1fe0f8783b12cf</li>
</ul>
<p>我们以类似的方式继续爬升Merkle树，直到我们到达超级哈希块、超级节点或者叫超级块。它是整个树的父节点，它只不过是其所有子节点连接起来的SHA-256散列。因此，对于我们例子中的超级块，是将哈希块0和1连接在一起，我们将得到以下输出:</p>
<ul>
<li>Uber block- 6b6fb7c2a8b73d24989e0f14ee9cf2706b4f72a24f240f4076f234fa361db084<br>*</li>
</ul>
<p>这个超级块负责验证整个默克尔树的完整性。如果一个数据块改变了，所有的父哈希块也应该改变，包括超级块。如果在任何一点上，一个散列与它相应的子节点不匹配，则树中就存在不一致或数据损坏。<br><img src="https://z3.ax1x.com/2021/10/12/5nXPT1.png" alt=""></p>
<p>ZFS使用Merkle树来验证整个文件系统及其中存储的所有数据的完整性。当您对存储池进行数据清理时，ZFS将验证Merkle树中的每个SHA-256哈希，以确保没有损坏的数据。如果存储池中存在冗余，并且发现了损坏的数据块，那么ZFS将使用这些散列在池中的其他位置寻找相同位置的良好数据块。如果找到好的数据，它将使用该块修复损坏的那个数据，然后在Merkle树中重新验证SHA-256哈希。</p>
<p>默克尔树常被应用于数字签名，P2P网络，可信计算，区块链等领域，更多关于其介绍可以参考文章：<a href="https://www.cnblogs.com/fengzhiwu/p/5524324.html">Merkle Tree（默克尔树）解析</a></p>
<h2 id="写时复制（COW-Copy-on-write）"><a href="#写时复制（COW-Copy-on-write）" class="headerlink" title="写时复制（COW, Copy-on-write）"></a>写时复制（COW, Copy-on-write）</h2><p> 写时复制又叫写前拷贝(copy -on-write, COW)是一种数据存储技术，在该技术中，你对将要修改的数据块做一个拷贝，而不是直接修改数据块。然后更新指针以查看新的块位置，而不是旧的块位置。您还可以释放旧块，因此，与修改原始块相比，您不会使用更多的磁盘空间。但是，您确实对底层数据进行了严重的分段。但是，数据存储的COW模型为我们的数据提供了以前不可能或很难实现的新特性。</p>
<p>COW最大的功能是对你的数据进行快照。因为我们在文件系统的其他地方复制了块，所以旧的块仍然存在，即使它已经被文件系统标记为空闲。</p>
<p>在下图中，当一个数据块被更新时，哈希树也必须被更新。以子块开始的所有散列及其所有父节点必须用新的散列更新。黄色块是数据的复本，在文件系统中其他地方，父散列节点被更新以指向新的块位置。<br><img src="https://z3.ax1x.com/2021/10/12/5nXVSO.md.png" alt=""></p>
<p> 如前所述，COW会产生很多的碎片磁盘。这可能会对性能产生巨大影响。因此，需要做一些工作来提前分配块，以最小化碎片。有两种基本方法:使用b树预分配区段，或者使用slab方法，为复制标记磁盘的slab。ZFS使用slab方法，而Btrfs使用b树方法。</p>
<p>通常，文件系统以4KB大小的块写入数据。ZFS以128KB大小的块的形式写入数据。其次，slab分配器将分配一个slab，然后将这个slab分割成多个128 KB的块。第三，ZFS每5秒向磁盘同步一次数据。所有剩余数据将在30秒后刷到磁盘。这使得大量数据在slab中同时被刷新到磁盘。因此，这大大增加了相似数据在同一slab中的概率。因此，在实践中，即使COW正在碎片化文件系统，我们也可以做一些事情来极大地减少碎片。</p>
<p>不仅ZFS使用COW模型，Btrfs、NILFS、WAFL和新的Microsoft文件系统ReFS也使用COW模型。许多虚拟化技术使用COW来存储VM镜像，例如Qemu。COW文件系统是数据存储的未来。我们将在以后的帖子中更详细地讨论快照，以及COW模型是如何发挥作用的。</p>
<h2 id="其他资料对ZFS-COW的介绍"><a href="#其他资料对ZFS-COW的介绍" class="headerlink" title="其他资料对ZFS COW的介绍"></a>其他资料对ZFS COW的介绍</h2><p>首先说下ZFS的copy on write 这个技术并不复杂，看下图比较清晰，<br><img src="https://z3.ax1x.com/2021/10/12/5nXumd.png" alt=""><br>图－1: 可以看到uberblock实际上是Merkle Tree的root. 它记录了文件系统的所有状态，当检索一个数据块的时候, 会从uberblock这里一路往下查找metadata block同时比较checksum, 直到找到对应的数据块。<br>图－2: 当写一个新的block 时，没有performance的影响，当修改一个旧的block时，需要先copy一份, 实际上会带来一些performance的问题, 实际上所有的metadata和checksum都是需要复制新建。 但COW和Transaction技术一起，可以对数据的一致性得到比较好的保护。<br>图－3: 数据已经写入，上层的metadata和checksum的数据也已经修改好，但uberblock还没被更新，这个时候断电重新启动，数据不会丢失，我们仍然可用找到修改的数据, 然后将uberblock原子的更新。<br>图－4: uberblock是通过原子的方式，所有绿色的部分都已经更新。<br>COW 带来另一个好处是Snapshot，Replication非常方便, 如下图:<br><img src="https://z3.ax1x.com/2021/10/12/5nX7cD.png" alt=""><br>做snapshot只需要找上图中不同颜色的相关的数据指针即可！<br>再看Replication, 如下图:<br><img src="https://z3.ax1x.com/2021/10/12/5nXLBd.png" alt=""><br>这里Merkle Tree的每个父亲节点都有一个birth time的元数据，birth time代表着transaction group的ID.这时如果想要复制19-37之间的数据就非常的容易，找到所有birth time大于19的父亲节点再使用数据指针和checksum的数据，找到对应的数据块即可用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/14/zfs-administration-part-ix-copy-on-write/">https://pthree.org/2012/12/14/zfs-administration-part-ix-copy-on-write/</a></p>
<p><a href="https://linux.cn/article-7422-1.html">ZFS 那点事</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
        <tag>COW</tag>
        <tag>写时复制</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（八）创建文件系统</title>
    <url>/2021/10/14/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AB%EF%BC%89%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/13/5Md3jJ.md.png" alt=""></p>
<span id="more"></span>
<p>本文介绍ZFS的基础和核心，被称为“ZFS数据集”或者文件系统。前面的文章，我们一直在讨论如何管理存储池。但是存储池并不意味着直接存储数据。相反，我们应该创建共享相同存储系统的文件系统。从现在开始，我们将这些文件系统称为数据集。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先，在全面理解ZFS数据集之前，我们需要了解GNU/Linux中，传统的文件系统和卷管理是如何工作的。为了公平地对待这一点，我们需要将Linux软件RAID、LVM和ext4或另一个Linux内核支持的文件系统组装在一起。</p>
<p>这是通过创建冗余磁盘阵列，并导出块设备来表示该阵列来实现的。然后，使用LVM对导出的块设备进行格式化。如果我们有多个RAID阵列，我们也会对它们进行格式化。然后我们将所有这些导出的块设备添加到一个“卷组”中，该卷组表示我的池存储。如果我有5个导出的RAID阵列，每个阵列1TB，那么在这个卷组中就有5TB的池存储。现在，我需要决定如何划分卷，以创建特定大小的逻辑卷。如果这是针对Ubuntu或Debian的安装，也许我会给根文件系统一个逻辑卷分配100GB。这100GB现在被标记为卷组所占用。然后我将500GB给我的主目录，等等。每个操作导出一个块设备，代表我的逻辑卷，我使用ext4或其它我选择的文件系统对这些块设备进行格式化。<br><img src="https://z3.ax1x.com/2021/10/13/5Ma6YT.png" alt=""></p>
<p>在这个场景中，卷组中的每个逻辑卷都是固定大小的。它无法处理已满的池。因此，在格式化逻辑卷块设备时，文件系统的大小是固定的。当该设备填满时，必须同时调整逻辑卷和文件系统的大小。这通常需要大量的命令，而且要在不丢失数据的情况下正确地进行操作是有难度的。</p>
<p>ZFS处理文件系统有点不同。首先，不需要用上面介绍的传统文件系统的方法来创建存储。前面的文章已经介绍了如何创建存储池zpool，现在我们将介绍如何使用它。这是通过在文件系统中创建数据集来实现的。默认情况下，该数据集将拥有对整个存储池的完全访问权。如果我们的存储池大小为5TB，如前所述，那么我们的第一个数据集将可以访问池中的所有5TB。如果我创建了第二个数据集，它也将完全访问池中的所有5TB，以此类推。<br><img src="https://z3.ax1x.com/2021/10/13/5Md3jJ.md.png" alt=""></p>
<p>现在，当文件被放置在数据集中时，存储池将该文件所占有的存储标记为所有数据集不可用。这意味着每个数据集都知道池中哪些是可用的，哪些是池中所有其他数据集不可用的。不需要创建大小有限的逻辑卷。每个数据集都可以继续往存储池中放文件，直到池被填满。当然，您可以对数据集设置配额，限制它们的大小，或者导出ZVOLs，这些主题我们将在后面介绍。</p>
<p>好，接下来让我们来创建一些数据集。</p>
<h2 id="基本创建"><a href="#基本创建" class="headerlink" title="基本创建"></a>基本创建</h2><p>在接下来的这些示例中，假设我们的ZFS共享存储名为“tank”。此外，我们将假设在RAIDZ-1阵列中创建了4个预分配的文件，每个文件的大小为1GB。让我们在这些基础上创建一些数据集。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create tank/test</span><br><span class="line"># zfs list</span><br><span class="line">NAME         USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank         175K  2.92G  43.4K  /tank</span><br><span class="line">tank/test   41.9K  2.92G  41.9K  /tank/test</span><br></pre></td></tr></table></figure><br> 注意，数据集“tank/test”在默认情况下被挂载到“tank/test”，并且它对整个池有完全的访问权限。还要注意，它只占用池的41.9 KB。让我们再创建4个数据集，然后看看输出:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create tank/test2</span><br><span class="line"># zfs create tank/test3</span><br><span class="line"># zfs create tank/test4</span><br><span class="line"># zfs create tank/test5</span><br><span class="line"># zfs list</span><br><span class="line">NAME         USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank         392K  2.92G  47.9K  /tank</span><br><span class="line">tank/test   41.9K  2.92G  41.9K  /tank/test</span><br><span class="line">tank/test2  41.9K  2.92G  41.9K  /tank/test2</span><br><span class="line">tank/test3  41.9K  2.92G  41.9K  /tank/test3</span><br><span class="line">tank/test4  41.9K  2.92G  41.9K  /tank/test4</span><br><span class="line">tank/test5  41.9K  2.92G  41.9K  /tank/test5</span><br></pre></td></tr></table></figure><br>每个数据集自动挂载到其各自的挂载点，并且每个数据集可以完全自由地访问存储池。让我们在其中一个数据集中填充一些数据，看看这是如何影响底层存储的:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd /tank/test3</span><br><span class="line"># for i in &#123;1..10&#125;; do dd if=/dev/urandom of=file$i.img bs=1024 count=$RANDOM &amp;&gt; /dev/null; done</span><br><span class="line"># zfs list</span><br><span class="line">NAME         USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank         159M  2.77G  49.4K  /tank</span><br><span class="line">tank/test   41.9K  2.77G  41.9K  /tank/test</span><br><span class="line">tank/test2  41.9K  2.77G  41.9K  /tank/test2</span><br><span class="line">tank/test3   158M  2.77G   158M  /tank/test3</span><br><span class="line">tank/test4  41.9K  2.77G  41.9K  /tank/test4</span><br><span class="line">tank/test5  41.9K  2.77G  41.9K  /tank/test5</span><br></pre></td></tr></table></figure><br>注意，在我的例子中，“tank/test3”占用了158 MB磁盘，因此根据其余的数据集，池中只有2.77 GB可用，而以前是2.92 GB。因此，正如您所看到的，这里最大的优点是我不需要担心预分配的块设备，就像使用LVM时一样。相反，ZFS管理整个堆栈，因此它了解有多少数据被占用，有多少数据可用。</p>
<h2 id="Mounting-数据集"><a href="#Mounting-数据集" class="headerlink" title="Mounting 数据集"></a>Mounting 数据集</h2><p>在创建数据集时，默认情况下并没有创建可导出的块设备，理解这一点很重要。这意味着您没有可以直接挂载的东西。总之，没有任何东西可以添加到/etc/fstab文件中以便持久化，重启后也会自动挂载。</p>
<p>那么，如果没有什么要添加的，那么如何挂载文件系统呢? 如果确实需要的话，这是通过导入池，然后运行“zfs mount”命令来完成的。类似地，我们有一个”zfs unmount”命令来卸载数据集，或者我们可以使用标准的”umount”工具:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># umount /tank/test5</span><br><span class="line"># mount | grep tank</span><br><span class="line">tank/test on /tank/test type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test2 on /tank/test2 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test3 on /tank/test3 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test4 on /tank/test4 type zfs (rw,relatime,xattr)</span><br><span class="line"># zfs mount tank/test5</span><br><span class="line"># mount | grep tank</span><br><span class="line">tank/test on /tank/test type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test2 on /tank/test2 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test3 on /tank/test3 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test4 on /tank/test4 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test5 on /tank/test5 type zfs (rw,relatime,xattr)</span><br></pre></td></tr></table></figure><br>默认情况下，数据集的挂载点为”/\<pool-name>/\<dataset-name>“。这可以通过更改数据集属性进行更改。正如存储池具有可调优的属性一样，数据集也是如此。稍后我们将专门发表一篇完整的文章来介绍数据集属性。我们只需要适当的更改“mountpoint”属性，如下所示:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set mountpoint=/mnt/test tank/test</span><br><span class="line"># mount | grep tank</span><br><span class="line">tank on /tank type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test2 on /tank/test2 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test3 on /tank/test3 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test4 on /tank/test4 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test5 on /tank/test5 type zfs (rw,relatime,xattr)</span><br><span class="line">tank/test on /mnt/test type zfs (rw,relatime,xattr)</span><br></pre></td></tr></table></figure></p>
<h2 id="嵌套数据集"><a href="#嵌套数据集" class="headerlink" title="嵌套数据集"></a>嵌套数据集</h2><p>数据集不需要被隔离。您可以在彼此之间创建嵌套的数据集。这允许您在不影响其他目录结构的情况下创建命名空间，同时调优嵌套目录结构。例如，你可能想压缩/var/log，而不是父文件/var。它还有其他的好处，还有一些我们将在后面介绍的注意事项。</p>
<p>要创建嵌套数据集，请像创建其他数据集一样，提供父存储池和数据集。在下面的例子中，我们将在test数据集中创建一个嵌套的log数据集:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create tank/test/log</span><br><span class="line"># zfs list</span><br><span class="line">NAME            USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank            159M  2.77G  47.9K  /tank</span><br><span class="line">tank/test      85.3K  2.77G  43.4K  /mnt/test</span><br><span class="line">tank/test/log  41.9K  2.77G  41.9K  /mnt/test/log</span><br><span class="line">tank/test2     41.9K  2.77G  41.9K  /tank/test2</span><br><span class="line">tank/test3      158M  2.77G   158M  /tank/test3</span><br><span class="line">tank/test4     41.9K  2.77G  41.9K  /tank/test4</span><br><span class="line">tank/test5     41.9K  2.77G  41.9K  /tank/test5</span><br></pre></td></tr></table></figure></p>
<h2 id="数据集管理"><a href="#数据集管理" class="headerlink" title="数据集管理"></a>数据集管理</h2><p>除了创建数据集，当您不再需要它们时，还可以销毁它们。销毁数据集将释放块供其他数据集使用，销毁数据集后不能在没有快照的情况下还原，这一点我们将在后面介绍。销毁数据集命令如下:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs destroy tank/test5</span><br><span class="line"># zfs list</span><br><span class="line">NAME            USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank            159M  2.77G  49.4K  /tank</span><br><span class="line">tank/test      41.9K  2.77G  41.9K  /mnt/test</span><br><span class="line">tank/test/log  41.9K  2.77G  41.9K  /mnt/test/log</span><br><span class="line">tank/test2     41.9K  2.77G  41.9K  /tank/test2</span><br><span class="line">tank/test3      158M  2.77G   158M  /tank/test3</span><br><span class="line">tank/test4     41.9K  2.77G  41.9K  /tank/test4</span><br></pre></td></tr></table></figure><br> 如果需要，我们也可以重命名数据集。当数据集的用途发生变化，并且希望名称反映该用途时，这很方便。参数以source数据集作为第一个参数，以新名称作为后一个参数。例子是将数据集tank/test3 重命名为tank/music:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs rename tank/test3 tank/music</span><br><span class="line"># zfs list</span><br><span class="line">NAME            USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank            159M  2.77G  49.4K  /tank</span><br><span class="line">tank/music      158M  2.77G   158M  /tank/music</span><br><span class="line">tank/test      41.9K  2.77G  41.9K  /mnt/test</span><br><span class="line">tank/test/log  41.9K  2.77G  41.9K  /mnt/test/log</span><br><span class="line">tank/test2     41.9K  2.77G  41.9K  /tank/test2</span><br><span class="line">tank/test4     41.9K  2.77G  41.9K  /tank/test4</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文帮助您开始理解ZFS数据集。还有许多与“zfs”命令相关的子命令可用，它们有许多不同的参数。你可以通过查看手册页以获得完整的清单。然而，本文并不是对数据集的深入彻底的掌握，随着我们对数据集的探索，更多的原则和概念将会浮出海面。最后，您应该足够熟悉数据集，从而能够以最小的努力管理整个存储的基础设施。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/17/zfs-administration-part-x-creating-filesystems/">https://pthree.org/2012/12/17/zfs-administration-part-x-creating-filesystems/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（九）压缩与数据去重</title>
    <url>/2021/10/15/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E4%B9%9D%EF%BC%89%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/14/51lt0K.png" alt=""></p>
<span id="more"></span>
<p>本文主要介绍ZFS的压缩和数据去重特性。</p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>如果你开启了ZFS的压缩功能，这个压缩过程是透明的。也就是说，在你开启压缩功能后，在你存储池中的每一个文件都被压缩了，但是从应用程序的角度来看，感受不到这一点，感觉文件没有被压缩。主要是ZFS压缩解压磁盘上的数据是动态进行的，并且压缩对CPU消耗很小而且一些压缩算法很快，所以上层通常感知不到（没有注意到压缩这个事情）。</p>
<p>可以对每个数据集启用和禁用压缩。支持的压缩算法有LZJB、LZ4、ZLE和Gzip。对于Gzip，支持标准级别是1到9，其中1是尽可能快的，压缩率最少，9是压缩比例高，但是耗时最多，默认值是6，这是GNU/Linux和其他Unix操作系统的标准值。LZJB是由Jeff Bonwick发明的，同时他也是ZFS的作者。LZJB被设计为具有紧凑的压缩比，这是大多数Lempel-Ziv算法的标准。LZJB是ZFS默认采用的压缩算法。ZLE是一个速度非常块，具有非常轻的压缩比。在性能和压缩方面，LZJB似乎提供了最好的全面结果。</p>
<p><strong>更新</strong>:自从写这篇文章以来，<strong>LZ4已经被引入到Linux上的ZFS中，现在它是使用ZFS进行压缩的首选方式</strong>。它不仅速度快，而且提供了比LZJB更紧凑的压缩比——平均约为0.23%</p>
<p>显然，根据存储的数据的不同，压缩节省的磁盘空间也会有所不同。如果数据集主要存储未压缩的数据，如纯文本日志文件或配置文件，则压缩比可能是巨大的。如果数据集主要存储的是压缩的图像和视频，那么在磁盘节省方面就不可观。压缩在默认情况下是禁用的，启用LZJB或LZ4似乎不会产生任何性能影响。因此，即使您存储的是大量压缩的数据，对于那些未压缩的数据文件，启用压缩后您也可以节约一些磁盘空间，而不会影响存储服务器的性能。所以，在我看来，我建议对所有的数据集启用压缩。</p>
<p><strong>警告</strong>:对数据集启用压缩是不可追溯的!它只适用于新提交或修改的数据。数据集中以前的任何数据都将保持未压缩状态。因此，如果您想使用压缩，您应该在开始提交数据之前启用它。</p>
<p>要在数据集上启用压缩，我们只需要修改“compression”属性。该属性的有效值是:”on”， “off”， “lzjb”， “lz4”， “gzip”， “gzip[1-9]”和”zle”。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create tank/log</span><br><span class="line"># zfs set compression=lz4 tank/log</span><br></pre></td></tr></table></figure><br>现在我们已经在这个数据集上启用了压缩，让我们复制一些未压缩的数据，看看我们会看到节省多少空间。未压缩数据的源文件是/etc/和/var/log/目录。让我们为这些目录创建一个tar包，看看它的原始大小，然后再看看节省了多少空间:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tar -cf /tank/test/text.tar /var/log/ /etc/</span><br><span class="line"># ls -lh /tank/test/text.tar</span><br><span class="line">-rw-rw-r-- 1 root root 24M Dec 17 21:24 /tank/test/text.tar</span><br><span class="line"># zfs list tank/test</span><br><span class="line">NAME        USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank/test  11.1M  2.91G  11.1M  /tank/test</span><br><span class="line"># zfs get compressratio tank/test</span><br><span class="line">NAME       PROPERTY       VALUE  SOURCE</span><br><span class="line">tank/test  compressratio  2.14x  -</span><br></pre></td></tr></table></figure><br>在上面的例子中，我创建一个24MB的未压缩的tar包，把它拷贝到开启压缩的数据中后，它只占用11.1MB，还不到原始文件的一半（文本文件很适合压缩）！我们可以读取数据集上的“compressratio”属性，看看节省了多少磁盘空间。在上面的例子中，输出告诉我，如果未压缩，压缩后的数据将占用2.14倍的磁盘空间，非常好的结果。</p>
<h2 id="数据去重（Deduplication，重复数据删除-重删）"><a href="#数据去重（Deduplication，重复数据删除-重删）" class="headerlink" title="数据去重（Deduplication，重复数据删除/重删）"></a>数据去重（Deduplication，重复数据删除/重删）</h2><p> 我们还有另一种与压缩相结合的方法来节约磁盘空间，那就是重复数据删除。现在，有三种主要的重复数据删除类型:文件、块和字节。文件重复数据删除是性能最高、系统资源成本最低的。每个文件都使用加密哈希算法进行哈希，比如SHA-256。如果哈希值匹配多个文件，则不将新文件存储在磁盘上，而是在元数据中引用原始文件。这可以节省大量空间，但也有一个严重的缺点。如果文件中的单个字节发生了变化，哈希值将不再匹配，这意味着我们不能再在文件系统元数据中引用整个文件。因此，我们必须将磁盘所有块做一个复本，对于大文件，这对性能有很大的影响。</p>
<p>另一种极端情况是字节重复数据删除，这种重复数据删除方法成本最高，因为您必须保留“锚点”，以确定重复数据删除和唯一字节区域的开始和结束位置。毕竟，字节就是字节，是不知道哪些文件需要它们，它只不过是一个数据的海洋。这种重复数据删除技术适用于文件可能被存储多次的存储，即使文件没有在相同的块下对齐，比如邮件附件。</p>
<p> 块重复数据删除处于三者中间位置。<strong>ZFS仅支持块重复数据删除</strong>。块重删共享文件中所有相同的块。这允许我们只在磁盘上存储唯一的块，并在RAM中引用共享块。它比字节重复数据删除更高效，比文件重复数据删除更灵活。然而，它有一个缺点——它需要大量的内存来记录哪些块是共享的，哪些不是。不过，因为文件系统读写数据是以块的方式，所以对现代文件系统使用块重复数据删除是最有意义的。</p>
<p>共享块被存储在所谓的“重复数据删除表”中，文件系统上重复的块越多，这个表就越大。每次写入或读取数据时，重复数据删除表都会被引用。这意味着您希望将整个重复数据删除表保存在快速RAM中。如果您没有足够的RAM，那么表将溢出到磁盘上。这可能会对存储的性能产生巨大的影响，无论是读数据还是写数据。</p>
<h2 id="数据去重的开销"><a href="#数据去重的开销" class="headerlink" title="数据去重的开销"></a>数据去重的开销</h2><p>所以这还有个问题:你需要多少内存来存储你的重复数据删除表?这个问题没有一个简单的答案，但是我们可以对如何处理这个问题有一个很好的总体思路。首先，查看存储池中的块数量。你可以看到这个信息，用如下的命令(耐心点-在它给出报告之前，可能需要一段时间来扫描文件系统中的所有块):<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zdb -b rpool</span><br><span class="line"></span><br><span class="line">Traversing all blocks to verify nothing leaked ...</span><br><span class="line"></span><br><span class="line">        No leaks (block sum matches space maps exactly)</span><br><span class="line"></span><br><span class="line">        bp count:          288674</span><br><span class="line">        bp logical:    34801465856      avg: 120556</span><br><span class="line">        bp physical:   30886096384      avg: 106992     compression:   1.13</span><br><span class="line">        bp allocated:  31092428800      avg: 107707     compression:   1.12</span><br><span class="line">        bp deduped:             0    ref&gt;1:      0   deduplication:   1.00</span><br><span class="line">        SPA allocated: 31092244480     used: 13.53%</span><br></pre></td></tr></table></figure><br>在本例中，存储池“rpool”中有288674块被使用(查看“bp count”)。<strong>池中的每个重复数据删除块需要大约320字节的内存</strong>。因此，对于288674块乘以320字节/块，我们得到大约92 MB。文件系统大约有200 GB大小，所以我们可以假设重复数据删除只能增长到大约670 MB，尽管它只有13.53%被填满。也就是说，每1GB的文件系统需要3.35 MB的重复数据删除数据，或者每1TB的磁盘需要3.35 GB的RAM。</p>
<p>如果您需要提前规划存储，并且希望在提交数据之前知道大小，那么您需要计算出块的平均大小。 在这种情况下，您需要非常熟悉这些数据。ZFS以128KB块大小的形式读写数据。但是，如果您要存储大量的配置文件、主目录等，那么您的文件将小于128KB。对于本例，我们假设平均块大小为100 KB，如上例所示。如果我的总存储是1TB，那么1TB除以100KB每个块大约是10737418块，然后乘以每块320字节，我们得到3.2 GB的RAM，这接近我们之前得到的数字。</p>
<p><strong>一个好的经验法则是，为每1TB磁盘规划5GB RAM</strong>。这很快就会变得非常昂贵。一个12 TB的池(在许多企业中很小)将需要60 GB RAM来确保您的重复数据删除表被存储和快速访问。请记住，一旦重复数据删除表溢出到磁盘，就会造成严重的性能影响。</p>
<h2 id="数据去重的总内存开销"><a href="#数据去重的总内存开销" class="headerlink" title="数据去重的总内存开销"></a>数据去重的总内存开销</h2><p>ZFS在RAM中存储的不仅仅是重复数据删除表。它还存储ARC以及其他ZFS元数据。你猜怎么着?重复数据删除表的大小上限是ARC的25%。这意味着，一个12TB的存储阵列需要的内存不只是60GB，而是需要240GB RAM来确保您的重复数据删除表能被完全存下。换句话说，如果您计划做重复数据删除，请确保将内存占用增加四倍，否则您将受到伤害（性能受到很大影响）。</p>
<p>请确保系统具有足够的内存来支持重复数据删除，如下所示：  </p>
<ul>
<li><strong>每个块的对应的重复数据删除表项大小约为 320 字节</strong>。  </li>
<li>用分配的块数乘以 320，即可得到大概需要多少内存。<br>例如：<pre><code>in-core DDT size = 2.63M x 320 = 841.60M
</code></pre></li>
</ul>
<h2 id="L2ARC中的重复数据删除表"><a href="#L2ARC中的重复数据删除表" class="headerlink" title="L2ARC中的重复数据删除表"></a>L2ARC中的重复数据删除表</h2><p>内存放不下的重复数据删除表可能会溢出到L2ARC，不一定是慢盘。如果您的L2ARC由快SSD或RAM驱动器组成，那么每次读取和写入重复数据删除表对性能的影响不会像溢出到盘片磁盘那样严重。然而，它仍然会有影响，因为SSD性能还是比不上内存。因此，对于性能要求不是很高的存储服务器，例如夜间或每周备份服务器，重复数据删除表溢出到L2ARC上，是完全可以接受的。</p>
<h2 id="启用数据去重"><a href="#启用数据去重" class="headerlink" title="启用数据去重"></a>启用数据去重</h2><p>可以通过设置”dedup”属性来启用数据去重。同压缩一样，数据去重对以前提交的数据不起作用。它只应用于新提交或修改的数据。此外，重复数据删除后的数据不会作为原子事务刷新到磁盘。相反，这些块是串行地写入磁盘的，每次一个块。因此，在写入块之前出现电源故障时，这将使您面临数据损坏的风险。</p>
<p>让我们在“tank/test”数据集上启用数据去重特性，然后拷贝一个相同的tar包，给它一个不同的名称，并看看这将如何影响重复数据删除比率。注意，获取重复数据删除比率是使用“zpool”命令，而不是使用“zfs”命令。首先，我们需要启用数据集的重复数据删除功能:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set dedup=on tank/test</span><br><span class="line"># cp /tank/test/text.tar&#123;,.2&#125;</span><br><span class="line"># tar -cf /tank/test/boot.tar /boot</span><br><span class="line"># zfs get compressratio tank/test</span><br><span class="line">NAME       PROPERTY       VALUE  SOURCE</span><br><span class="line">tank/test  compressratio  1.74x  -</span><br><span class="line"># zpool get dedupratio tank</span><br><span class="line">NAME  PROPERTY    VALUE  SOURCE</span><br><span class="line">tank  dedupratio  1.42x  -</span><br><span class="line"># ls -lh /tank/test</span><br><span class="line">total 38M</span><br><span class="line">-rw-rw-r-- 1 root root 18M Dec 17 22:31 boot.tar</span><br><span class="line">-rw-rw-r-- 1 root root 24M Dec 17 22:27 text.tar</span><br><span class="line">-rw-rw-r-- 1 root root 24M Dec 17 22:29 text.tar.2</span><br><span class="line"># zfs list tank/test</span><br><span class="line">NAME        USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank/test  37.1M  2.90G  37.1M  /tank/test</span><br></pre></td></tr></table></figure><br>在这个例子中，首先对数据进行压缩，然后进行数据去重。原始数据通占用66MB的磁盘空间，但是由于压缩和数据去重，它只占用37MB，节约了不少存储空间。</p>
<h2 id="结论及建议"><a href="#结论及建议" class="headerlink" title="结论及建议"></a>结论及建议</h2><p>毫无疑问，压缩和数据去重可以提供巨大的存储效益。对于实时运行的生产数据，压缩节省了巨大的存储空间，而对性能的影响可以忽略不计。对于混合数据，我通常会看到1.15倍的节省，就成本而言，这是很值得的。但是，对于数据去重，我发现不值得这么麻烦，除非性能根本不是问题。数据去重对RAM和L2ARC的消耗占比是巨大的。当它溢出到普通盘上时（内存和L2ARC上存不下数据去重表），你就可以和性能说再见了。对于混合数据，我很少看到它能节省超过1.10倍的，在我看来这是不值得的。此外，在我看来，数据去重带来的数据损坏风险也是不值得的。因此，作为建议，我建议您在默认情况下对所有数据集启用压缩，不要开启数据去重，除非您知道您有足够的内存来容纳数据去重表。如果您负担得起这种开销，那么节省的空间将非常可观，这是ext4、XFS和其他文件系统无法实现的。</p>
<p>关于是否启用ZFS的数据去重，我再多说一点：主要还是取决于你的数据。如果你的数据确实不包含重复，则开启去重功能则会带来额外的开销且没有任何的好处。但是如果你的数据包含重复，则使用ZFS的去重可以节约空间而且提高性能。节约空间是显而易见的，性能的提高是因为减少了重复数据的写磁盘消耗和内存页的置换。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/18/zfs-administration-part-xi-compression-and-deduplication/">https://pthree.org/2012/12/18/zfs-administration-part-xi-compression-and-deduplication/</a></p>
<p><a href="https://www.cnblogs.com/itech/archive/2012/06/19/2555442.html">ZFS与数据去重</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
        <tag>压缩</tag>
        <tag>去重</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（十）快照和克隆</title>
    <url>/2021/10/16/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%EF%BC%89%E5%BF%AB%E7%85%A7%E5%92%8C%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/15/58yGut.png" alt=""></p>
<span id="more"></span>
<p>ZFS里面的快照和Linux LVM中的快照是类似的。快照是只读的，它是你做快照的时候的文件系统的一份镜像复本。可以想象成对外部世界的一个数字照片，即使外部世界发生了变化，然而那个照片还是保留了拍下照片的那个时候的外部世界的样子。</p>
<p>您可以在池中保留至多2^64个快照，ZFS快照是持久化的，即使重启也不会丢失，而且它们不需要任何额外的备份存储;它们与其他数据一样使用相同的存储池。如果您还记得我们关于“写时复制”文件系统特性的文章，您应该会记得我们关于Merkle树的讨论。ZFS快照是处于该状态的Merkle树的副本，但我们要确保该Merkle树的快照永远不会被修改。</p>
<p> 创建快照几乎是瞬时的，而且成本低廉。但是，一旦数据开始更改，快照将开始存储数据。如果您有多个快照，那么将在所有快照中将记录多个增量。然而，根据您的需要，快照仍然可以非常便宜。</p>
<h2 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h2><p> 你可以创建两种类型快照：池快照和数据集快照。您想要哪种类型的快照取决于您。但是，您必须为快照指定一个名。快照名的语法为:</p>
<ul>
<li>pool/dataset@snapshot-name</li>
<li>pool@snapshot-name</li>
</ul>
<p>创建快照需要使用“zfs snapshot”命令，比如，要对数据集“tank/test”创建快照，应该执行如下命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs snapshot tank/test@tuesday</span><br></pre></td></tr></table></figure><br>因为快照是一类只读的文件系统，所以无法像标准的ZFS数据集或者存储池那样可以进行属性修改，比如你想对一个快照启用压缩特性，将会发生如下情况：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set compression=lzjb tank/test@friday</span><br><span class="line">cannot set property for &#x27;tank/test@friday&#x27;: this property can not be modified for snapshots</span><br></pre></td></tr></table></figure></p>
<h2 id="列出快照"><a href="#列出快照" class="headerlink" title="列出快照"></a>列出快照</h2><p>快照可以通过两种方式显示:通过访问数据集根目录下的隐藏的”.zfs”目录，或者使用“zfs list”命令。首先，让我们讨论隐藏目录。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls -a /tank/test</span><br><span class="line">./  ../  boot.tar  text.tar  text.tar.2</span><br><span class="line"># cd /tank/test/.zfs/</span><br><span class="line"># ls -a</span><br><span class="line">./  ../  shares/  snapshot/</span><br></pre></td></tr></table></figure><br>即使使用“ls -a”命令，“.zfs”目录也不可见，不过我们可以cd到这个目录中去。如果你想让“.zfs”目录可见，你可以更改该数据集上的“snapdir”属性。有效值是”hidden”和”visible”。默认情况下，它是隐藏的。让我们来试试：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set snapdir=visible tank/test</span><br><span class="line"># ls -a /tank/test</span><br><span class="line">./  ../  boot.tar  text.tar  text.tar.2  .zfs/</span><br></pre></td></tr></table></figure><br>另一种显示快照的方法是使用”zfs list”命令，并传入”-t snapshot”参数，如下所示:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs list -t snapshot</span><br><span class="line">NAME                              USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">pool/cache@2012:12:18:51:2:19:00      0      -   525M  -</span><br><span class="line">pool/cache@2012:12:18:51:2:19:15      0      -   525M  -</span><br><span class="line">pool/home@2012:12:18:51:2:19:00   18.8M      -  28.6G  -</span><br><span class="line">pool/home@2012:12:18:51:2:19:15   18.3M      -  28.6G  -</span><br><span class="line">pool/log@2012:12:18:51:2:19:00     184K      -  10.4M  -</span><br><span class="line">pool/log@2012:12:18:51:2:19:15     184K      -  10.4M  -</span><br><span class="line">pool/swap@2012:12:18:51:2:19:00       0      -    76K  -</span><br><span class="line">pool/swap@2012:12:18:51:2:19:15       0      -    76K  -</span><br><span class="line">pool/vmsa@2012:12:18:51:2:19:00       0      -  1.12M  -</span><br><span class="line">pool/vmsa@2012:12:18:51:2:19:15       0      -  1.12M  -</span><br><span class="line">pool/vmsb@2012:12:18:51:2:19:00       0      -  1.31M  -</span><br><span class="line">pool/vmsb@2012:12:18:51:2:19:15       0      -  1.31M  -</span><br><span class="line">tank@2012:12:18:51:2:19:00            0      -  43.4K  -</span><br><span class="line">tank@2012:12:18:51:2:19:15            0      -  43.4K  -</span><br><span class="line">tank/test@2012:12:18:51:2:19:00       0      -  37.1M  -</span><br><span class="line">tank/test@2012:12:18:51:2:19:15       0      -  37.1M  -</span><br></pre></td></tr></table></figure><br>注意，默认情况下，该命令将显示所有池的所有快照。<br>如果希望输出更具体，可以查看给定父节点的所有快照，无论它是数据集还是存储池。您只需要传递“-r”参数以进行递归，然后提供父节点名称。在本例中，我将只看“tank”的快照，而忽略“pool”中的快照:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs list -r -t snapshot tank</span><br><span class="line">NAME                              USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank@2012:12:18:51:2:19:00           0      -  43.4K  -</span><br><span class="line">tank@2012:12:18:51:2:19:15           0      -  43.4K  -</span><br><span class="line">tank/test@2012:12:18:51:2:19:00      0      -  37.1M  -</span><br></pre></td></tr></table></figure></p>
<h2 id="消耗快照"><a href="#消耗快照" class="headerlink" title="消耗快照"></a>消耗快照</h2><p>与销毁存储池或ZFS数据集一样，也可以使用类似的方法销毁快照。要销毁快照，使用“zfs destroy”命令，并提供要销毁的快照作为参数:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs destroy tank/test@2012:12:18:51:2:19:15</span><br></pre></td></tr></table></figure><br>需要知道的一件重要的事情是，如果快照存在，它就被认为是数据集的子文件系统。因此，在销毁所有快照和嵌套数据集之前，不能删除数据集。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs destroy tank/test</span><br><span class="line">cannot destroy &#x27;tank/test&#x27;: filesystem has children</span><br><span class="line">use &#x27;-r&#x27; to destroy the following datasets:</span><br><span class="line">tank/test@2012:12:18:51:2:19:15</span><br><span class="line">tank/test@2012:12:18:51:2:19:00</span><br></pre></td></tr></table></figure></p>
<h2 id="重命名快照"><a href="#重命名快照" class="headerlink" title="重命名快照"></a>重命名快照</h2><p>可以重命名快照，但是必须在创建快照的存储池和ZFS数据集中重命名快照。重命名快照非常简单:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs rename tank/test@2012:12:18:51:2:19:15 tank/test@tuesday-19:15</span><br></pre></td></tr></table></figure></p>
<h2 id="回滚快照"><a href="#回滚快照" class="headerlink" title="回滚快照"></a>回滚快照</h2><p>如果不讨论将文件系统回滚到上一个快照，那么关于快照的讨论就不完整。</p>
<p>回滚到上一个快照将丢弃该快照与当前时间之间的任何数据更改。默认情况下，只能回滚到最近的快照。为了回滚到更早的快照，您必须销毁当前时间和希望回滚到的快照之间的所有快照。如果这还不够，则必须在开始回滚之前卸载文件系统。这意味着停机时间。</p>
<p>要回滚“tank/test”数据集到“tuesday”快照，我们会发出以下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs rollback tank/test@tuesday</span><br><span class="line">cannot rollback to &#x27;tank/test@tuesday&#x27;: more recent snapshots exist</span><br><span class="line">use &#x27;-r&#x27; to force deletion of the following snapshots:</span><br><span class="line">tank/test@wednesday</span><br><span class="line">tank/test@thursday</span><br></pre></td></tr></table></figure><br> 与上面提到的一样，我们必须删除“@wednesday”和“@thursday”快照，然后才能回滚到“@tuesday”快照。</p>
<h2 id="ZFS克隆"><a href="#ZFS克隆" class="headerlink" title="ZFS克隆"></a>ZFS克隆</h2><p>ZFS克隆是一个从快照“升级”的可写文件系统。克隆只能从快照创建，只要克隆存在，对快照的依赖就会保持。这意味着，如果你克隆了快照，就不能直接销毁这个快照。克隆依赖快照提供给它的数据，所以在销毁快照之前，必须先销毁克隆。</p>
<p>创建克隆几乎是瞬时的，就像快照一样，最初并不会占用任何额外的空间。相反，它会占用快照的所有初始空间。当数据在克隆中被修改时，它开始占用与快照分离的空间。</p>
<h2 id="创建ZFS克隆"><a href="#创建ZFS克隆" class="headerlink" title="创建ZFS克隆"></a>创建ZFS克隆</h2><p>使用“zfs clone”命令、要克隆的快照和新文件系统的名称来创建克隆。克隆不需要驻留在与克隆相同的数据集中，但它需要驻留在相同的存储池中。 例如，如果我想克隆“tank/test@tuesday”快照，并给它命名为“tank/tuesday”，我将运行以下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs clone tank/test@tuesday tank/tuesday</span><br><span class="line"># dd if=/dev/zero of=/tank/tuesday/random.img bs=1M count=100</span><br><span class="line"># zfs list -r tank</span><br><span class="line">NAME           USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">tank           161M  2.78G  44.9K  /tank</span><br><span class="line">tank/test     37.1M  2.78G  37.1M  /tank/test</span><br><span class="line">tank/tuesday   124M  2.78G   161M  /tank/tuesday</span><br></pre></td></tr></table></figure></p>
<h2 id="销毁克隆"><a href="#销毁克隆" class="headerlink" title="销毁克隆"></a>销毁克隆</h2><p>与销毁数据集或快照一样，我们使用“zfs destroy”命令。再强调一遍，在您销毁克隆之前，不能销毁快照。所以，如果我们想要摧毁“tank/tuesday”的克隆，用如下命令，就像销毁其他数据集一样:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs destroy tank/tuesday</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>因为保存快照非常便宜，所以建议经常对数据集进行快照</strong>。Sun Microsystems提供了一个Time Slider ，它是GNOME Nautilus文件管理器的一部分。Time Slider 保存快照的方式如下:</p>
<ul>
<li>频率–每15分钟做一次快照，保留4张快照</li>
<li>每小时–每小时快照，保留24张快照</li>
<li>Daily –每天快照，保留31个快照</li>
<li>每周–每周快照，保留7个快照</li>
<li>Monthly–每月快照，保留12个快照<br>不幸的是，Time Slider 不是标准GNOME桌面的一部分，所以GNU/Linux上没有。 然而，Linux上的ZFS开发人员已经创建了一个“zfs-auto-snapshot”包，如果运行Ubuntu，你可以从项目的PPA中安装它。如果你运行的是另一种GNU/Linux操作系统，您可以轻松地编写一个Bash或Python脚本来模拟该功能，并将其放在您的根用户的crontab中。</li>
</ul>
<p>因为快照和克隆都很便宜，所以建议您充分利用它们。克隆对于测试部署虚拟机或从生产环境克隆的开发环境非常有用。而且可以很容易地销毁它们，而不会影响创建快照的父数据集。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/19/zfs-administration-part-xii-snapshots-and-clones/">https://pthree.org/2012/12/19/zfs-administration-part-xii-snapshots-and-clones/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
        <tag>快照</tag>
        <tag>克隆</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（十一）发送与接收文件系统</title>
    <url>/2021/10/17/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/19/50MaM6.png" alt=""></p>
<span id="more"></span>
<p>通过前面一篇文章，你对快照特性已经很了解了，现在让我们把视线转移到ZFS的另一个明珠上，即它的从一个主机往另一个主机发送和接受整个文件系统的能力。这是非常了不起的功能，我不清楚其他文件系统在不借助第三方工具（比如”dd”和”nc”）是不是可以做到这一点。</p>
<h2 id="ZFS发送"><a href="#ZFS发送" class="headerlink" title="ZFS发送"></a>ZFS发送</h2><p>发送一个ZFS文件系统，意味着对一个数据集做快照，然后发送这个快照。这样确保了在发送数据时始终保持一致，这是ZFS的关键所在。默认情况下，我们将数据发送到一个文件。然后，我们可以将该文件移动到离线备份、另一个存储服务器或者其他任何地方。ZFS发送相对于“dd”的优点是，您不需要使文件系统离线来获取数据。在我看来，这是非常棒的特性。<br>要将文件系统发送到文件，首先必须制作数据集的快照。创建快照后，可以发送快照。这会产生一个输出流，把该输出流必须重定向到一个文件即可。命令如下:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs snapshot tank/test@tuesday</span><br><span class="line"># zfs send tank/test@tuesday &gt; /backup/test-tuesday.img</span><br></pre></td></tr></table></figure><br>现在，你的大脑应该在思考。您可以使用一整套Unix实用程序来操作数据。所以，与其存储原始数据，不如使用“xz”工具压缩它?确实可以这样：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs send tank/test@tuesday | xz &gt; /backup/test-tuesday.img.xz</span><br></pre></td></tr></table></figure><br> 想要加密?你可以使用OpenSSL或GnuPG:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs send tank/test@tuesday | xz | openssl enc -aes-256-cbc -a -salt &gt; /backup/test-tuesday.img.xz.asc</span><br></pre></td></tr></table></figure></p>
<h2 id="ZFS接收"><a href="#ZFS接收" class="headerlink" title="ZFS接收"></a>ZFS接收</h2><p>接收ZFS文件系统是另一方面。在有数据流的地方，可以将数据导入到完整的可写文件系统中。如果不能对文件中的数据进行任何操作，那么将文件系统发送到映像文件就没有多大意义了。</p>
<p>就像“zfs send”对流进行操作一样，“zfs receive”也进行同样的操作。那么，假设我们想要接收“/backup/test-tuesday.img“文件系统。我们可以将它接收到任何存储池，它将创建必要的数据集。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs receive tank/test2 &lt; /backup/test-tuesday.img</span><br></pre></td></tr></table></figure><br>当然，在我们的发送示例中，我压缩并加密了发送的文件系统。所以，为了反转这个过程，我以相反的顺序执行命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># openssl enc -d -aes-256-cbc -a -in /storage/temp/testzone.gz.ssl | unxz | zfs receive tank/test2</span><br></pre></td></tr></table></figure><br> “zfs recv”命令可以作为快捷方式使用。</p>
<h2 id="发送命令与接收命令结合"><a href="#发送命令与接收命令结合" class="headerlink" title="发送命令与接收命令结合"></a>发送命令与接收命令结合</h2><p>“zfs发送”和“zfs接收”都对输入和输出流进行操作。因此，将一个文件系统发送到另一个文件系统是有意义的。当然，我们可以在本地这样做:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs send tank/test@tuesday | zfs receive pool/test</span><br></pre></td></tr></table></figure><br>这是完全可以接受的，但是在同一个存储服务器上保留文件系统的多个副本并没有太大意义。相反，将文件系统发送到远程机器会更有意义。你可以用OpenSSH简单地做到这一点:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs send tank/test@tuesday | ssh user@server.example.com &quot;zfs receive pool/test&quot;</span><br></pre></td></tr></table></figure><br>看看这个命令是多么的简单。您从快照中获取实时的、运行的和一致的数据，并将该数据发送到另一个服务器。这对于离线存储备份来说是史诗级的。在您的ZFS存储服务器上，您将经常运行数据集的快照，然后，启动一个夜间cron作业，您可以使用“zfs receive”将最新的快照“zfs send”到一个离线存储服务器。由于运行的是一个安全、严密的系统，所以需要使用OpenSSL和XZ加密数据，非常简单便捷。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我禁不住再次强调发送和接收ZFS文件系统的简单性。这是使ZFS成为存储市场的有力竞争者的最大的特性之一。利用这个特性结合crontab，就可以使用ZFS发送和接收对数据进行离线备份。您可以发送文件系统而不卸载它们。您可以在接收端更改数据集属性。所有数据都保持一致，您还可以将它与其他Unix工具结合使用（如上文介绍的压缩工具和加密工具等）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/20/zfs-administration-part-xiii-sending-and-receiving-filesystems/">https://pthree.org/2012/12/20/zfs-administration-part-xiii-sending-and-receiving-filesystems/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（十二）ZVOLs</title>
    <url>/2021/10/18/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89ZVOLs/</url>
    <content><![CDATA[<span id="more"></span>
<p>本文主要是讲如何把ZFS当作块设备使用–主要是通过ZFS卷（ZVOLS）。使用ZVOLS还可以享受底层ZFS带来的好处，比如有ZFS的数据清理，压缩，去重等等特性。</p>
<p>ZVOL是作为块设备导出到系统的“ZFS卷”。到目前为止，在处理ZFS文件系统时，除了创建池之外，我们根本没有处理块设备，甚至在挂载数据集时也没有。ZFS的行为更像是用户空间应用程序，而不是文件系统。我的意思是，在GNU/Linux上，当使用文件系统时，您总是在使用块设备，无论它们是完整的磁盘、分区、RAID阵列还是逻辑卷。然而，通过ZFS，我们成功地摆脱了这一切，现在我们开始搞ZVOLs了。</p>
<p>ZVOL是驻留在存储池中的ZFS块设备。这意味着单个块设备可以利用底层RAID阵列，如镜像或RAID- z。它可以利用写时复制的好处，比如快照，也可以利用数据清理、压缩和数据去重功能，还可以利用ZIL和ARC。因为它是一个合法的块设备，你可以用你的ZVOL做一些非常有趣的事情。我们将在这里研究其中的三个：swap、ext4和VM存储。<br>首先，我们需要学习如何创建一个ZVOL。<br>为了创建一个ZVOL，我们需要使用“-V”参数和“zfs create”命令，并给它指定一个大小。例如，如果我想创建一个1GB的ZVOL，我可以用以下命令。注意，在/dev/zvol/tank/和/dev/tank/中存在一些新的符号链接，指向/dev/中的一个新块设备:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create -V 1G tank/disk1</span><br><span class="line"># ls -l /dev/zvol/tank/disk1</span><br><span class="line">lrwxrwxrwx 1 root root 11 Dec 20 22:10 /dev/zvol/tank/disk1 -&gt; ../../zd144</span><br><span class="line"># ls -l /dev/tank/disk1</span><br><span class="line">lrwxrwxrwx 1 root root 8 Dec 20 22:10 /dev/tank/disk1 -&gt; ../zd144</span><br></pre></td></tr></table></figure><br>因为这是一个100%真实的块设备，它的大小是1 GB，我们可以用它做任何其他块设备可以做的事情，并且享受底层ZFS的所有好处。此外，创建一个无论多大的ZVOL都几乎是瞬时的。现在，我可以从文件系统上的一个文件用GNU/Linux创建一个块设备。例如，如果运行ext4，我可以创建一个1GB的文件，然后创建一个块设备，如下所示:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fallocate -l 1G /tmp/file.img</span><br><span class="line"># losetup /dev/loop0 /tmp/file.img</span><br></pre></td></tr></table></figure><br>我现在有了块设备/dev/loop0，它代表我的1GB文件。就像其他块设备一样，我可以格式化它，将它添加到swap等等。但它没有那么优雅，而且有严重的局限性。首先，默认情况下，你只有8个环回设备用来导出块设备，但是您可以更改这个数字。使用ZFS，您可以默认创建2^64个 zvol。另外，它需要在文件系统上预先分配映像。因此，您将管理三层数据:块设备、文件和文件系统上的块。 使用ZVOLs，块设备可以直接从存储池导出，就像任何其他数据集一样。</p>
<p>让我们看看我们可以用这个ZVOL做些什么。</p>
<h2 id="ZVOL上的交换分区"><a href="#ZVOL上的交换分区" class="headerlink" title="ZVOL上的交换分区"></a>ZVOL上的交换分区</h2><p>就我个人而言，我不太喜欢swap（分区）。我知道它是RAM的物理扩展，但是swap只在RAM填满、缓存溢出时使用。如果这种情况经常发生，那么您可能应该考虑获得更多的RAM。swap分区可以充当健康系统的一部分，使RAM专用于内核主动需要的内容。但是，当活动RAM开始溢出到swap分区时，就会出现“the swap of death”，就像磁盘抖动一样，试图跟上内核的要求。因此，根据您的系统和需求，您可能需要也可能不需要交换。</p>
<p>首先，让我们为swap分区创建1 GB的块设备。我们将该数据集称为“tank/swap”，以方便知晓其目的。在我们开始之前，让我们用“free”命令检查一下系统上目前有多少swap:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:      12327288    8637124    3690164          0     175264    1276812</span><br><span class="line">-/+ buffers/cache:    7185048    5142240</span><br><span class="line">Swap:            0          0          0</span><br></pre></td></tr></table></figure><br> 在本例中，我们目前还没有启用任何交换。因此，现在让我们在ZVOL上创建1 GB的swap，并将其添加到内核中:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create -V 1G tank/swap</span><br><span class="line"># mkswap /dev/zvol/tank/swap</span><br><span class="line"># swapon /dev/zvol/tank/swap</span><br><span class="line"># free</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:      12327288    8667492    3659796          0     175268    1276804</span><br><span class="line">-/+ buffers/cache:    7215420    5111868</span><br><span class="line">Swap:      1048572          0    1048572</span><br></pre></td></tr></table></figure><br> 可以看到已经生效了!我们在ZFS上有一个合法的Linux内核swap，很好。与典型的swap设备的情况一样，它们没有挂载点。它们要么是启用的，要么是禁用的，这个swap没有什么不同。</p>
<h2 id="ZVOL上的Ex4"><a href="#ZVOL上的Ex4" class="headerlink" title="ZVOL上的Ex4"></a>ZVOL上的Ex4</h2><p>这听起来可能有些古怪，但您可以将另一个文件系统挂载到ZVOL上。换句话说，您可以有一个ext4格式的ZVOL并挂载到/mnt。您甚至可以对ZVOL进行分区，并在其上放置多个文件系统。让我们来这样试试!<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create -V 100G tank/ext4</span><br><span class="line"># fdisk /dev/tank/ext4</span><br><span class="line">( follow the prompts to create 2 partitions- the first 1 GB in size, the second to fill the rest )</span><br><span class="line"># fdisk -l /dev/tank/ext4</span><br><span class="line"></span><br><span class="line">Disk /dev/tank/ext4: 107.4 GB, 107374182400 bytes</span><br><span class="line">16 heads, 63 sectors/track, 208050 cylinders, total 209715200 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 8192 bytes</span><br><span class="line">I/O size (minimum/optimal): 8192 bytes / 8192 bytes</span><br><span class="line">Disk identifier: 0x000a0d54</span><br><span class="line"></span><br><span class="line">          Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/tank/ext4p1            2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/tank/ext4p2         2099200   209715199   103808000   83  Linux</span><br></pre></td></tr></table></figure><br>让我们创建一些文件系统，并挂载它们:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mkfs.ext4 /dev/zd0p1</span><br><span class="line"># mkfs.ext4 /dev/zd0p2</span><br><span class="line"># mkdir /mnt/zd0p&#123;1,2&#125;</span><br><span class="line"># mount /dev/zd0p1 /mnt/zd0p1</span><br><span class="line"># mount /dev/zd0p2 /mnt/zd0p2</span><br></pre></td></tr></table></figure><br>在ZVOL上启用压缩，复制一些数据，然后做快照:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set compression=lzjb pool/ext4</span><br><span class="line"># tar -cf /mnt/zd0p1/files.tar /etc/</span><br><span class="line"># tar -cf /mnt/zd0p2/files.tar /etc /var/log/</span><br><span class="line"># zfs snapshot tank/ext4@001</span><br></pre></td></tr></table></figure><br>您可能没有注意到，但是您刚刚启用了透明压缩，并对ext4文件系统做了快照。这是ext4本身无法完成的两件事。您还可以获得ext4通常无法提供的ZFS的所有好处。所以，现在你可以定期快照你的数据，可以执行在线数据清理，并把它发送到离线备份。最重要的是，您的数据是一致的。</p>
<h2 id="将ZVOL作为VM的后端存储"><a href="#将ZVOL作为VM的后端存储" class="headerlink" title="将ZVOL作为VM的后端存储"></a>将ZVOL作为VM的后端存储</h2><p> 最后，您可以使用这些块设备作为虚拟机的后端存储。创建逻辑卷块设备作为虚拟机存储的后端是很常见的。让块设备对Qemu可用之后，将块设备附加到虚拟机，从它的角度来看，根据设置，您将拥有“/dev/vda”或“/dev/sda”。</p>
<p>如果使用libvirt，则会有一个/etc/libvirt/qemu/vm.xml文件。在该文件中，可以有以下内容，其中“/dev/zd0”是ZVOL块设备:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;disk type=&#x27;block&#x27; device=&#x27;disk&#x27;&gt;</span><br><span class="line">  &lt;driver name=&#x27;qemu&#x27; type=&#x27;raw&#x27; cache=&#x27;none&#x27;/&gt;</span><br><span class="line">  &lt;source dev=&#x27;/dev/zd0&#x27;/&gt;</span><br><span class="line">  &lt;target dev=&#x27;vda&#x27; bus=&#x27;virtio&#x27;/&gt;</span><br><span class="line">  &lt;alias name=&#x27;virtio-disk0&#x27;/&gt;</span><br><span class="line">  &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x05&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">&lt;/disk&gt;</span><br></pre></td></tr></table></figure><br>此时，您的VM将获得底层的所有ZFS优势，如快照、压缩、重复数据删除、数据完整性、冗余等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ZVOLs是一种很好的方法，可以在利用所有底层ZFS特性的同时快速使用块设备。使用ZVOLs作为VM备份存储特别有吸引力。但是，我应该注意，在使用zvol时，不能在集群之间复制它们。 ZFS不是集群文件系统。如果希望跨集群进行数据复制，那么不应该使用ZVOLs，而应该使用文件映像作为虚拟机备份存储。除此之外，无论您的ZVOL中驻留了什么数据，您可以从ZFS中获得到目前为止我们一直在博客中讨论的所有的好处。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/21/zfs-administration-part-xiv-zvols/">https://pthree.org/2012/12/21/zfs-administration-part-xiv-zvols/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（十三）共享数据集</title>
    <url>/2021/10/19/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>本文继续GNU/Linux ZFS的管理系列，主要讨论共享数据集（或者叫共享文件系统）。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p> 我一直在努力让这些ZFS帖子尽可能地与操作系统无关。尽管他们倾向于Linux内核，但您应该能够将其中的大部分内容带到BSD或任何Solaris衍生产品中，如OpenIndiana或Nexenta。然而，在这篇文章中，它将是针对linux内核的，甚至是针对Ubuntu和Debian的。原因是在写这篇文章的时候iSCSI支持还没有被编译到Linux上的ZFS中，但是通过NFS和SMB共享已经支持了。此外，本文中通过NFS和SMB共享的实现细节将在是针对Debian和Ubuntu的。因此，如果你使用的是Fedora、openSUSE、Gentoo、Arch等，那么你可能需要进行调整相应的参数。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p> 您可能会问，为什么要使用ZFS特定的数据集共享，而不是使用标准软件的“可靠的”方法。原因很简单。当系统启动并完成它的服务初始化过程(通常通过执行/etc/init.d/中找到的shell脚本)时，它有一个方法来判断哪个服务先启动。笼统来说，启动过程大致是首先安装文件系统，然后启用网络，最后才启动服务。其中一些是绑定在一起的，比如NFS导出，它需要挂载文件系统、安装防火墙、启动网络和运行NFS守护进程。但是，当文件系统没有安装时，会发生什么呢?如果目录仍然可以访问，则将通过NFS导出它，应用程序可以开始将数据导出。这可能会导致各种各样的问题，比如数据不一致。因此，管理员会进行检查，比如只导出挂载点中的嵌套目录，如果文件系统挂载失败，那么嵌套目录就不会被导出。这些都是聪明的技巧，但肯定不优雅。</p>
<p>当将导出直接绑定到文件系统中时，您可以很好地解决这个问题，ZFS就是这么做的。例如，在ZFS中，您可以通过NFS共享特定的数据集。但是，如果数据集没有挂载，则导出对应用程序不可用，NFS客户端将会阻塞。因为网络共享是文件系统固有的，所以不需要担心数据不一致，也不需要愚蠢的检查工具或脚本。因此，Oracle的ZFS能够通过NFS、SMB (CIFS或Samba)和iSCSI共享数据集。Linux上的ZFS目前只支持NFS和SMB，即将支持iSCSI。</p>
<p>在每种情况下，您仍然必须安装必要的守护程序以使共享可用。例如，如果您希望通过NFS共享数据集，那么您需要安装NFS服务器软件，并且该软件必须正在运行。然后，您所需要做的就是打开数据集上的共享NFS开关，它将立即可用。</p>
<h2 id="通过NFS共享"><a href="#通过NFS共享" class="headerlink" title="通过NFS共享"></a>通过NFS共享</h2><p>要通过NFS共享数据集，首先需要确保NFS守护进程正在运行。在Debian和Ubuntu上，这是“nfs-kernel-server”包。此外，在Debian和Ubuntu中，NFS守护进程不会启动，除非在/etc/exports文件中有导出。因此，您有两个选项:您可以创建一个虚拟的导出，仅对localhost可用，或者您可以编辑初始化脚本以启动，而不检查当前的导出。我更喜欢前者。让我们来设置一下:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo aptitude install -R nfs-kernel-server</span><br><span class="line">$ echo &#x27;/mnt localhost(ro)&#x27; &gt;&gt; /etc/exports</span><br><span class="line">$ sudo /etc/init.d/nfs-kernel-server start</span><br><span class="line">$ showmount -e hostname.example.com</span><br><span class="line">Export list for hostname.example.com:</span><br><span class="line">/mnt localhost</span><br></pre></td></tr></table></figure><br> 在NFS守护进程运行之后，我们现在可以开始共享ZFS数据集了。我假设您已经创建了数据集，它已经挂载，并且您已经准备好开始向它提交数据了。您会注意到在zfs(8)手册中，对于“sharenfs”属性，它可以是“on”、“off”或“opts”，其中“opts”是有效的NFS导出选项。所以，如果我想共享我的“pool/srv”数据集，并将它挂载到“/srv”到10.80.86.0/24网络，我可以做一些像这样的事情:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set sharenfs=&quot;rw=@10.80.86.0/24&quot; pool/srv</span><br><span class="line"># zfs share pool/srv</span><br><span class="line"># showmount -e hostname.example.com</span><br><span class="line">Export list for hostname.example.com:</span><br><span class="line">/srv 10.80.86.0/24</span><br><span class="line">/mnt localhost</span><br></pre></td></tr></table></figure><br>如果您希望在启动时共享ZFS数据集，那么您需要安装/etc/default/zfs配置文件。如果你使用Ubuntu PPA，默认情况下你会安装它。如果从源代码进行编译，则不会提供此选项。这是那个文件的内容。我强调了两行，如果您想要启用NFS共享，那应该修改这两行。默认的是“不”:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /etc/default/zfs</span><br><span class="line"># /etc/default/zfs</span><br><span class="line">#</span><br><span class="line"># Instead of changing these default ZFS options, Debian systems should install</span><br><span class="line"># the zfs-mount package, and Ubuntu systems should install the zfs-mountall</span><br><span class="line"># package. The debian-zfs and ubuntu-zfs metapackages ensure a correct system</span><br><span class="line"># configuration.</span><br><span class="line">#</span><br><span class="line"># If the system runs parallel init jobs, like upstart or systemd, then the</span><br><span class="line"># `zfs mount -a` command races in a way that causes sporadic mount failures.</span><br><span class="line"></span><br><span class="line"># Automatically run `zfs mount -a` at system start. Disabled by default.</span><br><span class="line">ZFS_MOUNT=&#x27;yes&#x27;</span><br><span class="line">ZFS_UNMOUNT=&#x27;no&#x27;</span><br><span class="line"></span><br><span class="line"># Automatically run `zfs share -a` at system start. Disabled by default.</span><br><span class="line"># Requires nfsd and/or smbd. Incompletely implemented for Linux.</span><br><span class="line">ZFS_SHARE=&#x27;yes&#x27;</span><br><span class="line">ZFS_UNSHARE=&#x27;no&#x27;</span><br></pre></td></tr></table></figure></p>
<p>正如注释中提到的，运行并行初始化系统会给ZFS带来问题。这是我最近遇到的问题，因为我的/var/log/和/var/cache/ dataset在引导时没有挂载。为了解决这个问题，并运行串行化的启动，从而确保所有操作都按照正确的顺序执行，您需要访问一个文件:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># touch /etc/init.d/.legacy-bootordering</span><br></pre></td></tr></table></figure><br>这将增加您的启动时间，但考虑到我的系统每次运行几个月，我并不担心这将为我的启动增加5秒时间，在/etc/init.d/rc脚本中设置“CONCURRENCY=none”。<br> 现在，您应该能够从NFS客户端挂载NFS导出:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(client)# mount -t nfs hostname.example.com:/srv /mnt</span><br></pre></td></tr></table></figure></p>
<h2 id="通过SMB共享"><a href="#通过SMB共享" class="headerlink" title="通过SMB共享"></a>通过SMB共享</h2><p> 目前，通过SMB共享遇到些问题，请参阅我在Github上报告的<a href="https://github.com/openzfs/zfs/issues/1170">bug #1170</a>。</p>
<p>与NFS一样，要通过SMB/CIFS共享ZFS数据集，需要安装并运行守护进程。 最近Samba发布了版本4，我们将继续使用Samba包的版本3，直到版本4稳定下来（注意：这篇文章原文发表于2012年，所以此时最新的稳定版本肯定不是版本3了）。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aptitude install -R aptitude install samba samba-client samba-doc samba-tools samba-doc-pdf</span><br><span class="line"># ps -ef | grep smb</span><br><span class="line">root     22413     1  0 09:05 ?        00:00:00 /usr/sbin/smbd -D</span><br><span class="line">root     22423 22413  0 09:05 ?        00:00:00 /usr/sbin/smbd -D</span><br><span class="line">root     22451 21308  0 09:06 pts/1    00:00:00 grep smb</span><br></pre></td></tr></table></figure><br>此时，我们需要做的就是共享数据集，并验证它是否已被共享。同样值得注意的是，微软Windows机器不像Unix那样区分大小写。因此，如果您在异构环境中，禁用ZFS数据集上的区分大小写可能是值得的。只能在创建时设置此值。因此，您可能希望在创建该数据集时发出以下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create -o casesensitivity=mixed pool/srv</span><br></pre></td></tr></table></figure><br>现在您可以继续配置数据集的其余部分:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set sharesmb=on pool/srv</span><br><span class="line"># zfs share pool/srv</span><br><span class="line"># smbclient -U guest -N -L localhost</span><br><span class="line">Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.6.6]</span><br><span class="line"></span><br><span class="line">        Sharename       Type      Comment</span><br><span class="line">        ---------       ----      -------</span><br><span class="line">        print$          Disk      Printer Drivers</span><br><span class="line">        sysvol          Disk      </span><br><span class="line">        netlogon        Disk      </span><br><span class="line">        IPC$            IPC       IPC Service (eightyeight server)</span><br><span class="line">        Canon-imageRunner-3300 Printer   Canon imageRunner 3300</span><br><span class="line">        HP-Color-LaserJet-3600 Printer   HP Color LaserJet 3600</span><br><span class="line">        salesprinter    Printer   Canon ImageClass MF7460</span><br><span class="line">        pool_srv        Disk      Comment: /srv</span><br><span class="line">Domain=[WORKGROUP] OS=[Unix] Server=[Samba 3.6.6]</span><br><span class="line"></span><br><span class="line">        Server               Comment</span><br><span class="line">        ---------            -------</span><br><span class="line">        EIGHTYEIGHT          eightyeight server</span><br><span class="line"></span><br><span class="line">        Workgroup            Master</span><br><span class="line">        ---------            -------</span><br><span class="line">        WORKGROUP            EIGHTYEIGHT</span><br></pre></td></tr></table></figure><br>您可以看到，在这个环境中(我的工作站主机名是’ eightyeight  ‘)，有一些打印机被共享，还有一些磁盘。我强调了我们在输出中共享的磁盘，以验证它是否正常工作。因此，我们应该能够将该共享挂载为CIFS挂载，并访问数据:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aptitude install -R cifs-utils</span><br><span class="line"># mount -t cifs -o username=USERNAME //localhost/srv /mnt</span><br><span class="line"># ls /mnt</span><br><span class="line">foo</span><br></pre></td></tr></table></figure></p>
<h2 id="通过iSCSI共享"><a href="#通过iSCSI共享" class="headerlink" title="通过iSCSI共享"></a>通过iSCSI共享</h2><p>不幸的是，Linux上的ZFS还不支持通过iSCSI共享ZFS数据集。然而，它在上游的Illumos源代码中是可用的，并且正在努力使它在GNU/Linux中工作。与SMB和NFS一样，您将需要安装并运行iSCSI守护进程。当启用支持后，我将通过这篇文章演示如何访问作为ZFS数据集的iSCSI目标。在此期间，您可以做如下操作:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># aptitude install -R openiscsi</span><br><span class="line"># zfs set shareiscsi=on pool/srv</span><br></pre></td></tr></table></figure><br> 然后从iSCSI客户端，您将访问目标，格式化它，挂载它，并开始处理数据。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2012/12/31/zfs-administration-part-xv-iscsi-nfs-and-samba/">https://pthree.org/2012/12/31/zfs-administration-part-xv-iscsi-nfs-and-samba/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（十四）获取设置ZFS数据集属性</title>
    <url>/2021/10/20/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%E8%8E%B7%E5%8F%96%E8%AE%BE%E7%BD%AEZFS%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<span id="more"></span>
<p>本文介绍如何ZFS文件系统（或者叫ZFS数据集）的各种属性。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>与Zpool属性一样，数据集也包含可以更改的属性。因为数据集是实际存储数据的地方，所以有比存储池多得多的属性。此外，属性可以从父数据集继承。同样，并不是每个属性都是可调的。许多是只读的。但是，这再次使我们能够根据存储需求优化文件系统。ZFS数据集的另一个方面是能够设置您自己的自定义属性。这些属性被称为“用户属性”，不同于“native 属性”。</p>
<p>因为有太多的属性，所以我决定把管理放在“显眼的地方”，并把属性和一些最后的想法放在文章的最后。</p>
<h2 id="获取并设置属性"><a href="#获取并设置属性" class="headerlink" title="获取并设置属性"></a>获取并设置属性</h2><p>与获取和设置存储池属性一样，也有一些方法可以获取数据集属性——您可以一次获取所有属性，只获取一个属性，或多个属性，以逗号分隔。例如，假设我只想获得数据集的压缩比。可以用以下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs get compressratio tank/test</span><br><span class="line">NAME       PROPERTY       VALUE  SOURCE</span><br><span class="line">tank/test  compressratio  1.00x  -</span><br></pre></td></tr></table></figure><br>如果想要获得多个设置，比如数据集使用的磁盘数量，以及可用磁盘的数量，以及压缩比，可以用以下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs get used,available,compressratio tank/test</span><br><span class="line">tank/test  used                  1.00G                  -</span><br><span class="line">tank/test  available             975M                   -</span><br><span class="line">tank/test  compressratio         1.00x                  -</span><br></pre></td></tr></table></figure><br>当然，如果想获得所有可用的设置，可以运行:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs get all tank/test</span><br><span class="line">NAME       PROPERTY              VALUE                  SOURCE</span><br><span class="line">tank/test  type                  filesystem             -</span><br><span class="line">tank/test  creation              Tue Jan  1  6:07 2013  -</span><br><span class="line">tank/test  used                  1.00G                  -</span><br><span class="line">tank/test  available             975M                   -</span><br><span class="line">tank/test  referenced            1.00G                  -</span><br><span class="line">tank/test  compressratio         1.00x                  -</span><br><span class="line">tank/test  mounted               yes                    -</span><br><span class="line">tank/test  quota                 none                   default</span><br><span class="line">tank/test  reservation           none                   default</span><br><span class="line">tank/test  recordsize            128K                   default</span><br><span class="line">tank/test  mountpoint            /tank/test             default</span><br><span class="line">tank/test  sharenfs              off                    default</span><br><span class="line">tank/test  checksum              on                     default</span><br><span class="line">tank/test  compression           lzjb                   inherited from tank</span><br><span class="line">tank/test  atime                 on                     default</span><br><span class="line">tank/test  devices               on                     default</span><br><span class="line">tank/test  exec                  on                     default</span><br><span class="line">tank/test  setuid                on                     default</span><br><span class="line">tank/test  readonly              off                    default</span><br><span class="line">tank/test  zoned                 off                    default</span><br><span class="line">tank/test  snapdir               hidden                 default</span><br><span class="line">tank/test  aclinherit            restricted             default</span><br><span class="line">tank/test  canmount              on                     default</span><br><span class="line">tank/test  xattr                 on                     default</span><br><span class="line">tank/test  copies                1                      default</span><br><span class="line">tank/test  version               5                      -</span><br><span class="line">tank/test  utf8only              off                    -</span><br><span class="line">tank/test  normalization         none                   -</span><br><span class="line">tank/test  casesensitivity       sensitive              -</span><br><span class="line">tank/test  vscan                 off                    default</span><br><span class="line">tank/test  nbmand                off                    default</span><br><span class="line">tank/test  sharesmb              off                    default</span><br><span class="line">tank/test  refquota              none                   default</span><br><span class="line">tank/test  refreservation        none                   default</span><br><span class="line">tank/test  primarycache          all                    default</span><br><span class="line">tank/test  secondarycache        all                    default</span><br><span class="line">tank/test  usedbysnapshots       0                      -</span><br><span class="line">tank/test  usedbydataset         1.00G                  -</span><br><span class="line">tank/test  usedbychildren        0                      -</span><br><span class="line">tank/test  usedbyrefreservation  0                      -</span><br><span class="line">tank/test  logbias               latency                default</span><br><span class="line">tank/test  dedup                 off                    default</span><br><span class="line">tank/test  mlslabel              none                   default</span><br><span class="line">tank/test  sync                  standard               default</span><br><span class="line">tank/test  refcompressratio      1.00x                  -</span><br><span class="line">tank/test  written               0                      -</span><br></pre></td></tr></table></figure></p>
<h2 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h2><p>正如您可能在上面的输出中注意到的，属性可以从它们的父类继承。在这种情况下，我将存储池文件系统“tank”上的压缩算法设置为“lzjb”(“tank”不仅仅是一个存储池—它是一个有效的ZFS数据集)。因此，在“tank”数据集下创建的任何数据集都将继承该属性。让我们创建一个嵌套数据集，看看它是如何发挥作用的:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create -o compression=gzip tank/test/one</span><br><span class="line"># zfs get -r compression tank</span><br><span class="line">NAME           PROPERTY     VALUE     SOURCE</span><br><span class="line">tank           compression  lzjb      local</span><br><span class="line">tank/test      compression  lzjb      inherited from tank</span><br><span class="line">tank/test/one  compression  gzip      local</span><br></pre></td></tr></table></figure><br>注意，”tank”和”tank/test”数据集使用”lzjb”压缩算法，其中”tank/test”从它的父”tank”继承了它。而对于“tank/test/one”数据集，我们选择了不同的压缩算法。现在让我们从”tank”继承父压缩算法，看看”tank/test/one”会发生什么:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs inherit compression tank/test/one</span><br><span class="line"># zfs get -r compression tank</span><br><span class="line">NAME           PROPERTY     VALUE     SOURCE</span><br><span class="line">tank           compression  lzjb      local</span><br><span class="line">tank/test      compression  lzjb      inherited from tank</span><br><span class="line">tank/test/one  compression  lzjb      inherited from tank</span><br></pre></td></tr></table></figure><br>现在“zfs inherit”命令也支持递归。我可以将”tank”数据集设置为”gzip”，并递归地应用该属性到所有的子数据集:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set compression=gzip tank</span><br><span class="line"># zfs inherit -r compression tank/test</span><br><span class="line"># zfs get -r compression tank</span><br><span class="line">NAME           PROPERTY     VALUE     SOURCE</span><br><span class="line">tank           compression  gzip      local</span><br><span class="line">tank/test      compression  gzip      inherited from tank</span><br><span class="line">tank/test/one  compression  gzip      inherited from tank</span><br></pre></td></tr></table></figure><br>使用“-r”开关时要非常小心。假设你快速输入命令，并给出“tank”数据集作为参数，而不是“tank/test”:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs inherit -r compression tank</span><br><span class="line"># zfs get -r compression tank</span><br><span class="line">NAME           PROPERTY     VALUE     SOURCE</span><br><span class="line">tank           compression  off       default</span><br><span class="line">tank/test      compression  off       default</span><br><span class="line">tank/test/one  compression  off       default</span><br></pre></td></tr></table></figure><br>发生了什么事?所有的压缩算法都被重置为默认值“off”。因此，使用“zfs inherit”命令的“-r”递归参数要非常小心，因为这会使数据集的参数都变成默认值，并且递归应用到其所有的子数据集，并且不仅适用于数据集，还包括卷和快照。</p>
<h2 id="用户数据集属性"><a href="#用户数据集属性" class="headerlink" title="用户数据集属性"></a>用户数据集属性</h2><p>了解了继承之后，就可以理解如何在数据集中设置自定义用户属性了。用户属性的目标是为特定的ZFS应用程序设计的，以利用这些设置。例如，poudriere是FreeBSD的一个工具，用于测试包的生产，并批量构建FreeBSD包。如果使用ZFS与FreeBSD，你可以为poudriere创建一个数据集，然后为它创建一些自定义属性。<br>自定义用户数据集属性对ZFS性能没有影响。将它们仅仅看作管理员和开发人员的“注释”。用户属性必须在属性名中使用冒号”:”以区别于native数据集属性。只能包含小写字母、数字、“:”、“-”、“。”和“_”。它们最多可以是256个字符，并且不能以破折号“-”开头。</p>
<p>要创建自定义属性，只需使用“module:property”语法。这不是ZFS强制执行的，但可能是最简洁明了的方法:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set poudriere:type=ports tank/test/one</span><br><span class="line"># zfs set poudriere:name=my_ports_tree tank/test/one</span><br><span class="line"># zfs get all tank/test/one | grep poudriere</span><br><span class="line">tank/test/one  poudriere:name        my_ports_tree          local</span><br><span class="line">tank/test/one  poudriere:type        ports                  local</span><br></pre></td></tr></table></figure><br>我不知道从ZFS文件系统中删除用户属性的方法。因此，如果它困扰您，并使您的属性列表变得混乱，那么删除用户属性的唯一方法是使用您想要的属性创建另一个数据集，复制数据，然后销毁旧的杂乱的数据集。当然，您也可以使用“zfs inherit”继承用户属性。</p>
<p> 说了这么多，让我们来看看原生属性。</p>
<h2 id="ZFS原生数据集属性"><a href="#ZFS原生数据集属性" class="headerlink" title="ZFS原生数据集属性"></a>ZFS原生数据集属性</h2><ul>
<li>aclinherit：控制在创建文件和目录时如何继承ACL项。目前，从0.6.0-rc13版本开始，acl在Linux上的ZFS中不起作用。默认设置是“限制”。此属性的有效值为:<br> （1）discard：不继承任何ACL属性<br> （2）noallow：仅继承指定“deny”权限的ACL项<br> （3）restricted：当继承ACL条目时，去掉“write_acl”和“write_owner”权限<br> （4）passthrough：继承所有可继承的ACL表项，不做任何修改<br> （5）passthrough-x：含义与passthrough相同，不过只有在文件创建模式也要求执行位的情况下，owner@, group@, and everyone@ ACE才会继承执行权限</li>
<li>aclmode：使用“chmod”命令控制如何修改ACL。”groupmask”为默认值，用于减少用户或组的权限。权限被减少，因此它们不大于组权限位，除非它是与文件或目录的所有者具有相同UID的用户条目。有效值为“discard”、“groupmask”和“passthrough”。</li>
<li>acltype：控制是否启用ACL以及如果启用，将使用何种类型的ACL。当文件系统将acltype属性设置为noacl(默认值)时，将禁用acl。将acltype属性设置为posixacl表示使用Posix ACLs。Posix ACLs是特定于Linux的，在其他平台上不起作用。Posix ACLs存储为xattr，因此不会覆盖任何可能设置的现有ZFS/NFSv4 ACLs。目前Linux只支持posixacls。</li>
<li>atime：控制在读取文件时是否更新文件的访问时间。默认是“on”。有效值为“on”和“off”。</li>
<li>available：只读属性，显示该数据集及其所有子数据集的可用空间，假设池上没有其他活动。可以通过它的缩写名“avail”来引用。可用性可能受到许多因素的限制，包括存储池中的物理空间、配额、保留和池中的其他数据集。</li>
<li>canmount：当使用“zfs mount”命令时，控制文件系统是否能够被挂载。默认是“on”。有效值为“on”、“off”或“noauto”。当设置了noauto选项时，数据集只能显式地挂载和卸载。当创建或导入数据集时，数据集不会自动挂载，也不会通过“zfs mount”命令挂载或通过“zfs unmount”命令卸载。此属性不会被继承。</li>
<li>casesensitivity：指定文件系统使用的文件名匹配算法是区分大小写、不区分大小写还是允许两种匹配方式的组合。默认值为“sensitive”。取值为“sensitive”、“insensitive”和“mixed”。在部署Unix POSIX和CIFS文件名的异构环境中，使用“mixed”值将是有益的。只能在创建数据集时设置。</li>
<li>checksum： 控制用于验证数据完整性的checksum。默认值是on，它会自动选择合适的算法。目前，该算法是“fletcher2”。合法取值为on、off、fletcher2、fletcher4或sha256。更改此属性只会影响新写入的数据，并且不会追溯应用。</li>
<li>clones：快照数据集只读属性。以逗号分隔的列表展示此快照的克隆数据集。如果该属性不为空，则不能销毁该快照(即使使用”-r”或”-f”选项也不能)，需要先销毁克隆。</li>
<li>compression：控制此数据集的压缩算法。默认设置是“关闭”。有效值为on、off、lzjb、gzip、gzip- n、zle。“lzjb”算法为速度进行了优化，同时提供了良好的压缩比。“on”的设置默认为“lzjb”。建议您使用“lzjb”、“gzip”、“gzip-N”或“zle”而不是“on”，因为ZFS开发人员或包维护人员可能会更改“on”使用的算法。gzip压缩算法使用与“gzip”命令相同的压缩。您可以使用“gzip-N”指定gzip级别，其中“N”是1到9的有效数字。“zle”压缩的速度非常快。更改此属性只会影响新写入的数据，并且不会追溯应用。</li>
<li>compressratio：只读属性，显示在“compression”属性上设置的压缩算法所实现的压缩比。用乘数表示。不考虑快照;看到“refcompressratio”。默认情况下不启用压缩。</li>
<li>copies：控制要存储在此数据集中的副本数量。默认值为1。取值为1、2、3。这些副本是在池提供的任何冗余之外的。如果可能，副本存储在不同的磁盘上。多个副本所使用的空间将由关联的文件和数据集承担。更改此属性只会影响新写入的数据，并不能追溯应用。</li>
<li>creation：只读属性，显示创建数据集的时间。</li>
<li>defer_destroy：快照只读属性。如果使用”zfs destroy -d”命令将快照标记为延迟销毁，则此属性为”on”，否则，属性为“off”。</li>
<li>dedup：控制数据去重是否对该数据集有效。默认设置是“关闭”。取值为off、on、verify、sha256[，verify]。数据去重的校验和默认为SHA256。当启用“dedup”属性时，它将覆盖“checksum”属性。如果属性设置为“verify”，那么如果两个块具有相同的校验和，ZFS将逐个字节地与现有块进行比较，以确保两个块是相同的。更改此属性只会影响新写入的数据。在数据集中启用重复数据删除功能，将对存储池中的所有数据进行重复数据删除。</li>
<li>devices： 控制是否可以在此文件系统上打开设备节点。默认值为“on”。有效值为“on”和“off”。</li>
<li>exec：控制进程是否可以从该文件系统中执行。默认值为“on”。有效值为“on”和“off”。</li>
<li>groupquota@<group>：限制指定组所使用的空间量。组空间消耗由“userquota@<user>”属性标识。默认值为none。有效值为“none”或者以字节为单位的大小。</li>
<li>groupsused@<group>： 只读属性，显示指定组在此数据集中所使用的空间量。每个文件的组都占用空间，如“ls -l”所示。有关更多信息，请参阅userused@<user>属性。</li>
<li>logbias：控制如何使用SLOG(如果存在的话)。为ZFS提供关于如何处理同步请求的提示。默认值是“latency”，如果存在，将在池中使用SLOG。另一个有效值是“吞吐量”，它不会在同步请求上使用SLOG，而是直接进入磁盘。</li>
<li>mlslabel：mlslabel属性是一个敏感标签，用于确定是否可以将数据集挂载到启用了受信任扩展的系统上的某个区域中。默认值为none。有效值是Solaris Zones标签或“none”。注意，Zones是Solaris的特性，与GNU/Linux无关。然而，这可能是将来可以用SELinux和Linux容器实现的。</li>
<li>mounted： 只读属性，显示该数据集是否已挂载。此属性将显示“yes”或“no”。</li>
<li>mountpoint：控制用于此文件系统的挂载点。默认值为“<pool>/<dataset>”。有效值是文件系统上的绝对路径、”none”或”legacy”。当“挂载点”属性更改时，新的目标必须不包含任何子文件。数据集将被卸载并重新挂载到新的目标。</li>
<li>nbmand： 控制文件系统是否应该用非阻塞的强制锁来挂载。用于CIFS客户端。默认值为“on”。有效值为“on”和“off”。只有在数据集卸载然后重新安装后，更改属性才会生效。</li>
<li>normalization： 指示当比较两个文件名时，文件系统是否应该对文件名执行unicode标准化，以及应该使用哪种标准化算法。默认值为none。取值为“formC”、“formD”、“formKC”、“formKD”。在创建数据集之后，不能更改此属性。</li>
<li>origin：克隆或卷的只读属性，显示创建克隆的快照。</li>
<li>primarycache：控制在主缓存(ARC)中缓存的内容。如果此属性设置为“all”，则会缓存用户数据和元数据。如果设置为“none”，则两者都不会被缓存。如果设置为”metadata”，则只缓存元数据。默认设置是“所有”。</li>
<li>quota： 限制数据集及其后代可以消耗的空间量。此属性强制对所使用的空间数量进行硬性限制。没有软限制。这包括后代所使用的所有空间，包括文件系统和快照。在已经拥有配额的数据集的后代上设置配额不会覆盖祖先的配额，而是施加一个额外的限制。不能对卷设置配额，因为volsize属性充当隐式配额。默认值为none。有效值为字节或none。</li>
<li>readonly： 控制是否可以修改此数据集。默认值是off。有效值为“on”和“off”。这个属性也可以通过它的缩写列名“rdonly”来引用。</li>
<li>recordsize：指定文件系统中文件的建议块大小。此属性专为访问固定大小记录中的文件的数据库工作负载而设计。ZFS根据为典型访问模式优化的内部算法自动调整块大小。指定的大小必须是2的乘方，大于等于512且小于等于128KB。改变文件系统的记录大小只影响之后创建的文件，现有文件不受影响。该属性也可以通过其缩短的列名“recsize”来表示。</li>
<li>refcompressratio：只读属性，显示由“引用”属性中占用的空间所实现的压缩比。</li>
<li>referenced：只读属性，显示数据集可以访问的数据量。最初，这个数字将与“used”属性相同。但是，当创建快照并修改数据时，这些数字就会出现分歧。这个属性可以通过它的缩写名称“refer”来表示。</li>
<li>refquota： 限制数据集可以消耗的空间量。此属性强制对所使用的空间数量进行硬性限制。该硬限制不包括派生文件系统和快照所使用的空间。默认值为none。有效值为“none”，大小以字节为单位</li>
<li>refreservation： 保证给数据集(不包括其派生数据集)的最小空间量。当使用的空间量低于此值时，数据集被视为占用了由rereservation指定的空间量。默认值为none。有效值为“none”和字节大小。该属性也可以通过其缩短的列名“refreserv”来引用。</li>
<li>reservation：保证给数据集及其后代的最小空间量。当使用的空间量低于此值时，数据集被视为占用了其预留所指定的空间量。保留在父数据集所使用的空间中计算，并计入父数据集的配额和保留。该属性也可以通过其缩短的列名reserve来引用。默认值为none。有效值为“none”和字节大小。</li>
<li>secondarycache：控制在辅助缓存(L2ARC)中缓存的内容。如果此属性设置为“all”，则会缓存用户数据和元数据。如果此属性设置为“none”，则不会缓存用户数据或元数据。如果此属性设置为“metadata”，则只缓存元数据。系统默认值为all。</li>
<li>setuid：控制文件系统中是否会标记setuid 位。</li>
<li>shareiscsi：指示是否将ZFS卷导出为iSCSI目标。目前，在Linux上的ZFS中还没有实现这一功能，但正在等待实现。有效值为“on”、“off”和“type=disk”。还可能支持其他磁盘类型。默认值为off。</li>
<li>sharenfs：指示是否将ZFS数据集导出为NFS导出，以及使用了哪些选项。默认值为“off”。有效值为”on”， “off”和有效的NFS导出选项列表。如果设置为“on”，则可以使用“zfs share”命令共享导出，并使用“zfs unshare”命令取消共享。在使用导出之前，主机上必须运行NFS守护进程。Debian和Ubuntu在启动守护进程之前，需要在/etc/exports文件中有一个有效的导出文件。</li>
<li>sharesmb： 是否将ZFS数据集导出为SMB共享。默认值为“off”。有效值为“on”和“off”。它将需要一个正在运行的Samba守护进程，就像NFS一样，并将使用“zfs share”和“zfs unshare”命令共享和取消共享</li>
<li>snapdir： 控制是否”.zfs”目录在文件系统的根目录中隐藏或可见。默认值为“hidden”。有效值是”hidden”和”visible”。即使设置为”hidden”值，仍然可以将目录cd到”.zfs”目录下，可以访问共享和快照。</li>
<li>sync：控制同步请求的行为(例如fsync, O_DSYNC)。默认值为“Default”，这是POSIX行为，以确保所有同步请求被写入稳定存储，所有设备被刷新，以确保数据不被设备控制器缓存。取值为default、always和disabled。“always”的值导致在系统调用返回之前写入和刷新每个文件系统事务。“disabled”的值</li>
<li>type：只读属性，显示文件系统的类型，可能是“数据集”、“卷”或者“快照”。</li>
<li>used：只读属性，显示此数据集及其所有子数据集所消耗的空间量。创建快照时，空间最初是在父数据集和它的快照之间共享的。当数据集中的数据被修改时，之前共享的空间对快照来说是唯一的，并且只在该快照的“used”属性中计算。此外，删除快照可以释放其他快照所独有的空间。</li>
<li>usedbychildren：只读属性，显示此数据集的子数据集所使用的空间量，如果销毁所有子数据集，则释放该空间。</li>
<li>usedbydataset：只读属性，显示此数据集本身使用的空间量。如果销毁该数据集，则释放该数据集所占用的空间。</li>
<li>usedbyrefreservation：只读属性，显示此数据集上的预留所使用的空间量，如果删除预留，将释放这些空间。</li>
<li>usedbysnapshots： 只读属性，显示此数据集的快照所消耗的空间量。换句话说，这是快照所独有的数据。注意，这不是每个快照“used”属性的总和，因为数据可以跨快照共享。</li>
<li>userquota@<user>：限制指定用户所使用的空间量。与refquota属性类似，userquota空间计算不包括派生数据集(如快照和克隆)使用的空间。强制执行用户配额可能会延迟几秒钟。这种延迟意味着用户可能在系统注意到他们已经超过配额并开始使用EDQUOT错误消息拒绝额外的写入之前就已经超过了配额。这个属性在卷上、版本4之前的文件系统上或版本15之前的文件池上不可用。默认值为none。有效值为“none”和字节大小。</li>
<li>userrefs：快照上的只读属性，显示此快照上的用户持有数量。用户持有是使用zfs hold命令设置的。</li>
<li>userused@<user>：只读属性，显示指定用户在此数据集中所使用的空间量。空间由每个文件的所有者承担，如“ls -l”所示。使用量由du和ls -s表示。有关更多信息，请参阅zfs userspace子命令。“userused@<user>”属性在“zfs get all”中不会显示。@符号后面必须加上用户名，使用以下形式之一:<br>（1）POSIX名称(例如，joe)<br>（2）POSIX数字ID(例如，789)<br>（3）SID名称(例如joe.smith@mydomain)<br>（4）SID数字ID(例如，S-1-123-456-789)</li>
<li>utf8only：指示文件系统是否应该拒绝包含UTF-8字符集中不存在的字符的文件名。默认值为“off”。有效值为“on”和“off”。在创建数据集之后，无法更改此属性。</li>
<li>version： 这个文件系统的磁盘版本，它独立于池版本。此属性只能设置为稍后支持的版本。有效值是“当前”、“1”、“2”、“3”、“4”、“5”</li>
<li>volblocksize： 卷的只读属性，指定卷的块大小。一旦写入卷，就不能更改块大小，因此应该在创建卷时设置块大小。卷的默认blocksize为8KB。从512字节到128KB的任意2次方都有效。</li>
<li>vscan： 控制在打开和关闭文件时是否应该对常规文件进行病毒扫描。除了启用此属性外，还必须启用病毒扫描服务才能进行病毒扫描。默认值为“off”。有效值为“on”和“off”。</li>
<li>written： 只读属性，显示自上次快照以来写入此数据集的引用空间量。</li>
<li>written@<snapshot>：快照上的只读属性，该属性显示自指定快照以来写入此数据集的引用空间量。这是该数据集引用但指定快照未引用的空间。</li>
<li>xattr：控制是否为该文件系统启用扩展属性。默认值为“on”。有效值为“on”和“off”。</li>
<li>zoned：控制是否从非全局区域管理数据集。Zones是Solaris的一个特性，与Linux无关。默认值为“off”。有效值为“on”和“off”。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 您可能已经注意到，一些ZFS数据集属性在Linux上的ZFS中并没有完全实现，例如通过iSCSI共享卷。其他数据集属性适用于整个池，例如重复数据删除的情况，即使它们适用于特定的数据集。许多属性只适用于新写入的数据，并且没有追溯力。因此，要了解每个属性及其所提供的优点/缺点。因为父存储池也是一个有效的ZFS数据集，所以任何子数据集都将继承非默认属性。嵌套数据集、快照和卷也是如此。</p>
<p> 使用ZFS数据集属性，您现在可以轻松地进行所有调优，目的是设置一个可靠的ZFS存储后端。所有的事情都是用“zfs”命令及其必要的子命令处理的。事实上，到目前为止，我们只学习了两个命令:“zpool”和“zfs”，但我们已经能够构建和配置功能强大、大型、冗余、一致、快速和调优的zfs文件系统。这在存储领域是前所未有的，特别是在GNU/Linux中。 剩下要讨论的唯一一件事就是一些最佳实践和注意事项，然后是一篇关于“zdb”命令(您应该永远不需要它)的简短文章，我们将完成本系列的工作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/cd/E24847_01/html/819-7065/gazss.html">ZFS属性介绍</a></p>
<p><a href="https://pthree.org/2013/01/02/zfs-administration-part-xvi-getting-and-setting-properties/">https://pthree.org/2013/01/02/zfs-administration-part-xvi-getting-and-setting-properties/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列（十五）数据集最佳实践和注意事项</title>
    <url>/2021/10/21/ZFS%E7%B3%BB%E5%88%97%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%E6%95%B0%E6%8D%AE%E9%9B%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/10/25/55upid.png" alt=""><br><span id="more"></span></p>
<p>本文介绍如何ZFS数据集的最佳实践和注意事项，注意和存储池的区分开。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>和所有的建议一样，这些建议中有一些很重要，而另一些可能没有。你甚至可能无法像你想的那样严格地遵循它们。无论如何，你应该意识到它们。我将尝试为每一项提供一个理由。它们没有特定的顺序。“最佳实践”的理念是优化空间效率、性能并确保最大程度的数据完整性。</p>
<ul>
<li>总是启用压缩。几乎可以肯定，没有理由让它保持禁用状态。它占用CPU很少和也几乎不影响硬盘的吞吐量，但它的好处是惊人的。</li>
<li>除非您有足够的RAM，否则避免使用数据去重功能。与压缩不同，数据去重在系统上的成本非常高。数据去重表占用大量内存。 </li>
<li>经常、定期地进行快照。快照很便宜，而且可以在一段时间内保存大量的文件版本。考虑使用类似<a href="https://github.com/zfsonlinux/zfs-auto-snapshot">zfs-auto-snapshot</a>的脚本。 </li>
<li>快照不是备份。使用“zfs send”和“zfs receive”将您的zfs快照发送到外部存储。</li>
<li>如果使用NFS，请使用ZFS NFS而不是您的本机导出。这可以确保在NFS客户端开始向挂载点发送数据之前，数据集已挂载并处于在线状态。</li>
<li>不要混合NFS内核导出和ZFS NFS导出，这很难管理和维护。</li>
<li>在/home/下 安装ZFS，可以为每个用户设置嵌套数据集。例如，pool/home/atoponce和pool/home/dobbs，并对数据集使用配额。</li>
<li>当使用”zfs send”和”zfs receive”时，使用”zfs send -i”开关发送增量流。这是一个非常节省时间的方法。</li>
<li>考虑使用“zfs send”而不是“rsync”，因为“zfs send”命令可以保留数据集属性。</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意事项列表的重点绝不是阻止您使用ZFS。相反，作为规划ZFS存储服务器的存储管理员，您应该注意这些事情，以免出现数据损坏丢失之类的严重的问题。如果您不关心这些注意事项，您有可能会得到损坏的数据。上述的“最佳实践”列表可能会模糊这一界限。我已经试着列出了所有的如果不注意可能会导致数据损坏的事项。阅读并理解这些说明，你应该会很大程度上避免出问题。</p>
<ul>
<li>“zfs destroy”可能导致其他数据集停机。“zfs destroy”将接触存储池中数据集中的每个文件。数据集越大，执行此操作所花费的时间就越长，并且它将使用驱动器中所有可能的IOPS来实现此操作。因此，如果销毁数据集需要2小时，则池中的其他数据集可能需要2小时的停机时间。</li>
<li>如果在/etc/exports文件中没有有效的导出，Debian和Ubuntu将不会启动NFS守护进程。您必须修改/etc/init.d/nfs 初始化脚本在不导出的情况下启动，或者在本地创建虚拟导出。</li>
<li>Debian和Ubuntu，可能还有其他系统都使用并行启动。因此，初始化脚本的执行顺序不再是按优先级的。这为在启动时挂载ZFS数据集带来了问题。对于Debian和Ubuntu，点击“/etc/init.d/.legacy-bootordering文件，并确保/etc/init.d/zfs 初始化脚本是在该运行级别的所有其他服务之前先启动的。</li>
<li>不要从其他ZFS数据集中的文件创建ZFS存储池。这将导致各种问题并且令人头痛。</li>
<li>在创建ZVOL时，请确保将块大小设置为与格式化ZVOL所用的块大小相同或者上其倍数。如果块大小没有对齐，可能会出现性能问题。</li>
<li>当加载“zfs”内核模块时，确保为ARC设置一个最大数量。执行大量的“zfs发送”或快照操作将缓存数据。如果不设置，RAM将被慢慢填满，直到内核调用OOM 杀掉进程。我已经在/etc/modprobe.d/zfs.conf文件中设置了”options zfs zfs_arc_max=2147483648”，这是一个2 GB的ARC限制。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2013/01/03/zfs-administration-part-xvii-best-practices-and-caveats/">https://pthree.org/2013/01/03/zfs-administration-part-xvii-best-practices-and-caveats/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列补充（一）图解ZIL</title>
    <url>/2021/10/22/ZFS%E7%B3%BB%E5%88%97%E8%A1%A5%E5%85%85%EF%BC%88%E4%B8%80%EF%BC%89%E5%9B%BE%E8%A7%A3ZIL/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/01/IP0AG4.png" alt=""><br><span id="more"></span></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在和同事一起散步的时候，讨论了异步写入和ZIL内容究竟是什么的问题。然而，在并没有真正讨论过ZIL的内容是什么之前，说实话，我自己也没有完全理解它。Andrew Kuhnhausen澄清了这一点。所以，根据我们在散步时的讨论，以及白板上的一些漂亮的图表，我将在这里给你们详细说明。</p>
<p>让我们从头说起。ZFS的行为更像ACID兼容的RDBMS，而不是传统的文件系统。它的写入是事务，这意味着没有部分写入，它们是完全原子的，这意味着您要么得到全部，要么什么都得不到。无论写操作是同步的还是异步的，都是如此。所以，最好的情况是你有所有的数据。最坏的情况是您错过了最后一次事务性写入，并且您的数据是5秒前的(默认情况下)。那么，让我们也看看这些情况——同步写和异步写。对于同步，我们将考虑是否使用单独的日志记录设备(SLOG)进行写操作。</p>
<h2 id="ZIL功能"><a href="#ZIL功能" class="headerlink" title="ZIL功能"></a>ZIL功能</h2><p>ZIL的主要也是唯一的功能是在发生故障时重放丢失的事务。当发生断电、崩溃或其他灾难性故障时，RAM中的挂起事务可能没有提交到较慢的磁盘。因此，当系统恢复时，ZFS将注意到丢失的事务。此时，将读取ZIL以重放这些事务，并将数据提交到稳定存储。<br>当系统启动并正常运行时，ZIL永远不会被读取，它只写入。您可以通过以下操作验证这一点(假设您的系统中有SLOG)：打开两个终端。在一个终端上运行IOZone基准测试。做以下事情:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ iozone -ao</span><br></pre></td></tr></table></figure><br>这将运行一系列测试，以查看磁盘的性能。当这个基准测试运行时，在另一个终端中，以root用户的身份运行以下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool iostat -v 1</span><br></pre></td></tr></table></figure><br> 这将清楚地告诉您，当ZIL驻留在一个SLOG上时，SLOG设备只被写入。你永远不会在read列中看到任何数字。这是因为不会读取ZIL，除非需要在崩溃时重放事务。下面是其中一秒钟的文字说明:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                                            capacity     operations    bandwidth</span><br><span class="line">pool                                                     alloc   free   read  write   read  write</span><br><span class="line">-------------------------------------------------------  -----  -----  -----  -----  -----  -----</span><br><span class="line">pool                                                     87.7G   126G      0    155      0   601K</span><br><span class="line">  mirror                                                 87.7G   126G      0    138      0   397K</span><br><span class="line">    scsi-SATA_WDC_WD2500AAKX-_WD-WCAYU9421741-part5          -      -      0     69      0   727K</span><br><span class="line">    scsi-SATA_WDC_WD2500AAKX-_WD-WCAYU9755779-part5          -      -      0     68      0   727K</span><br><span class="line">logs                                                         -      -      -      -      -      -</span><br><span class="line">  mirror                                                 2.43M   478M      0      8      0   108K</span><br><span class="line">    scsi-SATA_OCZ-REVODRIVE_XOCZ-6G9S9B5XDR534931-part1      -      -      0      8      0   108K</span><br><span class="line">    scsi-SATA_OCZ-REVODRIVE_XOCZ-THM0SU3H89T5XGR1-part1      -      -      0      8      0   108K</span><br><span class="line">  mirror                                                 2.57M   477M      0      7      0  95.9K</span><br><span class="line">    scsi-SATA_OCZ-REVODRIVE_XOCZ-V402GS0LRN721LK5-part1      -      -      0      7      0  95.9K</span><br><span class="line">    scsi-SATA_OCZ-REVODRIVE_XOCZ-WI4ZOY2555CH3239-part1      -      -      0      7      0  95.9K</span><br><span class="line">cache                                                        -      -      -      -      -      -</span><br><span class="line">  scsi-SATA_OCZ-REVODRIVE_XOCZ-6G9S9B5XDR534931-part5    26.6G  56.7G      0      0      0      0</span><br><span class="line">  scsi-SATA_OCZ-REVODRIVE_XOCZ-THM0SU3H89T5XGR1-part5    26.5G  56.8G      0      0      0      0</span><br><span class="line">  scsi-SATA_OCZ-REVODRIVE_XOCZ-V402GS0LRN721LK5-part5    26.7G  56.7G      0      0      0      0</span><br><span class="line">  scsi-SATA_OCZ-REVODRIVE_XOCZ-WI4ZOY2555CH3239-part5    26.7G  56.7G      0      0      0      0</span><br><span class="line">-------------------------------------------------------  -----  -----  -----  -----  -----  -----</span><br></pre></td></tr></table></figure><br> <strong>ZIL应该总是放在非易失性的稳定存储! </strong> 您希望您的数据在断电时保持一致。将您的ZIL放在由TMPFS、RAMFS或RAM驱动器构建的SLOG上，而这些驱动器不是电池备份的，这意味着您将丢失任何挂起的事务，当然这并不意味着你会有损坏的数据。这只意味着你将拥有旧数据。在易失性存储上使用ZIL，发生故障时您将永远无法获得在写到稳定存储时挂起的新数据。取决于您的服务器有多忙，这可能是一个大问题。来自英特尔或OCZ的ssd是一种很好的廉价方法，可以获得快速、低延迟的SLOG，在断电时也是可靠的。</p>
<h2 id="没有SLOG的同步写"><a href="#没有SLOG的同步写" class="headerlink" title="没有SLOG的同步写"></a>没有SLOG的同步写</h2><p>当您没有SLOG时，应用程序只与RAM和普通磁盘进行交互。正如前面所讨论的，可以将ZFS Intent LOG (ZIL)看作是驻留在慢速磁盘上的文件。当应用程序需要进行同步写操作时，写操作的内容将被发送到应用程序当前所在的RAM，并被发送到ZIL。 因此，同步写入的数据块在这个时刻需要去两个地方——RAM和ZIL。一旦数据被写入到ZIL，盘片磁盘就会向应用程序发送一个确认，让它知道它拥有数据，此时数据就会从RAM刷新到较慢的磁盘。</p>
<p>然而，情况并非总是如此。在磁盘速度较慢的情况下，ZFS实际上可以立即将事务组(TXG)存储在磁盘上，并在ZIL中使用指针指向磁盘上的位置的。当磁盘返回ZIL包含指向数据的指针时，写入TXG将在RAM中关闭，并为将来的事务打开ZIL中的空间。因此，本质上，您可以将TXG SYNCHRONOUS以三种方式进行写提交:<br>（1）所有数据块同步写入RAM ARC和ZIL。<br>（2）所有数据块都同步写入RAM ARC和VDEV，指针指向写到ZIL的数据块。<br>（3）所有的数据块都被同步地写入磁盘，而ZIL则完全被忽略。<br>在下图中，我试图捕捉第一个过程的简化视图。标记为1的粉色箭头表示应用程序将其数据提交给RAM和ZIL。从技术上讲，应用程序已经在RAM中运行了，但我把它拿出来是为了让图像更清晰一些。在块被提交到RAM后，磁盘返回写入ZIL的ACK，标记为2号绿色箭头。最后，ZFS将数据块从RAM中刷到磁盘，标记为三号的灰色箭头说明了这一点。<br><img src="https://z3.ax1x.com/2021/11/01/IPwVDP.png" alt=""></p>
<h2 id="带有SLOG的同步写"><a href="#带有SLOG的同步写" class="headerlink" title="带有SLOG的同步写"></a>带有SLOG的同步写</h2><p> 如前面的文章所述，SLOG的优点是能够使用低延迟、快速地将ACK发送回应用程序。注意，ZIL现在驻留在SLOG上，而不再驻留在盘上。SLOG将捕获所有同步写操作(至少是那些用O_SYNC和fsync(2)调用的操作)。与盘片磁盘一样，ZIL将包含应用程序试图提交到稳定存储的数据块。然而，作为一个快速的SSD或NVRAM驱动器，写完ZIL后，SLOG会ACK，此时ZFS会将数据从RAM中刷新到慢盘中。</p>
<p>注意，ZFS没有将数据从ZIL刷新到磁盘。这就是最初让我困惑的地方。数据从RAM刷新到磁盘。与ACID兼容的RDBMS一样，ZIL仅用于在发生故障和数据丢失时重放事务。否则，永远不会从ZIL读取数据。所以写操作根本没有改变。只有ZIL的位置发生了变化。否则，操作完全相同。</p>
<p>图所示，标记为1的粉色箭头再次表示应用程序将其数据提交给RAM和SLOG上的ZIL。SLOG对写入ZIL操作进行ACK(绿色箭头标记为2)，然后ZFS将数据从RAM中刷新到磁盘(灰色箭头标记为3)。<br><img src="https://z3.ax1x.com/2021/11/01/IPwh2d.png" alt=""></p>
<h2 id="异步写"><a href="#异步写" class="headerlink" title="异步写"></a>异步写</h2><p>异步写有一段“不稳定”的历史。您已经知道应该避免异步写操作，如果决定采用异步写操作，则应该准备好在出现故障时处理损坏的数据。对于大多数文件系统，这是一个好的建议。然而，用ZFS就没有什么好害怕的了。由于ZFS的体系结构设计，所有数据都被提交到事务组中的磁盘。此外，事务是原子的，这意味着您可以获得所有事务，也可以不获得任何事务。你永远不会得到部分写入。异步写入也是如此。因此，您的数据在磁盘上总是一致的——即使是异步写入。</p>
<p>如果是这样，那异步写流程是什么样的?当你在你的数据集上启用“sync=disabled”时，实际上会在RAM中驻留一个ZIL。按照之前同步架构的标准，应用程序的数据块被发送到位于RAM中的ZIL。一旦数据进入ZIL, RAM就会确认写入操作，然后按照同步数据的标准将数据刷新到磁盘。</p>
<p>我知道你在想什么:“等一下!异步写入不需要确认!”不总是正确的。对于ZFS，有一点是肯定的，它只是一个来自非常非常快和非常低潜在的易失性存储。ACK几乎是瞬时的。如果出现崩溃或其他一些导致RAM失去电源的故障，并且写没有保存到非易失性存储，那么写就会丢失。然而，这意味着您丢失了新数据，并且只能使用旧的但一致的数据。记住，使用ZFS时，数据是在原子事务中提交的。<br>（简单的说，在ZFS中即使发生故障，最多也就是丢掉最近5分钟的数据，所以数据是5分钟前的就数据，但是数据是一致的）。</p>
<p>下图展示了异步写操作。同样，粉色的1号箭头表示最初写入RAM中的ZIL的应用程序数据块。绿色的2号箭头表示RAM的ACK。然后，正如带数字3的灰色箭头所示，ZFS将数据刷新到磁盘，这与前面的每个实现相同。注意，在这个图中，即使你有一个SLOG，在异步写的时候，它将被绕过，没有使用。<br><img src="https://z3.ax1x.com/2021/11/01/IPwIKI.png" alt=""></p>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>这是我和我的同事对ZIL的理解。这是在阅读大量文档、理解一些计算机科学理论和理解遵循ACID的RDBMS是如何工作的(它是以类似的方式构建的)之后完成的。如果你认为这是不正确的，请在评论中告诉我，我们可以讨论架构。</p>
<p>当然，我忽略了一些细节，比如在不再使用ZIL之前，它将保存多少数据、事务组写入的时间，以及其他事情。然而，还应该注意的是，除了一些晦涩的文档之外，似乎没有任何关于ZIL如何确切工作的可靠示例。所以，我想最好在这里说明一下，这样其他人就不会像我一样困惑了。对我来说，图总是能让事情更清晰地理解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2013/04/19/zfs-administration-appendix-a-visualizing-the-zfs-intent-log/">https://pthree.org/2013/04/19/zfs-administration-appendix-a-visualizing-the-zfs-intent-log/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列补充（二）把你的U盘用起来</title>
    <url>/2021/10/23/ZFS%E7%B3%BB%E5%88%97%E8%A1%A5%E5%85%85%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8A%8A%E4%BD%A0%E7%9A%84U%E7%9B%98%E7%94%A8%E8%B5%B7%E6%9D%A5/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/09/INijqH.png" alt=""><br><span id="more"></span></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文来自于“为什么我之前没有想到?!”系列。我家里和办公室有一堆usb2.0 U盘：有6个16GB的和8个8GB的，总共14个。我在一个GlusterFS存储集群中有两个hypervisor，我刚好有两个USB 集线器，每个USB 集线器支持7个USB口。完美!所以，为什么不好好利用它们，把它们作为L2ARC设备添加到我的资源池中呢?</p>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>USB2.0每个控制器限速在40MBps以内。一个标准的7200RPM硬盘可以做到100MBps。因此，将USB 2.0驱动器添加到您的池中作为缓存不会增加读带宽。至少对于大的顺序读取不是这样。然而，NAND闪存设备的寻道延迟通常在1毫秒到3毫秒之间，而普通HDD硬盘大约是12毫秒。如果您像我一样进行大量小的随机IO，那么USB驱动器实际上将提供HDD无法提供的总体性能提升。</p>
<p>此外，由于NAND闪存没有移动部件，需要从HDD硬盘读取的数据更少，这意味着执行器臂的移动更少，这意味着长期消耗更少的电力。所以，它们不仅对小型随机IO更好，同时也节省了您的电力!为绿色干杯!</p>
<p>最后，L2ARC应该是读密集的。然而，如果在ARC和L2ARC中没有足够的空间存储所有请求的数据，它也可能是写密集型的。如果是这种情况，您将不断地向L2ARC写入数据。对于USB驱动器没有磨损水平算法，你将快速消耗U盘，它可能会死在任何时间。如果是这种情况，可以只在L2ARC中存储元数据，而不是存实际的数据。你可以通过以下方式来实现:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs set secondarycache=metadata pool</span><br></pre></td></tr></table></figure><br> 您可以设置整个池或每个数据集。在上面概述的情况下，我肯定会在池范围内执行，每个数据集都会默认继承这个范围。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这是相当直接的。只需通过使用它们的唯一标识符识别驱动器是什么，然后将它们添加到池中:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ls /dev/disk/by-id/usb-* | grep -v part</span><br><span class="line">/dev/disk/by-id/usb-Kingston_DataTraveler_G3_0014780D8CEBEBC145E80163-0:0@</span><br><span class="line">/dev/disk/by-id/usb-Kingston_DataTraveler_SE9_00187D0F567FEC2090007621-0:0@</span><br><span class="line">/dev/disk/by-id/usb-Kingston_DataTraveler_SE9_00248121ABD5EC2070002E70-0:0@</span><br><span class="line">/dev/disk/by-id/usb-Kingston_DataTraveler_SE9_00D0C9CE66A2EC2070002F04-0:0@</span><br><span class="line">/dev/disk/by-id/usb-_USB_DISK_Pro_070B2605FA99D033-0:0@</span><br><span class="line">/dev/disk/by-id/usb-_USB_DISK_Pro_070B2607A029C562-0:0@</span><br><span class="line">/dev/disk/by-id/usb-_USB_DISK_Pro_070B2608976BFD58-0:0@</span><br></pre></td></tr></table></figure><br>所以，这就是我在文章开头提到的七个盘。因此，要将它们添加到系统中作为L2ARC驱动器，只需运行以下命令:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool add -f pool cache usb-Kingston_DataTraveler_G3_0014780D8CEBEBC145E80163-0:0\</span><br><span class="line">usb-Kingston_DataTraveler_SE9_00187D0F567FEC2090007621-0:0\</span><br><span class="line">usb-Kingston_DataTraveler_SE9_00248121ABD5EC2070002E70-0:0\</span><br><span class="line">usb-Kingston_DataTraveler_SE9_00D0C9CE66A2EC2070002F04-0:0\</span><br><span class="line">usb-_USB_DISK_Pro_070B2605FA99D033-0:0\</span><br><span class="line">usb-_USB_DISK_Pro_070B2607A029C562-0:0\</span><br><span class="line">usb-_USB_DISK_Pro_070B2608976BFD58-0:0</span><br></pre></td></tr></table></figure><br>当然，这些是我的U盘的唯一标识符。你需要根据你的U盘的标识符来替换它们。现在它们都安装好了，看看容量是不是都满了?<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool iostat -v</span><br><span class="line">pool                                                          alloc   free   read  write   read  write</span><br><span class="line">------------------------------------------------------------  -----  -----  -----  -----  -----  -----</span><br><span class="line">pool                                                           695G  1.13T     21     59  53.6K   457K</span><br><span class="line">  mirror                                                       349G   579G     10     28  25.2K   220K</span><br><span class="line">    ata-ST1000DM003-9YN162_S1D1TM4J                               -      -      4     21  25.8K   267K</span><br><span class="line">    ata-WDC_WD10EARS-00Y5B1_WD-WMAV50708780                       -      -      4     21  27.9K   267K</span><br><span class="line">  mirror                                                       347G   581G     11     30  28.3K   237K</span><br><span class="line">    ata-WDC_WD10EARS-00Y5B1_WD-WMAV50713154                       -      -      4     22  16.7K   238K</span><br><span class="line">    ata-WDC_WD10EARS-00Y5B1_WD-WMAV50710024                       -      -      4     22  19.4K   238K</span><br><span class="line">logs                                                              -      -      -      -      -      -</span><br><span class="line">  mirror                                                         4K  1016M      0      0      0      0</span><br><span class="line">    ata-OCZ-REVODRIVE_OCZ-33W9WE11E9X73Y41-part1                  -      -      0      0      0      0</span><br><span class="line">    ata-OCZ-REVODRIVE_OCZ-X5RG0EIY7MN7676K-part1                  -      -      0      0      0      0</span><br><span class="line">cache                                                             -      -      -      -      -      -</span><br><span class="line">  ata-OCZ-REVODRIVE_OCZ-33W9WE11E9X73Y41-part2                52.2G    16M      4      2  51.3K   291K</span><br><span class="line">  ata-OCZ-REVODRIVE_OCZ-X5RG0EIY7MN7676K-part2                52.2G    16M      4      2  52.6K   293K</span><br><span class="line">  usb-Kingston_DataTraveler_G3_0014780D8CEBEBC145E80163-0:0    465M  6.80G      0      0    319  72.8K</span><br><span class="line">  usb-Kingston_DataTraveler_SE9_00187D0F567FEC2090007621-0:0  1.02G  13.5G      0      0  1.58K  63.0K</span><br><span class="line">  usb-Kingston_DataTraveler_SE9_00248121ABD5EC2070002E70-0:0  1.17G  13.4G      0      0    844  72.3K</span><br><span class="line">  usb-Kingston_DataTraveler_SE9_00D0C9CE66A2EC2070002F04-0:0   990M  13.6G      0      0  1.02K  59.9K</span><br><span class="line">  usb-_USB_DISK_Pro_070B2605FA99D033-0:0                      1.08G  6.36G      0      0  1.18K  67.0K</span><br><span class="line">  usb-_USB_DISK_Pro_070B2607A029C562-0:0                      1.76G  5.68G      0      1  2.48K   109K</span><br><span class="line">  usb-_USB_DISK_Pro_070B2608976BFD58-0:0                      1.20G  6.24G      0      0    530  38.8K</span><br><span class="line">------------------------------------------------------------  -----  -----  -----  -----  -----  -----</span><br></pre></td></tr></table></figure><br>这里需要理解的重要一点是，驱动器不需要都是相同的大小。根据手边有的盘，你可以混合和匹配。当然，给缓存提供的空间越大越好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然这种方式肯定不是为速度而设计的，但它可以用于降低随机IO延迟，并且很好地降低数据中心的功耗。此外，你还打算用这些随处可见的USB设备做什么呢?不妨好好利用它们。显然，“云”让你的所有文件都在线变得容易。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2013/05/09/zfs-administration-appendix-b-using-usb-drives/">https://pthree.org/2013/05/09/zfs-administration-appendix-b-using-usb-drives/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列补充（三）为什么你应该使用ECC RAM</title>
    <url>/2021/10/24/ZFS%E7%B3%BB%E5%88%97%E8%A1%A5%E5%85%85%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8ECC%20RAM/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/09/INm0N4.png" alt=""><br><span id="more"></span></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着ZFS扩展到FreeBSD、Linux、FreeNAS、Illumos和许多其他操作系统，以及OpenZFS的引入，将所有项目统一到一个整体下，越来越多的人开始在许多不同的情况下使用并修复ZFS的一些问题。有些人将其安装在主生产服务器上，有些人将其安装在大型后端存储阵列上，甚至还有一些人将其安装在他们的工作站或笔记本电脑上。随着ZFS越来越流行，您将看到越来越多的ZFS安装在商品硬件上，而不是企业硬件上。因此，您将看到越来越多的ZFS安装在不支持ECC RAM的硬件上。</p>
<p>我在这里提出的问题是:这是个坏主意吗?如果您花一些时间在Web上搜索，您会发现一篇又一篇关于为什么应该为ZFS安装选择ECC RAM的文章，这些文章有很好的论点，也有很好的理由。本文我希望重申这些观点，并为ECC RAM辩护。您的链的强度取决于最薄弱的一环，如果该链接是非ECC RAM，那么您将失去ZFS开发人员为防止数据损坏而付出的所有努力。</p>
<h2 id="好的RAM-vs-坏的RAM-vs-ECC-RAM"><a href="#好的RAM-vs-坏的RAM-vs-ECC-RAM" class="headerlink" title="好的RAM vs 坏的RAM vs ECC RAM"></a>好的RAM vs 坏的RAM vs ECC RAM</h2><p>首先，让我们明确区分“好RAM”和“坏RAM”，以及它们与“ECC RAM”的区别:</p>
<ul>
<li>好的RAM – 有很低失败率的高质量RAM模块</li>
<li>坏的RAM – 有很高失败率的低质量RAM模块</li>
<li>ECC RAM – 具有纠错能力的RAM模块</li>
</ul>
<p>“坏RAM”并不一定是非ECC RAM。我过去部署过“坏的”（质量不好的）ECC RAM，即使它们有纠错能力，但它们经常失败，需要更换。也就是说，ECC RAM不一定就是“好RAM”。比如我有这样的经历，已经部署了多年的非ECC RAM，它没有纠错功能，但一直也没有看到数据损坏的文件。关键是，您可以有例外的非ECC“好RAM”，它永远不会让您失败，也可以有可怕的ECC“坏RAM”，它仍然会造成数据损坏。</p>
<p>你需要注意的是失败率。一个ECC RAM模块可能与一个具有相同构建质量的非ECC模块一样频繁地发生故障。希望失败率是这样的，ECC可以修复它检测到的错误，并且仍然在没有数据损坏的情况下运行。但是ECC RAM和硬件的故障率是脱节的，这可能是徒劳无功。只是因为它是ECC RAM并不意味着硬件故障的频率更低。ECC的全部意思是，它检测故障，并试图纠正它们。</p>
<h2 id="ECC-RAM"><a href="#ECC-RAM" class="headerlink" title="ECC RAM"></a>ECC RAM</h2><p>失败率很难控制。如果你读过维基百科关于ECC RAM的文章，它提到了一些研究，这些研究试图掌握内存模块中发生bit错误的频率:</p>
<blockquote>
<p> 2007年至2009年间发表的研究显示，错误率变化很大，差异超过7个数量级，范围从10^(−10)[到]10^(−17)error/bit-h[ours]。在SIGMETRICS/Performance ‘ 09会议上提出了一项基于谷歌的大量服务器的非常大规模的研究。发现的实际错误率比之前的小规模或实验室研究高出几个数量级，每兆位(约2.5^(-7)x 10^(- 11)error/bit-h[ours])每十亿台设备小时25,000到70,000个错误(即:以最大错误率计算，8GB RAM每小时约5个单比特错误)，每年有超过8%的内存模块受到错误的影响。</p>
</blockquote>
<p>粗略地说，从谷歌在他们的数据中心所看到的，在他们安装的8%的RAM中，每小时8GB的RAM中有5位错误。如果你不认为这很重要，那你就是在欺骗自己。大多数这些位错是由背景辐射影响已安装的内存条造成的，这是由于宇宙射线产生的中子。但是电压波动，坏的电路，仅仅是差的构建质量也可以作为“位翻转”的因素。</p>
<p>ECC RAM通过每个字节使用一个额外的奇偶校验位来检测这个坏位。换句话说，对于每8位，就有一个第9位奇偶校验位，它作为前8位的校验和。因此，对于一个在系统中注册为64GB的内存模块，实际上有72GB的物理安装在芯片上，以便为奇偶校验提供空间。然而，需要注意的是，ECC RAM每字节只能纠正1位翻转(8位)。如果每字节有2位翻转，ECC RAM将无法恢复数据。</p>
<p>ZFS被设计用于检测由于硬件和其他因素而发生的静默数据错误。ZFS从上到下对数据进行校验，以确保没有数据损坏。如果您从一开始就阅读了本系列文章，那么您就会知道ZFS是如何构建的，以及ZFS是如何优先考虑数据完整性。使用ZFS的人之所以使用它，是因为他们无法忍受文件系统中任何地方、任何时候的数据损坏。但是，如果您的RAM不是ECC RAM，那么您就不能保证您的文件在存储到磁盘时不会损坏。如果文件由于RAM中的某个bit损坏而在RAM中损坏，那么当存储到ZFS时，它将使用这个坏位进行校验，因为ZFS将假定它正在接收的数据是好的。因此，您的ZFS数据集中有损坏的数据，并且这个已经损坏的数据会被当作完好的数据来校验，并且没有办法在内部修复错误。这是一件很糟糕的事情。<br>（<strong>简单的说，就是不用ECC RAM的话，很可能数据在存储到ZFS前，在内存中已经就损坏了，这样ZFS自然没有办法知道，也没办法修复</strong>）</p>
<h2 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景"></a>一个场景</h2><p>为了更深入地了解ZFS中的ECC RAM，让我们创建一个场景。让我们假设您没有使用ECC RAM。也许它安装在您的工作站上或笔记本电脑上，因为您喜欢ZFS用户空间工具，并且喜欢ZFS背后的思想。你想在本地使用它。但是，让我们假设您有上面定义的非ECC “Bad RAM”。不管出于什么原因，您的一个RAM模块中出现了一个“冻结位”。DIMM只在特定位置存储“0”或“1”。假设由于硬件故障，它总是报告一个“0”，不管应该在那里写什么。为了简单起见，我们将在示例中查看8位，即1字节。我用红色的“<span style="color:red;">0</span>”表示坏的部分。</p>
<p> 你的应用程序希望写“11001011”，但由于你的坏RAM，你以“1100<span style="color:red;">0</span>011”结束。因此，“1100<span style="color:red;">0</span>011”被发送到ZFS进行存储。ZFS将校验和添加到“1100<span style="color:red;">0</span>011”并将其存储在池中。您有数据损坏，而ZFS并不知道。ZFS假设从RAM输出的数据是正确的，因此奇偶校验和校验都是基于该结果计算的。</p>
<p>但是，当您从磁盘读取数据并将其存储回故障的非ECC RAM中时，会发生什么呢?在这一点上，事情变得很糟糕。所以，你读回“1100<span style="color:red;">0</span>011”到RAM。然而，在它被发送到磁盘之前，它被存储在几乎相同的位置。假设它只存储了4位。然后，你得到“<span style="color:red;">0</span>100<span style="color:red;">0</span>011”。不仅你的文件在磁盘上损坏了，而且你把它们存储到有故障的硬件所在的RAM中，使事情变得更糟。但是，ZFS是为了纠正这个问题而设计的，对吧?所以，我们可以修复坏位到“<strong>1</strong>1000011”，但问题是数据仍然是损坏的!</p>
<p>事情从这里开始越来越糟糕。因为这是一个物理硬件故障，我们实际上不能将第一个位设置为“1”。因此，任何这样做的尝试都会立即将其恢复为“0”。因此，当数据存储在我们错误的非ECC RAM中时，字节将保持为“<span style="color:red;">0</span>100<span style="color:red;">0</span>011”。现在，假设我们准备将RAM中的数据刷新到磁盘上，我们将“<span style="color:red;">0</span>100<span style="color:red;">0</span>011”存储在磁盘上，从而加剧了我们的错误。ZFS计算一个新的校验和基于新损坏的数据，并再次认为DIMM模块告诉我们的就是实际的值，但其实不是，这样下去就进一步损坏了我们的数据。</p>
<p>正如您所看到的，我们对非ECC RAM读写的数据越多，文件系统中损坏数据的可能性就越大。ZFS旨在保护我们不受这种情况的影响，但我们的保护链的强度是受最薄弱的环节决定，在本例中是非ECC RAM破坏了我们的数据。</p>
<p>您可能认为备份可以拯救您。如果你有一个未损坏的文件，你可以恢复，很好。但是，如果您的ZFS快照或rsync(1)复制了损坏的位到您的备份，那么您就没辙了。ZFS数据清理在这里也帮不了你。如前所述，您正确地将损坏的数据存储在磁盘上，这意味着损坏字节的checksum是正确的。然而，如果您在RAM中有额外的坏位，擦洗实际上会尝试“修复”坏位。但是，因为这是硬件故障，导致位冻结，所以擦洗将继续，继续，使您的池发生抖动。因此，数据清理（scrub）实际上会使性能下降，试图修复RAM中的一个坏比特。此外，数据清理不会修复池中已经正确校验的坏位。</p>
<p>无论你如何分割它，你信任你的非ECC RAM，而你信任的RAM出现了错误，而且你没有尝试恢复的手段和方法。</p>
<h2 id="ECC价格"><a href="#ECC价格" class="headerlink" title="ECC价格"></a>ECC价格</h2><p> 由于内存上的额外硬件，ECC RAM肯定比非ECC RAM更贵，但不是很多。事实上，因为ECC dimm有9/8额外的硬件，价格非常接近这一点。根据我的经验，64GB的ECC RAM大约比64GB的非ECC RAM贵9/8。许多通用主板也将支持无缓冲ECC RAM，尽管您应该选择支持主动ECC scrub的主板，以保持位损坏最小化。</p>
<p>你可以获得高质量的ECC DDR3 SDRAM从新蛋大约50美元每4GB。非ECC DDR3 SDRAM的零售价几乎完全相同。对我来说，这是显而易见的。你所需要的只是一个支持它的主板，并且支持ECC RAM的Supermicro主板也可以相对便宜。我知道这是主观的，但我最近构建了一个双节点的KVM管理程序共享存储集群，每个主机上有32 GB的注册ECC RAM和Tyan主板。</p>
<p> 所有32GB的总成本肯定比系统中的其他所有东西都要高，但我能够以每16GB 150美元的价格购买它们，或者以每64GB 600美元的价格购买它们。每个主板的价格是250美元，两块价格总共是500美元。所以，对于两个非常强大的服务器，我总共花费了1100美元，不包含CPU和磁盘等。对我来说，这是确保数据完整性的一项小投资，如果采用非ECC的RAM，也不会节省多少钱。小小的额外投资是非常值得的，能够确保我从上到下拥有数据完整性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ZFS从头开始构建，具有奇偶校验、镜像、校验和和其他机制来保护数据。如果校验和失败，ZFS可以尝试基于池中的冗余加载良好的数据，并修复损坏的位。但是ZFS假设一个正确的checksum，意味着在应用checksum之前位是正确的。这就是ECC RAM如此关键的地方。ECC RAM可以大大降低比特在存储到池中之前不正确的风险。</p>
<p>所以，你应该从这篇文章中吸取一些教训:  </p>
<ul>
<li>ZFS校验和假设来自RAM的数据是正确的。 </li>
<li>常规的ZFS数据清理将极大地降低损坏位的风险，但对于非ecc RAM硬件故障，这可能是您最大的敌人。</li>
<li>备份的好坏取决于它们存储的数据。如果备份损坏了，那就不是备份。 </li>
<li>ZFS校验数据、chechsum和物理数据都需要匹配。如果不匹配，就需要开始维修了。如果由于非ECC RAM在门外就坏了，那么你使用ZFS有什么意义呢?</li>
</ul>
<p>感谢FreeBSD论坛上的“cyberjock”对这篇文章的启发。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2013/12/10/zfs-administration-appendix-c-why-you-should-use-ecc-ram/">https://pthree.org/2013/12/10/zfs-administration-appendix-c-why-you-should-use-ecc-ram/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>ZFS系列补充（四）数据去重的真实代价</title>
    <url>/2021/10/25/ZFS%E7%B3%BB%E5%88%97%E8%A1%A5%E5%85%85%EF%BC%88%E5%9B%9B%EF%BC%89%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E7%9A%84%E7%9C%9F%E5%AE%9E%E4%BB%A3%E4%BB%B7/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/09/INMS8H.png" alt=""><br><span id="more"></span></p>
<p>这篇文章其实应该放在系统管理的“预算和计划”部分。在规划ZFS存储池时，您需要决定空间效率以及构建它所需的成本。我们多次听说ZFS块数据去重非常昂贵，我甚至在本博客上提到过，但它到底有多昂贵呢?我们要花多少钱?这就是这篇文章的内容。我们将从两个角度来看待它——企业硬件和商用硬件。在调查之后，我们应该能得出一些像样的结论。</p>
<p>本文提到的成本只是存储的成本而不是总的成本，总成本将包括网线，主板，CPU等等，这些成本变化范围大，这可能会使本文变得相当复杂。所以，让我们从基础开始。我们将把企业硬件定义为15K SAS驱动器和MLC SSD，我们将把商品硬件定义为7200 SATA驱动器和MLC SSD。在这两种情况下，我们将坚持使用高质量的ECC DDR3 RAM模块，并使用10TB的基础ZFS池。</p>
<p>那么，闲话少说，我们开始吧。</p>
<h2 id="确定硬盘需求"><a href="#确定硬盘需求" class="headerlink" title="确定硬盘需求"></a>确定硬盘需求</h2><p>在我们开始购买硬件之前，我们需要知道我们在寻找什么数据去重技术，以及它是否适合我们的数据需求。因为还没有实际将所有数据存储在池中，所以这可能是一个难以解决的难题。不过本文将给出关于这个解决方案的想法(“三个S测试”):</p>
<ol>
<li><strong>Sample test（抽样测试）</strong>：获取具有代表性的数据样本，不需要太多，也许是整个数据的1/5。只是表示实际要存储的东西。这将是最准确的测试，只要你得到一个好的样品-越多越好。将这些数据样本存储在具有数据去重的池中，并查看最终的数据去重率是多少。</li>
<li><strong>Simulation test（模拟测试）</strong>：这不如上面的抽样测试准确，但它仍然可以提供一个很好的想法，您将看到什么。运行“zfs -S”命令，看看输出的结果。这将花费一些时间，可能会给您的池带来压力，所以如果您必须在生产池上执行此命令，请在空闲时间运行该命令。它不会真的做数据去重，只是模拟它。以下是我个人ZFS产品服务器的实际模拟直方图:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zdb -S</span><br><span class="line">Simulated DDT histogram:</span><br><span class="line"></span><br><span class="line">bucket              allocated                       referenced          </span><br><span class="line">______   ______________________________   ______________________________</span><br><span class="line">refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE</span><br><span class="line">------   ------   -----   -----   -----   ------   -----   -----   -----</span><br><span class="line">     1    5.23M    629G    484G    486G    5.23M    629G    484G    486G</span><br><span class="line">     2     860K   97.4G   86.3G   86.6G    1.85M    215G    190G    190G</span><br><span class="line">     4    47.6K   4.18G   3.03G   3.05G     227K   19.7G   14.2G   14.3G</span><br><span class="line">     8    11.8K    931M    496M    504M     109K   8.49G   4.25G   4.33G</span><br><span class="line">    16    3.89K    306M   64.3M   68.3M    81.8K   6.64G   1.29G   1.37G</span><br><span class="line">    32    5.85K    499M    116M    122M     238K   17.9G   4.64G   4.86G</span><br><span class="line">    64    1.28K   43.7M   20.0M   21.0M     115K   3.74G   1.69G   1.79G</span><br><span class="line">   128    2.60K   50.2M   20.0M   22.0M     501K   9.22G   3.62G   3.99G</span><br><span class="line">   256      526   6.61M   3.18M   3.62M     163K   1.94G    946M   1.06G</span><br><span class="line">   512      265   3.25M   2.02M   2.19M     203K   2.67G   1.72G   1.86G</span><br><span class="line">    1K      134   1.41M    628K    720K     185K   2.13G    912M   1.02G</span><br><span class="line">    2K       75   1.16M    188K    244K     222K   3.37G    550M    716M</span><br><span class="line">    4K       51    127K   85.5K    125K     254K    657M    450M    650M</span><br><span class="line">    8K        2      1K      1K   2.46K    26.7K   13.3M   13.3M   32.8M</span><br><span class="line">   16K        1     512     512   1.94K    31.3K   15.6M   15.6M   60.7M</span><br><span class="line"> Total    6.15M    732G    574G    576G    9.38M    920G    708G    712G</span><br><span class="line"></span><br><span class="line">dedup = 1.24, compress = 1.30, copies = 1.01, dedup * compress / copies = 1.60</span><br></pre></td></tr></table></figure></li>
<li><strong>Supposed Test（假定测试）</strong>： 基本上只是猜测。到目前为止，这是我们测试中最不准确的，但您可能比自己想象的更了解您的数据。例如，这个10TB的服务器将是一个Debian或RPM包存储库吗?如果是这样，数据很可能是高度重复的，您可能会得到接近3:1的节省，甚至更好。也许该服务器将存储大量虚拟机映像，在这种情况下，基本操作系统将被大量复制。同样，你的比率可能会非常高。也就是说您知道您计划存储什么，以及会发生什么。</li>
</ol>
<p>现在您将得到一个重复数据删除比率数字。在我的例子中，是1.24:1。这个数字将帮助我们“超额认购”我们的存储。为了确定购买多少磁盘，我们的方程应该是:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Savings = Need - (Need / Ratio)</span><br></pre></td></tr></table></figure><br> 我的比率是1.24:1，运行了大约12个虚拟机，我们不需要购买全部10TB的磁盘，实际上我们只需要购买8TB的磁盘。这是一个现实的期望。因此，我可以为这个设置节省2TB的存储。问题就变成了这些节省是否值得。</p>
<h2 id="确定内存需求"><a href="#确定内存需求" class="headerlink" title="确定内存需求"></a>确定内存需求</h2><p>好的，现在我们知道了要购买多少磁盘，我们现在需要确定要购买多少RAM。我们已经知道，默认情况下，重复数据删除表(DDT)占安装RAM的比例不会超过25%。这可以通过内核模块进行调整，但在本文中我们将坚持使用默认值。因此，我们只需要确定这25%有多大，这样我们就可以准确地了解需要多少RAM才能安全地存储ARC而不溢出到普通盘上。为了掌握这个指标，我们有两个选择:</p>
<ol>
<li><p><strong>Counting Blocks（统计块数）</strong>：用”zdb -b“命令就可以得到存储池中当前使用的blocks数量。与“zdb -S”命令一样，这将加重池的压力，但它将为您提供关于重复数据删除表的最准确的描述。下面是我的生产服务器上的实际块数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zdb -b pool</span><br><span class="line"></span><br><span class="line">Traversing all blocks to verify nothing leaked ...</span><br><span class="line"></span><br><span class="line">        No leaks (block sum matches space maps exactly)</span><br><span class="line"></span><br><span class="line">        bp count:        11975124</span><br><span class="line">        bp logical:    1023913523200      avg:  85503</span><br><span class="line">        bp physical:   765382441472      avg:  63914     compression:   1.34</span><br><span class="line">        bp allocated:  780946764288      avg:  65214     compression:   1.31</span><br><span class="line">        bp deduped:             0    ref&gt;1:      0   deduplication:   1.00</span><br><span class="line">        SPA allocated: 780946764288     used: 39.19%</span><br></pre></td></tr></table></figure>
<p>在本例中，有11975124个已使用的块，我的2TB的池已使用39.19%，即784GB。因此，每个块的大小约为70KB。你可能会看到一些不同的东西。根据Oracle的说法，每个重复数据删除的块将占用大约320字节的RAM。因此，2TB除以70KB块得到的总存储空间约为30,700,000块。30,700,000块乘以320字节，是9824,000,000字节，或9.8GB RAM的DDT。 因为DDT不超过ARC的25%，而ARC通常是25%的RAM，所以需要至少156.8GB，或基本上160GB的RAM，以防止DDT溢出到磁盘。</p>
</li>
<li><p><strong>经验法则</strong>：这是我们的“经验法则”，您已经在本系列文章和互联网上的其他地方读过。规则是每1TB磁盘分配5GB RAM。这个比率来自于这样一个事实:一个重复数据删除的块在RAM中占用大约320字节的存储空间，而您的块占用的空间可能在512字节到128KB之间，通常平均约为64KB。所以，这个比率大约是1:208，这就是我们提出的“每1TB磁盘5GB RAM”指标。因此，对于10TB的池，我们可以预计DDT需要50GB的RAM, ARC需要200GB的RAM。</p>
</li>
</ol>
<p>在这两种情况下，需要的RAM可能只是物理限制上和成本限制上太高。在我的服务器中，主板不允许物理安装超过32GB的RAM模块。所以40GB是不行的。因此，数据去重是不可能的吗?不一定。如果您有一个快速的SSD，能够达到100k IOPS，或者大致相当于你安装的RAM，那么您可以让DDT从RAM溢出到L2ARC，并且性能不会受到影响。从物理限制和成本限制来看，256GB SSD比200GB的物理RAM模块更实用。</p>
<h2 id="企业硬件"><a href="#企业硬件" class="headerlink" title="企业硬件"></a>企业硬件</h2><h3 id="没有SSD"><a href="#没有SSD" class="headerlink" title="没有SSD"></a>没有SSD</h3><p>15k SAS硬盘可不便宜。目前，希捷猎豹硬盘售价约为每3GB 1美元，或每1TB 330美元。所以，对于8TB我们将花费在磁盘上，我们将花费2600美元用于磁盘。我们已经确定ARC需要大约200GB的空间。如果我们需要在RAM中安装所有东西，结合我们的主板将支持的安装尺寸，那么ECC RAM大约为320美元每16GB(多么方便)。我需要至少14个16GB内存模块。这将使我的内存成本在4480美元左右。因此，我的存储总账单只有7080美元。我只节省了670美元，省了两块盘。</p>
<h3 id="带SSD"><a href="#带SSD" class="headerlink" title="带SSD"></a>带SSD</h3><p>不购买14个16GB内存模块，我们可以很容易用500美元购买一个企业级的256GB快速SLC SSD。256GB的SSD很有吸引力，因为作为L2ARC，它将存储的不仅仅是DDT，而是磁盘上的其他缓存。此外，SSD也可以被分区来存储ZIL，作为一个SLOG。所以，我们可能只需要安装16GB的RAM(双通道的2x8GB模块)，这将使我们的RAM成本为320美元，SSD成本为500美元，硬盘成本为2600美元，总安装成本为3420美元。这是只使用ECC RAM来存DDT的配置价格的一半，在我看来，这是划算的。同样，我少买了2块盘，节省了670美元。</p>
<h2 id="商业硬件"><a href="#商业硬件" class="headerlink" title="商业硬件"></a>商业硬件</h2><h3 id="不带SSD"><a href="#不带SSD" class="headerlink" title="不带SSD"></a>不带SSD</h3><p>现在7200 SATA硬盘很便宜。ZFS在设计时考虑到了普通磁盘，知道它经常故障和静默数据损坏。我现在可以花80美元购买一个全新的2TB磁盘。4块硬盘的总成本是320美元。然而，ECC RAM不会改变，如果我需要14个16GB的棒，就像我的企业设置一样，那么可以计算出商品设置的总成本为4800美元。但是，对于“普通”设置装那么多内存没有意义，所以让我们减少RAM使用，并添加SSD。</p>
<h3 id="带SSD-1"><a href="#带SSD-1" class="headerlink" title="带SSD"></a>带SSD</h3><p>256GB的三星840 Pro目前售价为180美元，IOPS为10万，可以与DDR3 RAM相媲美。所以，还是用4个2TB的SATA硬盘，合计320美元，16GB的RAM是320美元，三星的SSD是180美元，我们这个设置的总成本是820美元，节省了80美元，因为少买了一个2TB SATA硬盘。这是目前为止最便宜的解决方案。</p>
<h2 id="额外的隐形成本-amp-SSD性能考虑"><a href="#额外的隐形成本-amp-SSD性能考虑" class="headerlink" title="额外的隐形成本 &amp; SSD性能考虑"></a>额外的隐形成本 &amp; SSD性能考虑</h2><p>当我们制定这些购买RAM的计划时，我们只考虑了储存ARC和DDT的成本。我们没有考虑到你的操作系统仍然需要ARC之外的空间来运行。我认识的大多数ZFS管理员在内存密集的设置中不会给ARC超过25%的RAM，在内存较少的设置中不会超过50%。因此，对于我们200GB的ARC要求，它可能需要多达400GB的RAM，甚至800GB。我还没有管理过安装这么大RAM的服务器。因此，SSD突然变得更有吸引力了。</p>
<p>如果您决定为L2ARC使用SSD，则需要确保它的性能与安装的RAM相当，否则在使用DDT进行查找时将会看到性能下降。预计DDR3 RAM的持续顺序读/写IOPS为100k到150k。</p>
<p>但是，假设您没有购买与DDR3模块性能相同的SSD。假设你的DDR3维持100k IOPS，但是你的SSD只有20k IOPS。这是DDR3慢的5倍(旋转7200转的磁盘只能维持大约100 IOPS)。由于ZFS将频繁地执行DDT查找，这将对性能造成重大影响。因此，您的L2ARC能够匹配与RAM相同的带宽是至关重要的。</p>
<p>此外，ssd还有一个隐性成本，那就是可靠性。典型的企业SLC SSD在芯片开始磨损之前，可以承受约10k的写周期，。然而，对于普通的、更“消费级”的ssd，它们只能维持大约3000 -5k的写周期。不要欺骗自己，对于我们的256GB SSD，这意味着您可以在SLC SSD上写入256GB 10,000次，或2.56PB的数据，或在MLC SSD上写入256GB 3,000次，或768TB的数据。这是大量的写，假设SSD在芯片上有磨损均衡算法。但是，SSD可能过早失效，这意味着DDT溢出到磁盘，完全扼杀存储池的性能。通过将一部分DDT放在SSD上，当ZFS为新的重复数据删除块扩展DDT表时，L2ARC将变得更加密集。在没有重复数据删除的情况下，L2ARC的写密集程度较低，读密集程度应该很高。因此，通过不使用重复数据删除，可以延长SSD的寿命。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，现在当你以1.24:1的去重率向首席财务官提供硬件报价时，你就很难说服他了。对于使用SSD的普通硬件，您在磁盘上的节省非常接近(10.25:1)，而在企业硬件上，您要要花更多的钱来节省空间(5.10:1)。但是，对于普通硬件，你的花费是企业级硬件的四分之一。在我看来，还是太贵了。</p>
<p>然而，如果你能让你的比例接近2:1，或者更好，那么它可能是一个很好的选择。你真的需要了解你的数据，你真的需要能够证明你会得到可靠的比率。虚拟机的存储服务器可能是一个很好的选择，或者您有几乎完全相同的冗余数据。对于一般用途的存储，尤其是在比率为1.24:1的情况下，似乎不值得这么做。但是，如果您希望节省磁盘，也不一定要这么做。</p>
<p>为了节省磁盘空间，我强烈建议压缩。即使是在高负载的情况下，压缩不会多消耗多少CPU，也可以提供类似的空间节省(在上面的示例中，压缩比为1.3:1，而dedup比为1.24:1)，不需要昂贵的DDT，实际上还提供了增强的性能。额外的性能来自于这样一个事实，即高度压缩的数据不需要物理地写入同样多的数据到慢速旋转的硬盘，也不需要从物理硬盘读取同样多。旋转磁盘是基础设施中最慢的瓶颈，因此任何优化读和写的操作都可以带来很大的收益。压缩带来的性能收益正是来源于此。（简单的说，如果压缩前数据大小为2MB，压缩后数据大小为1MB，你只需要写1MB数据到硬盘，读也只需要读1MB，这样性能得到了提升）。</p>
<p>希望这篇文章能帮助您分析数据去重计划，并确定必要的成本。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://pthree.org/2013/12/18/zfs-administration-appendix-d-the-true-cost-of-deduplication/">https://pthree.org/2013/12/18/zfs-administration-appendix-d-the-true-cost-of-deduplication/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
        <tag>ZFS</tag>
      </tags>
  </entry>
  <entry>
    <title>NVMe over RDMA的安装配置</title>
    <url>/2021/10/27/NVMe%20over%20RDMA%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/11/I0LqZn.png" alt=""><br><span id="more"></span></p>
<p>本文主要介绍NVMe over RDMA的安装和配置。关于什么是NVMe over Fabrics,什么是NVMe over RDMA，本文就不做介绍了，网上资料一大堆。<br>可以看看<a href="https://www.sdnlab.com/24838.html">什么是NVMe over Fabrics？</a><br>RDMA（全称：Remote Direct Memory Access）是一种远程直接内存访问技术，通过在硬件中实现传输层协议，将内存/消息原语接口暴露至用户空间，通过绕过CPU和内核网络协议栈来实现高吞吐和低延迟的网络。RoCE（RDMA over Converged Ethernet）是一种允许通过以太网使用远程直接内存访问（RDMA）的网络协议。</p>
<h2 id="RDMA安装配置"><a href="#RDMA安装配置" class="headerlink" title="RDMA安装配置"></a>RDMA安装配置</h2><h3 id="RDMA驱动安装"><a href="#RDMA驱动安装" class="headerlink" title="RDMA驱动安装"></a>RDMA驱动安装</h3><p>1.下载驱动包 debian10.5<br>下载页面：<a href="https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed">https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed</a></p>
<p><img src="https://z3.ax1x.com/2021/11/11/I0LEvQ.png" alt=""><br>选好对应的OS版本等信息后就可以点击下载：<br><img src="https://z3.ax1x.com/2021/11/11/I0L32F.png" alt=""></p>
<p>2.安装驱动<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./mlnxofedinstall  --add-kernel-support --with-nvmf --force</span><br><span class="line">./mlnxofedinstall --force --without-dkms --with-nvmf --add-kernel-support update-initramfs -u</span><br></pre></td></tr></table></figure></p>
<h3 id="验证RDMA的联通性"><a href="#验证RDMA的联通性" class="headerlink" title="验证RDMA的联通性"></a>验证RDMA的联通性</h3><p>target端和client端都安装驱动后，可以验证RDMA的联通性<br>1.查询服务器的ib device<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#target端</span><br><span class="line">:~#ibdev2netdev</span><br><span class="line">mlx5_4 port 1 ==&gt; eth4 (Down)</span><br><span class="line">mlx5_5 port 1 ==&gt; eth5 (Down)</span><br><span class="line">mlx5_bond_0 port 1 ==&gt; bond0 (Up)</span><br><span class="line">mlx5_bond_1 port 1 ==&gt; bond1 (Up)</span><br><span class="line">#client端</span><br><span class="line">:~# ibdev2netdev</span><br><span class="line">mlx5_bond_0 port 1 ==&gt; bond0 (Up)</span><br><span class="line">mlx5_bond_1 port 1 ==&gt; bond1 (Up)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>2.开启target端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ib_send_bw --ib-dev=mlx5_bond_1</span><br><span class="line"></span><br><span class="line">************************************</span><br><span class="line">* Waiting for client to connect... *</span><br><span class="line">************************************</span><br></pre></td></tr></table></figure>
<p>3.连接target端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:~# ib_send_bw --ib-dev=mlx5_bond_1 target端的ip</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line">                    Send BW Test</span><br><span class="line"> Dual-port       : OFF		Device         : mlx5_bond_1</span><br><span class="line"> Number of qps   : 1		Transport type : IB</span><br><span class="line"> Connection type : RC		Using SRQ      : OFF</span><br><span class="line"> PCIe relax order: ON</span><br><span class="line"> ibv_wr* API     : ON</span><br><span class="line"> TX depth        : 128</span><br><span class="line"> CQ Moderation   : 1</span><br><span class="line"> Mtu             : 1024[B]</span><br><span class="line"> Link type       : Ethernet</span><br><span class="line"> GID index       : 3</span><br><span class="line"> Max inline data : 0[B]</span><br><span class="line"> rdma_cm QPs	 : OFF</span><br><span class="line"> Data ex. method : Ethernet</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"> local address: LID 0000 QPN 0x117f PSN 0x3a5e58</span><br><span class="line"> GID: 00:00:00:00:00:00:00:00:00:00:255:255:07:32:205:201</span><br><span class="line"> remote address: LID 0000 QPN 0x126d PSN 0xf975cb</span><br><span class="line"> GID: 00:00:00:00:00:00:00:00:00:00:255:255:07:32:205:198</span><br><span class="line">---------------------------------------------------------------------------------------</span><br><span class="line"> #bytes     #iterations    BW peak[MB/sec]    BW average[MB/sec]   MsgRate[Mpps]</span><br><span class="line"> 65536      1000             2757.96            2757.93		   0.044127</span><br><span class="line">---------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>查看网卡支持的RoCE版本<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ show_gids //看看网卡支持的roce版本, </span><br><span class="line">DEV     PORT    INDEX   GID                                     IPv4            VER     DEV</span><br><span class="line">---     ----    -----   ---                                     ------------    ---     ---</span><br><span class="line">mlx5_4  1       0       fe80:0000:0000:0000:ee0d:9aff:fe2f:c21a                 v1      p1p1</span><br><span class="line">mlx5_4  1       1       fe80:0000:0000:0000:ee0d:9aff:fe2f:c21a                 v2      p1p1</span><br><span class="line">mlx5_4  1       2       0000:0000:0000:0000:0000:ffff:c0a8:0101 192.168.1.1     v1      p1p1</span><br><span class="line">mlx5_4  1       3       0000:0000:0000:0000:0000:ffff:c0a8:0101 192.168.1.1     v2      p1p1</span><br></pre></td></tr></table></figure></p>
<p>show_gids是一个脚本，脚本内容为：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">black=&#x27;\E[30;50m&#x27;</span><br><span class="line">red=&#x27;\E[31;50m&#x27;</span><br><span class="line">green=&#x27;\E[32;50m&#x27;</span><br><span class="line">yellow=&#x27;\E[33;50m&#x27;</span><br><span class="line">blue=&#x27;\E[34;50m&#x27;</span><br><span class="line">magenta=&#x27;\E[35;50m&#x27;</span><br><span class="line">cyan=&#x27;\E[36;50m&#x27;</span><br><span class="line">white=&#x27;\E[37;50m&#x27;</span><br><span class="line">bold=&#x27;\033[1m&#x27;</span><br><span class="line"></span><br><span class="line">gid_count=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cecho (color <span class="built_in">echo</span>) prints text <span class="keyword">in</span> color.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">first parameter should be the desired color followed by text</span></span><br><span class="line">function cecho ()</span><br><span class="line">&#123;</span><br><span class="line">    echo -en $1</span><br><span class="line">    shift</span><br><span class="line">    echo -n $*</span><br><span class="line"></span><br><span class="line">    tput sgr0</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">becho (color <span class="built_in">echo</span>) prints text <span class="keyword">in</span> bold.</span></span><br><span class="line">becho ()</span><br><span class="line">&#123;</span><br><span class="line">    echo -en $bold</span><br><span class="line">    echo -n $*</span><br><span class="line"></span><br><span class="line">    tput sgr0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function print_gids()</span><br><span class="line">&#123;</span><br><span class="line">    dev=$1</span><br><span class="line">    port=$2</span><br><span class="line"></span><br><span class="line">    for gf in /sys/class/infiniband/$dev/ports/$port/gids/* ; do</span><br><span class="line"></span><br><span class="line">    gid=$(cat $gf);</span><br><span class="line">    if [ $gid = 0000:0000:0000:0000:0000:0000:0000:0000 ] ; then</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo -e $(basename $gf) &quot;\t&quot; $gid</span><br><span class="line"></span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo -e &quot;DEV\tPORT\tINDEX\tGID\t\t\t\t\tIPv4 \t\tVER\tDEV&quot;</span><br><span class="line">echo -e &quot;---\t----\t-----\t---\t\t\t\t\t------------ \t---\t---&quot;</span><br><span class="line"></span><br><span class="line">DEVS=$1</span><br><span class="line">if [ -z &quot;$DEVS&quot; ] ; then</span><br><span class="line">    DEVS=$(ls /sys/class/infiniband/)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for d in $DEVS ; do</span><br><span class="line">    for p in $(ls /sys/class/infiniband/$d/ports/) ; do</span><br><span class="line">        for g in $(ls /sys/class/infiniband/$d/ports/$p/gids/) ; do</span><br><span class="line">            gid=$(cat /sys/class/infiniband/$d/ports/$p/gids/$g);</span><br><span class="line">            if [ $gid = 0000:0000:0000:0000:0000:0000:0000:0000 ] ; then</span><br><span class="line">                continue</span><br><span class="line">            fi</span><br><span class="line"></span><br><span class="line">            if [ $gid = fe80:0000:0000:0000:0000:0000:0000:0000 ] ; then</span><br><span class="line">                continue</span><br><span class="line">            fi</span><br><span class="line"></span><br><span class="line">            _ndev=$(cat /sys/class/infiniband/$d/ports/$p/gid_attrs/ndevs/$g 2&gt;/dev/null)</span><br><span class="line">            __type=$(cat /sys/class/infiniband/$d/ports/$p/gid_attrs/types/$g 2&gt;/dev/null)</span><br><span class="line">            _type=$(echo $__type| grep -o &quot;[Vv].*&quot;)</span><br><span class="line"></span><br><span class="line">            if [ $(echo $gid | cut -d &quot;:&quot; -f -1) = &quot;0000&quot; ] ; then</span><br><span class="line">                ipv4=$(printf &quot;%d.%d.%d.%d&quot; 0x$&#123;gid:30:2&#125; 0x$&#123;gid:32:2&#125; 0x$&#123;gid:35:2&#125; 0x$&#123;gid:37:2&#125;)</span><br><span class="line">                echo -e &quot;$d\t$p\t$g\t$gid\t$ipv4 \t$_type\t$_ndev&quot;</span><br><span class="line">            else</span><br><span class="line">                echo -e &quot;$d\t$p\t$g\t$gid\t\t\t$_type\t$_ndev&quot;</span><br><span class="line">            fi</span><br><span class="line"></span><br><span class="line">            gid_count=$(expr 1 + $gid_count)</span><br><span class="line"></span><br><span class="line">        done #g (gid)</span><br><span class="line">    done #p (port)</span><br><span class="line">done #d (dev)</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo n_gids_found=$gid_count</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="NVMe-Initiator-和-target-配置"><a href="#NVMe-Initiator-和-target-配置" class="headerlink" title="NVMe Initiator 和 target 配置"></a>NVMe Initiator 和 target 配置</h3><p>Initiator 和 target 分别为 2 台服务器，target 端 NVMe SSD能通过 RoCE 方式连接到 Initiator 端，连接至 Initiator 端的 SSD 与本地的块设备使用方式一致，例如 mkfs，mount等操作。可以理解为多个 target 端 NVMe 盘可以横向扩展至 Initiator 端，组成 NVMe 存储池使用。</p>
<p>其中nvme discover -q host nqn中nqn是指是NVMe 合格名称 (NVMe Qualified Name) 的缩写</p>
<h4 id="NVMe-target端配置"><a href="#NVMe-target端配置" class="headerlink" title="NVMe target端配置"></a>NVMe target端配置</h4><ol>
<li>安装nvme-cli（apt-get install nvme-cli）</li>
<li>配置target端</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># NVMe target configuration</span><br><span class="line"># Assuming the following:</span><br><span class="line"># IP is 192.168.13.147/24</span><br><span class="line"># link is up</span><br><span class="line"># using ib device eth2</span><br><span class="line"># modprobe nvme and rdma module</span><br><span class="line"></span><br><span class="line">modprobe nvmet</span><br><span class="line">modprobe nvmet-rdma</span><br><span class="line">modprobe nvme-rdma</span><br><span class="line"></span><br><span class="line"># 1、config nvme subsystem</span><br><span class="line">mkdir /sys/kernel/config/nvmet/subsystems/nvme-subsystem-name</span><br><span class="line">cd /sys/kernel/config/nvmet/subsystems/nvme-subsystem-name</span><br><span class="line"></span><br><span class="line"># 2、allow any host to be connected to this target</span><br><span class="line">echo 1 &gt; attr_allow_any_host</span><br><span class="line"></span><br><span class="line"># 3、create a namesapce，example: nsid=10</span><br><span class="line">mkdir namespaces/10</span><br><span class="line">cd namespaces/10</span><br><span class="line"></span><br><span class="line"># 4、set the path to the NVMe device</span><br><span class="line">echo -n /dev/nvme0n1&gt; device_path</span><br><span class="line">echo 1 &gt; enable</span><br><span class="line"></span><br><span class="line"># 5、create the following dir with an NVMe port</span><br><span class="line">mkdir /sys/kernel/config/nvmet/ports/1</span><br><span class="line">cd /sys/kernel/config/nvmet/ports/1</span><br><span class="line"></span><br><span class="line"># 6、set ip address to traddr</span><br><span class="line">echo &quot;192.168.13.147&quot; &gt; addr_traddr</span><br><span class="line"></span><br><span class="line"># 7、set rdma as a transport type，addr_trsvcid is unique.</span><br><span class="line">echo rdma &gt; addr_trtype</span><br><span class="line">echo 4420 &gt; addr_trsvcid</span><br><span class="line"></span><br><span class="line"># 8、set ipv4 as the Address family</span><br><span class="line">echo ipv4 &gt; addr_adrfam</span><br><span class="line"></span><br><span class="line"># 9、create a soft link</span><br><span class="line">ln -s /sys/kernel/config/nvmet/subsystems/nvme-subsystem-name /sys/kernel/config/nvmet/ports/1/subsystems/nvme-subsystem-name</span><br><span class="line"></span><br><span class="line"># 10、Check dmesg to make sure that the NVMe target is listening on the port</span><br><span class="line">dmesg -T| grep &quot;enabling port&quot;</span><br><span class="line">[369910.403503] nvmet_rdma: enabling port 1 (192.168.13.147:4420)`</span><br></pre></td></tr></table></figure>
<h4 id="配置initiator端"><a href="#配置initiator端" class="headerlink" title="配置initiator端"></a>配置initiator端</h4><p>initiator 端，又称为host/client端，initiator 配置前提：RDMA基础环境已搭建。通过NVMe 互联命令探测和连接target 端 NVMe SSD 即可。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#探测 192.168.13.147 机器上 4420 端口 nvme ssd</span><br><span class="line">nvme discover -t rdma -q nvme-subsystem-name -a 192.168.13.147 -s 4420</span><br><span class="line"></span><br><span class="line">#连接 192.168.13.147 4420 端口 nvme ssd</span><br><span class="line">nvme connect -t rdma -q nvme-subsystem-name -n nvme-subsystem-name  -a 192.168.13.147 -s 4420</span><br><span class="line"></span><br><span class="line">#显示NVMe盘</span><br><span class="line">lsblk</span><br><span class="line">NAME    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda       8:0    0  1.1T  0 disk</span><br><span class="line">├─sda1    8:1    0    8G  0 part /</span><br><span class="line">├─sda2    8:2    0    1K  0 part</span><br><span class="line">├─sda5    8:5    0    4G  0 part [SWAP]</span><br><span class="line">├─sda6    8:6    0    8G  0 part /usr</span><br><span class="line">├─sda7    8:7    0    8G  0 part /var</span><br><span class="line">├─sda8    8:8    0    4G  0 part /tmp</span><br><span class="line">└─sda9    8:9    0  1.1T  0 part /home</span><br><span class="line">nvme0n1 259:1    0  1.5T  0 disk</span><br><span class="line"></span><br><span class="line">#与target 端 nvme ssd 断开连接</span><br><span class="line">nvme disconnect -n nvme-subsystem-name</span><br></pre></td></tr></table></figure></p>
<h2 id="安装配置过程中遇到的问题"><a href="#安装配置过程中遇到的问题" class="headerlink" title="安装配置过程中遇到的问题"></a>安装配置过程中遇到的问题</h2><h3 id="1-如何配置多个NVMe盘的问题"><a href="#1-如何配置多个NVMe盘的问题" class="headerlink" title="1. 如何配置多个NVMe盘的问题"></a>1. 如何配置多个NVMe盘的问题</h3><p>一般的配置文档都是只映射了一个NVMe盘到远端客户端，然后自己用如下两种思路尝试摸索：</p>
<ul>
<li>按单个NVMe盘的操作思路来，多个盘就做多次，也就是这种思路创建了多个NVMe子系统，然后再客户端做多次nvme connect</li>
<li>只做单个子系统，在单个子系统下面创建多个命名空间（相当于每个命名空间对应一个NVMe盘）</li>
</ul>
<p>实践发现第一个思路操作没有成功，按第二个思路操作成功了！不过在操作的时候需要注意，不同的盘需要对应不同的端口。<br>最后因为都是一个子系统，所以connect的时候就不用输端口了，命令如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvme connect -t rdma -q ahnselina_test -n ahnselina_test -a x.x.x.x</span><br></pre></td></tr></table></figure><br>请把上面命令中的”ahnselina_test”换成你自己创建的子系统名称，x.x.x.x替换成你那台机器上的IP。</p>
<h3 id="2-使用nvme-connect遇到的问题"><a href="#2-使用nvme-connect遇到的问题" class="headerlink" title="2. 使用nvme connect遇到的问题"></a>2. 使用nvme connect遇到的问题</h3><p>使用nvme connect遇到报”Failed to write to /dev/nvme-fabrics: Input/output error”错误。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvme connect -t rdma -q ahnselina_test -n ahnselinatest -a x.x.x.x</span><br><span class="line">Failed to write to /dev/nvme-fabrics: Input/output error</span><br></pre></td></tr></table></figure><br>错误原因：通过看dmesg -T｜ grep nvme发现是自己把nqn名称打错了，尴尬，把名称该正确即可:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvme connect -t rdma -q ahnselina_test -n ahnselina_test -a x.x.x.x</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://community.mellanox.com/s/article/howto-install-mlnx-ofed-driver">HowTo Install MLNX_OFED Driver</a></p>
<p><a href="https://community.mellanox.com/s/article/howto-configure-nvme-over-fabrics">HowTo Configure NVMe over Fabrics</a></p>
<p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/8/html/managing_storage_devices/overview-of-nvme-over-fabric-devicesmanaging-storage-devices">NVME OVER FABRIC 设备概述</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/345609031">NVMe over RoCE 初探</a><br><a href="https://www.sdnlab.com/24673.html">浅析RoCE网络技术</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>NVMe</tag>
        <tag>NVMeoF</tag>
        <tag>RDMA</tag>
      </tags>
  </entry>
  <entry>
    <title>NVMe over RDMA的环境上安装ZFS</title>
    <url>/2021/10/28/NVMe%20over%20RDMA%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8A%E5%AE%89%E8%A3%85ZFS/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/17/IhdUG4.png" alt=""><br><span id="more"></span></p>
<p>本文主要介绍将NVMe盘通过RDMA映射到远端机器后，再在该机器上安装ZFS。<br>如何安装NVMe over RDMA，请参考上一篇文章：<a href="http://www.a-programmer.top/2021/10/27/NVMe%20over%20RDMA%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">NVMe over RDMA的安装配置</a>。</p>
<p>说明：本文所有命令执行的系统为debian。</p>
<h2 id="安装ZFS"><a href="#安装ZFS" class="headerlink" title="安装ZFS"></a>安装ZFS</h2><p>直接使用”apt install -y zfsutils-linux”安装ZFS,会出现问题，详细解决办法请参考本文后面的<strong>遇到的错误及解决办法</strong>。</p>
<p>可直接按如下步骤进行安装：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. apt-get install dpkg-dev linux-headers-$(uname -r) linux-image-amd64</span><br><span class="line">2. apt-get install zfs-dkms zfsutils-linux</span><br><span class="line">3. modprobe zfs</span><br></pre></td></tr></table></figure></p>
<h2 id="创建存储池"><a href="#创建存储池" class="headerlink" title="创建存储池"></a>创建存储池</h2><h3 id="创建ZFS存储池（普通存储池，相当于RAID0，无冗余）"><a href="#创建ZFS存储池（普通存储池，相当于RAID0，无冗余）" class="headerlink" title="创建ZFS存储池（普通存储池，相当于RAID0，无冗余）"></a>创建ZFS存储池（普通存储池，相当于RAID0，无冗余）</h3><p>1.机器上要有相应的硬盘，本文以NVMe盘为例，nvme0n1和nvme1n1。<br>2.查看存储池状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool status   </span><br><span class="line">no pools available</span><br></pre></td></tr></table></figure>
<p>3.创建ZFS存储池，以nvme0n1和nvme1n1为例：<br>创建好后，用zpool status查看是如下结果，如遇到错误请参考后面的解决办法。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create mypool nvme0n1 nvme1n1</span><br><span class="line"># zpool status</span><br><span class="line">  pool: mypool</span><br><span class="line"> state: ONLINE</span><br><span class="line">  scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">	NAME        STATE     READ WRITE CKSUM</span><br><span class="line">	mypool      ONLINE       0     0     0</span><br><span class="line">	  nvme0n1   ONLINE       0     0     0</span><br><span class="line">	  nvme1n1   ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure><br>使用ZFS创建这种简单的池意义不大，这相当于没有冗余（类似RAID0）</p>
<p>创建下一个存储池前，记得清理存储池<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool destroy mypool</span><br></pre></td></tr></table></figure></p>
<h3 id="一个简单的镜像池"><a href="#一个简单的镜像池" class="headerlink" title="一个简单的镜像池"></a>一个简单的镜像池</h3><p>还是使用nvme0n1和nvme1n1两个盘，创建一个简单的镜像池：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create mypool mirror nvme0n1 nvme1n1</span><br><span class="line"># zpool status</span><br><span class="line">  pool: mypool</span><br><span class="line"> state: ONLINE</span><br><span class="line">  scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">	NAME         STATE     READ WRITE CKSUM</span><br><span class="line">	mypool       ONLINE       0     0     0</span><br><span class="line">	  mirror-0   ONLINE       0     0     0</span><br><span class="line">	    nvme0n1  ONLINE       0     0     0</span><br><span class="line">	    nvme1n1  ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure></p>
<h3 id="创建RAIDZ2的存储池"><a href="#创建RAIDZ2的存储池" class="headerlink" title="创建RAIDZ2的存储池"></a>创建RAIDZ2的存储池</h3><p>RAIDZ-2至少需要4块硬盘，RAIDZ-2能容忍最多两盘故障。<br>例子中使用4块NVMe盘：nvme0n1 nvme1n1 nvme2n1 nvme3n1。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool create zfstest raidz2 nvme0n1 nvme1n1 nvme2n1 nvme3n1</span><br><span class="line">root@cld-mon1-12002:~# zpool status</span><br><span class="line">  pool: zfstest</span><br><span class="line"> state: ONLINE</span><br><span class="line">  scan: none requested</span><br><span class="line">config:</span><br><span class="line"></span><br><span class="line">	NAME         STATE     READ WRITE CKSUM</span><br><span class="line">	zfstest      ONLINE       0     0     0</span><br><span class="line">	  raidz2-0   ONLINE       0     0     0</span><br><span class="line">	    nvme0n1  ONLINE       0     0     0</span><br><span class="line">	    nvme1n1  ONLINE       0     0     0</span><br><span class="line">	    nvme2n1  ONLINE       0     0     0</span><br><span class="line">	    nvme3n1  ONLINE       0     0     0</span><br><span class="line"></span><br><span class="line">errors: No known data errors</span><br></pre></td></tr></table></figure></p>
<h2 id="对存储池创建数据集（创建文件系统）"><a href="#对存储池创建数据集（创建文件系统）" class="headerlink" title="对存储池创建数据集（创建文件系统）"></a>对存储池创建数据集（创建文件系统）</h2><p>使用命令查看上面创建的zfstest池：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs list</span><br><span class="line">NAME      USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">zfstest   114K  2.80T  32.9K  /zfstest</span><br></pre></td></tr></table></figure><br>创建数据集test：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs create zfstest/test</span><br><span class="line"># zfs list</span><br><span class="line">NAME           USED  AVAIL  REFER  MOUNTPOINT</span><br><span class="line">zfstest        151K  2.80T  32.9K  /zfstest</span><br><span class="line">zfstest/test  32.9K  2.80T  32.9K  /zfstest/test</span><br></pre></td></tr></table></figure></p>
<h2 id="销毁zfs数据集"><a href="#销毁zfs数据集" class="headerlink" title="销毁zfs数据集"></a>销毁zfs数据集</h2><p>销毁zfs数据集使用”zfs destroy”命令，下面的例子中把数据集tabriz销毁了：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs destroy tank/home/tabriz</span><br></pre></td></tr></table></figure><br><strong>注意</strong>：如果遇到要销毁的数据集正忙，无法umount，可以使用-f参数强制销毁。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zfs destroy tank/home/ahrens</span><br><span class="line">cannot unmount &#x27;tank/home/ahrens&#x27;: Device busy</span><br><span class="line"></span><br><span class="line"># zfs destroy -f tank/home/ahrens</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>另外，我犯了一个错误，就是在zfstest/test/目录下执行“zfs destory zfstest/test”，然后一直报<br>“umount: /zfstest/test: target is busy.<br>cannot unmount ‘/zfstest/test’: umount failed”，加-f参数也不行，其实不在那个目录就好了。</p>
</blockquote>
<h2 id="FIO测试其性能"><a href="#FIO测试其性能" class="headerlink" title="FIO测试其性能"></a>FIO测试其性能</h2><h3 id="大文件单线程写"><a href="#大文件单线程写" class="headerlink" title="大文件单线程写"></a>大文件单线程写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@XXX:/zfstest/test# fio --group_reporting --time_based   --norandommap --name=big-file-single-write --directory=/zfstest/test --rw=write --bs=4M --size=10G --time_based --runtime=300  --numjobs=1 --output big-file-single-write.txt</span><br><span class="line">root@XXX:/zfstest/test# 7MiB/s][w=736 IOPS][eta 00m:00s]</span><br><span class="line">root@XXX:/zfstest/test#</span><br><span class="line">root@XXX:/zfstest/test# cat big-file-single-write.txt</span><br><span class="line">big-file-single-write: (g=0): rw=write, bs=(R) 4096KiB-4096KiB, (W) 4096KiB-4096KiB, (T) 4096KiB-4096KiB, ioengine=psync, iodepth=1</span><br><span class="line">fio-3.12</span><br><span class="line">Starting 1 process</span><br><span class="line">big-file-single-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line"></span><br><span class="line">big-file-single-write: (groupid=0, jobs=1): err= 0: pid=1769227: Thu Oct 14 20:25:16 2021</span><br><span class="line">  write: IOPS=692, BW=2771MiB/s (2906MB/s)(812GiB/300002msec); 0 zone resets</span><br><span class="line">    clat (usec): min=924, max=108499, avg=1342.66, stdev=639.84</span><br><span class="line">     lat (usec): min=973, max=108576, avg=1441.28, stdev=648.02</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1012],  5.00th=[ 1074], 10.00th=[ 1123], 20.00th=[ 1188],</span><br><span class="line">     | 30.00th=[ 1221], 40.00th=[ 1270], 50.00th=[ 1303], 60.00th=[ 1336],</span><br><span class="line">     | 70.00th=[ 1385], 80.00th=[ 1450], 90.00th=[ 1565], 95.00th=[ 1696],</span><br><span class="line">     | 99.00th=[ 2278], 99.50th=[ 2606], 99.90th=[ 3392], 99.95th=[ 3654],</span><br><span class="line">     | 99.99th=[ 4490]</span><br><span class="line">   bw (  MiB/s): min= 1944, max= 3080, per=99.99%, avg=2770.98, stdev=141.42, samples=600</span><br><span class="line">   iops        : min=  486, max=  770, avg=692.71, stdev=35.36, samples=600</span><br><span class="line">  lat (usec)   : 1000=0.51%</span><br><span class="line">  lat (msec)   : 2=97.68%, 4=1.78%, 10=0.02%, 250=0.01%</span><br><span class="line">  cpu          : usr=7.11%, sys=90.80%, ctx=61584, majf=0, minf=74187</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, &gt;=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     issued rwts: total=0,207849,0,0 short=0,0,0,0 dropped=0,0,0,0</span><br><span class="line">     latency   : target=0, window=0, percentile=100.00%, depth=1</span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">  WRITE: bw=2771MiB/s (2906MB/s), 2771MiB/s-2771MiB/s (2906MB/s-2906MB/s), io=812GiB (872GB), run=300002-300002msec</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@XXX# fio --group_reporting --time_based  --iodepth=32 --norandommap --name=big-file-single-write --directory=/zfstest/test --rw=write --bs=4M --size=10G --time_based --runtime=300  --numjobs=1 --output big-file-single-write.txt</span><br><span class="line">root@XXX:# iB/s][w=672 IOPS][eta 00m:00s]</span><br><span class="line">root@XXX:#</span><br><span class="line">root@XX:/# cat big-file-single-write.txt</span><br><span class="line">big-file-single-write: (g=0): rw=write, bs=(R) 4096KiB-4096KiB, (W) 4096KiB-4096KiB, (T) 4096KiB-4096KiB, ioengine=psync, iodepth=32</span><br><span class="line">fio-3.12</span><br><span class="line">Starting 1 process</span><br><span class="line"></span><br><span class="line">big-file-single-write: (groupid=0, jobs=1): err= 0: pid=3774285: Thu Oct 14 20:43:03 2021</span><br><span class="line">  write: IOPS=685, BW=2742MiB/s (2875MB/s)(803GiB/300001msec); 0 zone resets</span><br><span class="line">    clat (usec): min=924, max=103373, avg=1357.26, stdev=552.14</span><br><span class="line">     lat (usec): min=979, max=103459, avg=1457.04, stdev=561.19</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[ 1029],  5.00th=[ 1090], 10.00th=[ 1139], 20.00th=[ 1205],</span><br><span class="line">     | 30.00th=[ 1237], 40.00th=[ 1287], 50.00th=[ 1319], 60.00th=[ 1352],</span><br><span class="line">     | 70.00th=[ 1401], 80.00th=[ 1467], 90.00th=[ 1565], 95.00th=[ 1713],</span><br><span class="line">     | 99.00th=[ 2278], 99.50th=[ 2671], 99.90th=[ 3490], 99.95th=[ 3851],</span><br><span class="line">     | 99.99th=[ 4883]</span><br><span class="line">   bw (  MiB/s): min= 2104, max= 3027, per=100.00%, avg=2741.44, stdev=122.83, samples=599</span><br><span class="line">   iops        : min=  526, max=  756, avg=685.33, stdev=30.71, samples=599</span><br><span class="line">  lat (usec)   : 1000=0.34%</span><br><span class="line">  lat (msec)   : 2=97.88%, 4=1.75%, 10=0.03%, 250=0.01%</span><br><span class="line">  cpu          : usr=6.98%, sys=91.12%, ctx=58822, majf=0, minf=66995</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, &gt;=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     issued rwts: total=0,205618,0,0 short=0,0,0,0 dropped=0,0,0,0</span><br><span class="line">     latency   : target=0, window=0, percentile=100.00%, depth=32</span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">  WRITE: bw=2742MiB/s (2875MB/s), 2742MiB/s-2742MiB/s (2875MB/s-2875MB/s), io=803GiB (862GB), run=300001-300001msec</span><br></pre></td></tr></table></figure>
<h3 id="大文件并发写"><a href="#大文件并发写" class="headerlink" title="大文件并发写"></a>大文件并发写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@XXX:/zfstest/test# fio --group_reporting --time_based --iodepth=32  --norandommap --name=big-file-multi-write --directory=/zfstest/test/ --rw=write --bs=4M --size=10G --time_based --runtime=300  --numjobs=16 --output big-file-multi-write.txt</span><br><span class="line">root@XXX:/zfstest/test# 3367MiB/s][w=841 IOPS][eta 00m:00s]</span><br><span class="line">root@XXX:/zfstest/test# cat big-file-multi-write.txt</span><br><span class="line">big-file-multi-write: (g=0): rw=write, bs=(R) 4096KiB-4096KiB, (W) 4096KiB-4096KiB, (T) 4096KiB-4096KiB, ioengine=psync, iodepth=32</span><br><span class="line">...</span><br><span class="line">fio-3.12</span><br><span class="line">Starting 16 processes</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line">big-file-multi-write: Laying out IO file (1 file / 10240MiB)</span><br><span class="line"></span><br><span class="line">big-file-multi-write: (groupid=0, jobs=16): err= 0: pid=1473793: Thu Oct 14 20:59:04 2021</span><br><span class="line">  write: IOPS=834, BW=3339MiB/s (3501MB/s)(978GiB/300016msec); 0 zone resets</span><br><span class="line">    clat (usec): min=1428, max=162761, avg=18864.46, stdev=6169.03</span><br><span class="line">     lat (usec): min=1668, max=163066, avg=19166.41, stdev=6189.02</span><br><span class="line">    clat percentiles (usec):</span><br><span class="line">     |  1.00th=[14484],  5.00th=[15139], 10.00th=[15533], 20.00th=[15926],</span><br><span class="line">     | 30.00th=[16450], 40.00th=[17171], 50.00th=[17433], 60.00th=[17957],</span><br><span class="line">     | 70.00th=[18220], 80.00th=[19006], 90.00th=[22414], 95.00th=[30278],</span><br><span class="line">     | 99.00th=[49021], 99.50th=[58459], 99.90th=[69731], 99.95th=[73925],</span><br><span class="line">     | 99.99th=[83362]</span><br><span class="line">   bw (  KiB/s): min=147456, max=589824, per=6.25%, avg=213576.59, stdev=22303.40, samples=9595</span><br><span class="line">   iops        : min=   36, max=  144, avg=52.10, stdev= 5.45, samples=9595</span><br><span class="line">  lat (msec)   : 2=0.03%, 4=0.08%, 10=0.20%, 20=85.23%, 50=13.51%</span><br><span class="line">  lat (msec)   : 100=0.94%, 250=0.01%</span><br><span class="line">  cpu          : usr=1.62%, sys=10.60%, ctx=8083125, majf=0, minf=172228</span><br><span class="line">  IO depths    : 1=100.0%, 2=0.0%, 4=0.0%, 8=0.0%, 16=0.0%, 32=0.0%, &gt;=64=0.0%</span><br><span class="line">     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%</span><br><span class="line">     issued rwts: total=0,250401,0,0 short=0,0,0,0 dropped=0,0,0,0</span><br><span class="line">     latency   : target=0, window=0, percentile=100.00%, depth=32</span><br><span class="line"></span><br><span class="line">Run status group 0 (all jobs):</span><br><span class="line">  WRITE: bw=3339MiB/s (3501MB/s), 3339MiB/s-3339MiB/s (3501MB/s-3501MB/s), io=978GiB (1050GB), run=300016-300016msec</span><br></pre></td></tr></table></figure>
<h2 id="遇到的错误及解决办法"><a href="#遇到的错误及解决办法" class="headerlink" title="遇到的错误及解决办法"></a>遇到的错误及解决办法</h2><h3 id="使用zpool-status命令，报“ZFS-modules-are-not-loaded”错误"><a href="#使用zpool-status命令，报“ZFS-modules-are-not-loaded”错误" class="headerlink" title="使用zpool status命令，报“ZFS modules are not loaded”错误"></a>使用zpool status命令，报“ZFS modules are not loaded”错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool status</span><br><span class="line">The ZFS modules are not loaded.</span><br><span class="line">Try running &#x27;/sbin/modprobe zfs&#x27; as root to load them.</span><br></pre></td></tr></table></figure>
<p><strong>解决办法</strong>：使用命令”modprobe zfs”加载zfs模块，不过很可能会遇到下一个的问题，把下面的那个问题解决了，该问题也就解决了，详情看下个问题的解决办法</p>
<h3 id="使用“modprobe-zfs”报“Module-zfs-not-found-in-directory”错误"><a href="#使用“modprobe-zfs”报“Module-zfs-not-found-in-directory”错误" class="headerlink" title="使用“modprobe zfs”报“Module zfs not found in directory”错误"></a>使用“modprobe zfs”报“Module zfs not found in directory”错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~# modprobe zfs</span><br><span class="line">modprobe: FATAL: Module zfs not found in directory /lib/modules/4.19.0-10-amd64</span><br></pre></td></tr></table></figure>
<p><strong>解决办法</strong>：需要先安装内核相关的头文件，然后在重新安装zfs相关组件，具体步骤如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. apt-get install dpkg-dev linux-headers-$(uname -r) linux-image-amd64</span><br><span class="line">2. apt-get install zfs-dkms zfsutils-linux</span><br><span class="line">3. modprobe zfs</span><br></pre></td></tr></table></figure><br>这样，该问题解决，上一个问题也就解决了。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool status</span><br><span class="line">no pools available</span><br></pre></td></tr></table></figure></p>
<h3 id="创建存储池遇到”xx-is-in-use-and-contains-a-LVM2-member-filesystem”错误"><a href="#创建存储池遇到”xx-is-in-use-and-contains-a-LVM2-member-filesystem”错误" class="headerlink" title="创建存储池遇到”xx is in use and contains a LVM2_member filesystem”错误"></a>创建存储池遇到”xx is in use and contains a LVM2_member filesystem”错误</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># zpool create mypool nvme0n1 nvme1n1</span><br><span class="line">/dev/nvme0n1 is in use and contains a LVM2_member filesystem.</span><br><span class="line">/dev/nvme1n1 is in use and contains a LVM2_member filesystem.</span><br></pre></td></tr></table></figure>
<p><strong>解决办法</strong>：这是因为我原先使用该环境搭建了Ceph并且已经使用了那两个盘,清理掉相应的环境，并删除对应的LVM即可。删除LVM可以参考该文章<a href="http://www.a-programmer.top/2021/10/03/关于LVM的概念及相关操作/">关于LVM的概念及相关操作</a><br><img src="https://z3.ax1x.com/2021/11/17/IhaWD0.png" alt=""></p>
<p>删除卷组vg：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in `pvs | grep ceph | awk &#x27;&#123; print $2 &#125;&#x27;`; do vgremove -y $i; done</span><br></pre></td></tr></table></figure><br>删除物理卷：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in `pvs | grep dev | awk &#x27;&#123; print $1 &#125;&#x27;`; do pvremove -y $i; done</span><br></pre></td></tr></table></figure></p>
<h3 id="cannot-unmount-‘tank-home-ahrens’-Device-busy"><a href="#cannot-unmount-‘tank-home-ahrens’-Device-busy" class="headerlink" title="cannot unmount ‘tank/home/ahrens’: Device busy"></a>cannot unmount ‘tank/home/ahrens’: Device busy</h3><p><strong>解决办法</strong>：  </p>
<ol>
<li>加 -f 参数  </li>
<li>如果还不行看看是不是自己正在那个要umount的目录下，换到其他目录再执行umount即可。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.a-programmer.top/2021/10/03/关于LVM的概念及相关操作/">关于LVM的概念及相关操作</a></p>
<p><a href="https://www.escapelife.site/posts/caf259ea.html">在Linux上安装和使用ZFS</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ZFS</tag>
        <tag>NVMe</tag>
        <tag>NVMeoF</tag>
        <tag>RDMA</tag>
      </tags>
  </entry>
  <entry>
    <title>测试NVMe over RDMA上的ZFS遇到的问题</title>
    <url>/2021/10/29/%E6%B5%8B%E8%AF%95NVMe%20over%20RDMA%E4%B8%8A%E7%9A%84ZFS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/17/IIVnhT.png" alt=""><br><span id="more"></span></p>
<p>本文主要介绍在测试构建在NVMe over RDMA上的ZFS遇到的问题及解决方法。</p>
<h2 id="问题：contains-a-corrupt-primary-EFI-label"><a href="#问题：contains-a-corrupt-primary-EFI-label" class="headerlink" title="问题：contains a corrupt primary EFI label."></a>问题：contains a corrupt primary EFI label.</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool create nvme_over_rdma_zfs_pool raidz2 nvme0n1 nvme0n2 nvme0n3 nvme0n4 nvme1n1 nvme1n2</span><br><span class="line">invalid vdev specification</span><br><span class="line">use &#x27;-f&#x27; to override the following errors:</span><br><span class="line">/dev/nvme0n2 contains a corrupt primary EFI label.</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wipefs -a /dev/nvme0n2</span><br></pre></td></tr></table></figure></p>
<h2 id="问题：使用nvme-delete-ns-dev-nvme2n1删除该盘的ns之后，使用lsblk看不见该盘了"><a href="#问题：使用nvme-delete-ns-dev-nvme2n1删除该盘的ns之后，使用lsblk看不见该盘了" class="headerlink" title="问题：使用nvme delete-ns /dev/nvme2n1删除该盘的ns之后，使用lsblk看不见该盘了"></a>问题：使用nvme delete-ns /dev/nvme2n1删除该盘的ns之后，使用lsblk看不见该盘了</h2><p><strong>解决方法</strong>：<br><a href="https://www.ibm.com/docs/en/linux-on-systems?topic=drive-deleting-stray-nvme-namespaces-nvme">https://www.ibm.com/docs/en/linux-on-systems?topic=drive-deleting-stray-nvme-namespaces-nvme</a></p>
<h2 id="问题：由于前面模拟拔盘和重新插盘后，那个盘符发生了变化，所以导致通过RDMA映射到本地客户端创池失败"><a href="#问题：由于前面模拟拔盘和重新插盘后，那个盘符发生了变化，所以导致通过RDMA映射到本地客户端创池失败" class="headerlink" title="问题：由于前面模拟拔盘和重新插盘后，那个盘符发生了变化，所以导致通过RDMA映射到本地客户端创池失败"></a>问题：由于前面模拟拔盘和重新插盘后，那个盘符发生了变化，所以导致通过RDMA映射到本地客户端创池失败</h2><p><strong>解决方法</strong>：尝试了想修改nvme子系统中盘符，但是nvme子系统此时不让进行修改，想卸载nvmet也不行。<br>最后发现重启之后就可以了。</p>
<h2 id="问题：重启后安装的nvme相关驱动不见了，自己做的设置也消失了（这类加载驱动后开机重启后没有驱动的解决方法）"><a href="#问题：重启后安装的nvme相关驱动不见了，自己做的设置也消失了（这类加载驱动后开机重启后没有驱动的解决方法）" class="headerlink" title="问题：重启后安装的nvme相关驱动不见了，自己做的设置也消失了（这类加载驱动后开机重启后没有驱动的解决方法）"></a>问题：重启后安装的nvme相关驱动不见了，自己做的设置也消失了（这类加载驱动后开机重启后没有驱动的解决方法）</h2><p><strong>解决方法</strong>：为了使命令行中执行insmod命令安装的驱动能在重启之后还有的解决方法大致有一下两种方法：<br>（1）直接编译内核，把想安装的驱动在编译内核的时候给编译进去，这种方法比较麻烦，花的时候也比较的多，一般不采用这种方法（这种方法网上有很多资料可以参考）。<br>（2）这种方法比较简单：就是在启动脚本中加载模块，这样每次开机启动都自动加载相应的驱动模块。具体的方式如下：<br>      在文件/etc/rc.local中加载你想要的模块程序即可，比如我想再系统启动的时候自动给我完成：卸载r8169驱动、然后安装r8168驱动、同时重启网络服务器的工作，那么我在该文件中的exit 0 之前写如下的语句：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmmod r8169#（卸载相应的驱动）</span><br><span class="line"></span><br><span class="line">insmod /usr/src/r8168.ko#(这个是r8168.ko文件放的绝对路径)，这步是安装相应的驱动</span><br><span class="line"></span><br><span class="line">ifconfig eth0 down</span><br><span class="line"></span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><br>然后保存，重新启动reboot之后，系统就将自动完成我们想要的那几步工作。</p>
<p>在加载好驱动之后，还需要在脚本中执行自己想要做的设置！</p>
<p>加载NVME模块及NVME映射相关的配置：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">LOG=&quot;/var/log/nvme_over_rdma.log&quot;</span><br><span class="line">NVME_SUBSYSTEM_PATH=&quot;/sys/kernel/config/nvmet/subsystems/&quot;</span><br><span class="line">NVME_SUBSYSTEM_DIR=&quot;mon1_nvme&quot;</span><br><span class="line">NVME_PORT_PATH=&quot;/sys/kernel/config/nvmet/ports&quot;</span><br><span class="line">NAME_SPACE_NUM=11</span><br><span class="line">PORT=4420</span><br><span class="line"></span><br><span class="line">echo &quot;$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)  start installing nvme driver...&quot; | tee -a $&#123;LOG&#125;</span><br><span class="line"></span><br><span class="line"># 加载模块</span><br><span class="line">modprobe nvmet</span><br><span class="line">modprobe nvmet-rdma</span><br><span class="line">modprobe nvme-rdma</span><br><span class="line"></span><br><span class="line"># 创建nvme的subsystem</span><br><span class="line">echo &quot;$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)  create the subsystem of nvme.&quot; | tee -a $&#123;LOG&#125;</span><br><span class="line">mkdir /sys/kernel/config/nvmet/subsystems/$NVME_SUBSYSTEM_DIR</span><br><span class="line">cd /sys/kernel/config/nvmet/subsystems/$NVME_SUBSYSTEM_DIR</span><br><span class="line">echo 1 &gt; attr_allow_any_host</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">j=1;</span><br><span class="line">for i in `lsscsi | grep nvme | awk &#x27;&#123;print $4&#125;&#x27;`;</span><br><span class="line">do</span><br><span class="line">    # 创建命名空间</span><br><span class="line">    echo &quot;$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)  create namespace $&#123;NAME_SPACE_NUM&#125;.&quot; | tee -a $&#123;LOG&#125;;</span><br><span class="line">    mkdir namespaces/$NAME_SPACE_NUM;</span><br><span class="line">    # 设置NVME盘的设备路径</span><br><span class="line">    echo &quot;$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)  set the NVMe disk device path: $i.&quot; | tee -a $&#123;LOG&#125;;</span><br><span class="line">    echo -n $i &gt; namespaces/$&#123;NAME_SPACE_NUM&#125;/device_path;</span><br><span class="line">    echo 1 &gt; namespaces/$&#123;NAME_SPACE_NUM&#125;/enable;</span><br><span class="line">    # 创建NVME的port</span><br><span class="line">    echo &quot;$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)  create the NVMe&#x27;s port:$&#123;PORT&#125;.&quot; | tee -a $&#123;LOG&#125;;</span><br><span class="line">    mkdir $&#123;NVME_PORT_PATH&#125;/$&#123;j&#125;;</span><br><span class="line"></span><br><span class="line">    # 设置rdma的ip</span><br><span class="line">    echo `ifconfig bond1  | grep inet | awk &#x27;&#123;print $2&#125;&#x27;` &gt; $&#123;NVME_PORT_PATH&#125;/$&#123;j&#125;/addr_traddr;</span><br><span class="line">    echo rdma &gt; $&#123;NVME_PORT_PATH&#125;/$&#123;j&#125;/addr_trtype;</span><br><span class="line">    echo $&#123;PORT&#125; &gt; $&#123;NVME_PORT_PATH&#125;/$&#123;j&#125;/addr_trsvcid;</span><br><span class="line">    echo ipv4 &gt; $&#123;NVME_PORT_PATH&#125;/$&#123;j&#125;/addr_adrfam;</span><br><span class="line">    ln -s $&#123;NVME_SUBSYSTEM_PATH&#125;/$&#123;NVME_SUBSYSTEM_DIR&#125; $&#123;NVME_PORT_PATH&#125;/$&#123;j&#125;/subsystems/$&#123;NVME_SUBSYSTEM_DIR&#125;;</span><br><span class="line">    ((j++));</span><br><span class="line">    ((PORT++));</span><br><span class="line">    ((NAME_SPACE_NUM++));</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line">echo &quot;$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)  installed nvme success.&quot; | tee -a $&#123;LOG&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="NVMe-over-RDMA的ZFS客户端重启后，ZFS存储池没了"><a href="#NVMe-over-RDMA的ZFS客户端重启后，ZFS存储池没了" class="headerlink" title="NVMe over RDMA的ZFS客户端重启后，ZFS存储池没了"></a>NVMe over RDMA的ZFS客户端重启后，ZFS存储池没了</h2><p><strong>解决方法</strong>：<br>需要重新加载<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modprobe nvme-rdma</span><br></pre></td></tr></table></figure><br>然后尝试重新创池发现”is part of potentially active pool ‘nvme_over_rdma_zfs_pool’”类型错误，其实是正常的，那些盘原本已经被我创建了存储池，不让创建是对的，所以解决办法是恢复原先创建的那个存储池。</p>
<p>恢复方法为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool import -n nvme_over_rdma_zfs_pool -F</span><br></pre></td></tr></table></figure><br>把上面的存储池的名字换成你自己的要恢复的存储池名字。<br><a href="https://www.reddit.com/r/zfs/comments/a5jdkp/help_trying_to_recreate_an_existing_pool/ebmxzlw/">[HELP] Trying to recreate an existing pool</a></p>
<h2 id="通过NVMe-over-RDMA映射组建的ZFS的硬盘盘符，在重启后发生变化"><a href="#通过NVMe-over-RDMA映射组建的ZFS的硬盘盘符，在重启后发生变化" class="headerlink" title="通过NVMe over RDMA映射组建的ZFS的硬盘盘符，在重启后发生变化"></a>通过NVMe over RDMA映射组建的ZFS的硬盘盘符，在重启后发生变化</h2><p>通过NVMe over RDMA映射到一个客户端上组建的ZFS，重启后端NVMe盘的机器后，盘符会发生改变，然后ZFS存储池中会检测到原来的那个盘符故障，然后也没法用”zpool replace”命令。</p>
<p><strong>解决方法</strong>：</p>
<ol>
<li>重启客户端(即创建ZFS存储池的那台机器) </li>
<li>重新加载nvme-rdma </li>
<li><strong>使用“nvme connect xxx”命令重新连接其他机器上的NVMe盘</strong></li>
<li><strong>重新import存储池</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zpool import -n nvme_over_rdma_zfs_pool -F</span><br></pre></td></tr></table></figure>
在创建ZFS存储池的时候，最佳实践是不要使用/dev/sda这样的字盘符来创建存储池，可以使用”/dev/disk/by-id/xxx”这样字独一无二的标识符来创池。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/liangxanhai/article/details/7748271">加载驱动后开机重启后没有驱动的解决方法</a></p>
<p><a href="https://www.reddit.com/r/zfs/comments/a5jdkp/help_trying_to_recreate_an_existing_pool/ebmxzlw/">[HELP] Trying to recreate an existing pool</a></p>
<p><a href="https://www.reddit.com/r/zfs/comments/gh4svd/zpool_lost_after_reboot/">zpool lost after reboot</a></p>
<p><a href="https://askubuntu.com/questions/404172/zpools-dont-automatically-mount-after-boot">zpools don’t automatically mount after boot</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ZFS</tag>
        <tag>NVMe</tag>
        <tag>NVMeoF</tag>
        <tag>RDMA</tag>
      </tags>
  </entry>
  <entry>
    <title>NVMe namespace</title>
    <url>/2021/10/30/NVMe%20namespace/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/19/IqmWqK.png" alt=""><br><span id="more"></span></p>
<p>本文主要介绍NVMe namespace。阅读完本文后，你会了解NVMe中的namespace概念，知道其作用及如何管理，并且可以了解常用的命令。</p>
<h2 id="什么是NVMe-namespace"><a href="#什么是NVMe-namespace" class="headerlink" title="什么是NVMe namespace"></a>什么是NVMe namespace</h2><p>NVMe 命名空间，<strong>不是块的物理隔离</strong>，而是可由主机软件寻址的逻辑块的隔离。</p>
<p>主机软件希望将NVMe SSD分解为多个名称空间的原因有很多:为了逻辑隔离、多租户、安全隔离(每个名称空间加密)、为了恢复目的对名称空间进行写保护、为了提高写性能和持久性而进行的overprovisioning等等。</p>
<h2 id="命名空间-namespace-大小、容量和使用量"><a href="#命名空间-namespace-大小、容量和使用量" class="headerlink" title="命名空间(namespace)大小、容量和使用量"></a>命名空间(namespace)大小、容量和使用量</h2><p>命名空间的数据结构包含相关的字段–大小，容量和使用量：</p>
<ul>
<li>命名空间大小（NSZE）字段定义了命名空间在逻辑块中的总大小(LBA 0到n-1)。</li>
<li>命名空间容量（NCAP）字段定义了在任何时间点可以分配的逻辑块的最大数目。</li>
<li>命名空间使用量（NUSE）字段定义命名空间中当前分配的逻辑块的数量。这允许主机软件记录设备是如何响应deallocate命令的。在格式化之后，期望是这个值为零(没有使用量)，但在写入之后，使用量会增加，直到收到一个deallocate命令(有时称为“TRIM”)。</li>
</ul>
<h2 id="nvme-id命令包含了命名空间-namespace-能力的信息"><a href="#nvme-id命令包含了命名空间-namespace-能力的信息" class="headerlink" title="nvme id命令包含了命名空间(namespace)能力的信息"></a>nvme id命令包含了命名空间(namespace)能力的信息</h2><p>除了了解命名空间(namespace)的大小和使用情况外，另一个重要属性是LBA格式。这有助于主机软件知道发送到命名空间(namespace)的命令的最佳大小，硬盘是否支持保护信息(端到端数据保护)等。<br><img src="https://z3.ax1x.com/2021/11/19/Iqe53n.png" alt=""></p>
<center>该图是linux上报告“nvme id 命名空间”命令的输出的屏幕截图 </center>



<p><strong>注意</strong>:命名空间可以附加到两个或多个控制器，称为<strong>共享命名空间</strong>。相反，命名空间可能只附加到一个控制器，称为<strong>私有命名空间</strong>。两者都由主机决定。</p>
<h2 id="命名空间-namespace-如何管理"><a href="#命名空间-namespace-如何管理" class="headerlink" title="命名空间(namespace)如何管理"></a>命名空间(namespace)如何管理</h2><p>有两个命令集：<strong>管理命令集和attachment命令集</strong><br><u>命名空间管理</u>：Create, Modify, or Delete<br><u>命名空间attachment</u>：Attach or detach</p>
<ul>
<li>一旦主机创建了名称空间，它就不可见了。 </li>
<li>每个命名空间(namespace)由一个相应的NSID(命名空间ID)标识，每个命名空间(namespace)需要连接到子系统中的控制器。<br><img src="https://z3.ax1x.com/2021/11/19/IqmA4H.png" alt=""><center>图1:attached命名空间(Private和Shared)    NS A: Private，附加到控制器0   | NS B: Shared，附加到控制器0和1  | NS C z: Private，附加到控制器1 </center>


</li>
</ul>
<p>在图1中，主机创建了三个命名空间(namespace)。这不仅展示了NVMe子系统的抽象，还展示了如何利用私有和共享命名空间。每个命名空间被视为独立的目标设备。</p>
<h2 id="多命名空间"><a href="#多命名空间" class="headerlink" title="多命名空间"></a>多命名空间</h2><h3 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h3><p>一个用例可能涉及有两个或多个用户使用一个NVMe SSD。多个用户使用一个SSD会引起对服务一致性、专用性能和必须购买多个SSD的成本的担忧。这个时候namespace就起作用了，每个租户之间的逻辑隔离允许所有者根据租户的工作负载习惯处理每个命名空间。SSD仍然可以使用磨损级别，并在命名空间(namespace)之间共享用于垃圾收集的空闲区域。这与NVM Sets不同，在NVM Sets中，期望物理隔离，而不是命名空间(namespace)，后者是逻辑隔离。</p>
<p><img src="https://z3.ax1x.com/2021/11/19/IqmWqK.png" alt=""></p>
<center>图2:多租户用例 </center>

<h3 id="Overprovisioning"><a href="#Overprovisioning" class="headerlink" title="Overprovisioning"></a>Overprovisioning</h3><p>SSD将使用未写入的LBA和一定数量的空闲区域进行垃圾收集、损耗均衡等。通过减少与设备上NAND闪存数量相关的命名空间(namespace)大小(称为预留空间)，这将提高耐久性、性能和服务质量。<br><img src="https://z3.ax1x.com/2021/11/19/Iqn8eK.png" alt=""></p>
<center> 例子：3.84TB NVMe SSD，典型的空闲区域和命名空间大小 </center>                   

<ul>
<li>主机不能直接访问未供应的空间，而是允许控制器在垃圾收集、TRIMs等期间使用该空闲区域。 </li>
<li>预留空间不仅对一个命名空间(namespace)有用，在多个名称空间的情况下也是如此。每个名称空间的预留空间的百分比可以增加或减少，以满足每个名称空间遇到的最频繁的工作负载。</li>
</ul>
<p>使用nvme cli对命名空间(namespace)预留空间的步骤是：<br>1.从每个控制器分离所有命名空间(namespace)(spec建议先分离，但也可以删除)。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvme detach-ns /dev/nvme0 –namespace-id=1 –controllers=0</span><br></pre></td></tr></table></figure><br>2.删除已分离的每个命名空间(namespace)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvme delete-ns /dev/nvme0 –namespace-id=1</span><br></pre></td></tr></table></figure><br>3.根据需要的容量，创建一个新的命名空间(对每个命名空间重复)<br>从7.68TB变到6.14TB<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvme create-ns /dev/nvme0 –nsze 11995709440 –ncap 1199570940 –flbas 0 –dps 0 –nmic 0</span><br></pre></td></tr></table></figure><br>4.将新的命名空间附加到所需的控制器<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvme attach-ns /dev/nvme0 –namespace-id=1 –controllers=0</span><br></pre></td></tr></table></figure><br>5.置设备以使目标对主机可见。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvme reset /dev/nvme0</span><br><span class="line">nvme list</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://nvmexpress.org/resources/nvm-express-technology-features/nvme-namespaces/">https://nvmexpress.org/resources/nvm-express-technology-features/nvme-namespaces/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>namespace</tag>
        <tag>NVMe</tag>
      </tags>
  </entry>
  <entry>
    <title>vdbench安装与使用</title>
    <url>/2021/10/31/vdbench%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/24/oFE8v6.png" alt=""></p>
<span id="more"></span>
<p>本文介绍vdbench的安装与使用，本文使用的系统为debian。</p>
<h2 id="vdbench简介"><a href="#vdbench简介" class="headerlink" title="vdbench简介"></a>vdbench简介</h2><p>vdbench是一个 I/O 工作负载生成器，用于验证数据完整性和度量直接附加和网络连接的存储的性能。它是一个免费的工具，容易使用，而且常常用于测试和基准测试。<br>可以使用vdbench测试磁盘和文件系统的读写性能。<br>vdbench中常用的一些名词解释：<br>hd:</p>
<h2 id="vdbench的安装"><a href="#vdbench的安装" class="headerlink" title="vdbench的安装"></a>vdbench的安装</h2><p>1.下载Vdbench压缩包到所有client的“/home”目录下。<br>下载链接：<br><a href="https://www.oracle.com/webapps/redirect/signon?nexturl=https://download.oracle.com/otn/utilities_drivers/vdbench/vdbench50406.zip">https://www.oracle.com/webapps/redirect/signon?nexturl=https://download.oracle.com/otn/utilities_drivers/vdbench/vdbench50406.zip</a><br>注意：可能需要登录Oracle账号之类，没有的话就注册一个<br>2.进入所有客户端“/home”目录下解压Vdbench压缩包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home &amp;&amp; unzip vdbench50406.zip</span><br></pre></td></tr></table></figure>
<p>3.安装Java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install default-jre -q -y</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：vdbench的使用依赖java，若已安装，则可跳过本步骤。</p>
</blockquote>
<p>4.测试Vdbench是否工作正常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd vdbench50406</span><br><span class="line">chmod +x vdbench</span><br><span class="line">./vdbench -t</span><br></pre></td></tr></table></figure>
<p>若出现“Vdbench execution completed successfully”字段则说明Vdbench工作正常。</p>
<h2 id="Vdbench测试模型"><a href="#Vdbench测试模型" class="headerlink" title="Vdbench测试模型"></a>Vdbench测试模型</h2><p>Vdbench通过执行工作负载配置文件运行，选取其中一台客户端执行即可，该客户端会通过负载配置文件中的其他客户端IP地址等信息自动登录到其他客户端执行测试。</p>
<h3 id="创建Vdbench工作负载"><a href="#创建Vdbench工作负载" class="headerlink" title="创建Vdbench工作负载"></a>创建Vdbench工作负载</h3><p>本文以1个Ceph客户端为例，在任意一个客户端上（本文使用client1）创建vdbench 4KB随机读工作负载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /home/4k_randread.txt</span><br></pre></td></tr></table></figure>
<p>添加以下内容：<br>1.为所有测试机设置统一的默认参数，请根据实际情况修改Vdbench路径，此处为“/home”目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hd=default,vdbench=/home/vdbench50406,user=root,shell=ssh</span><br></pre></td></tr></table></figure>
<p>2.定义测试机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hd=hd1,system=client1</span><br></pre></td></tr></table></figure>
<p>相关参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>hd</td>
<td>测试机的名称</td>
</tr>
<tr>
<td>system</td>
<td>主机IP地址或主机名</td>
</tr>
</tbody>
</table>
<p>3.文件系统定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fsd=fsd1,anchor=/mnt/cephfs,depth=1,width=10,files=200,size=20m,shared=yes</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fsd</td>
<td>标识文件系统的名称</td>
</tr>
<tr>
<td>anchor</td>
<td>将在其中创建目录结构的父目录，此处为CephFS挂载点</td>
</tr>
<tr>
<td>depth</td>
<td>要在定位符下创建的级别数</td>
</tr>
<tr>
<td>width</td>
<td>要在定位符下创建的目录数</td>
</tr>
<tr>
<td>files</td>
<td>要在最低级别创建的文件数</td>
</tr>
<tr>
<td>size</td>
<td>创建的文件大小</td>
</tr>
<tr>
<td>shared</td>
<td>所有主机共享fsd参数</td>
</tr>
</tbody>
</table>
<p>4.文件系统工作负载定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fwd=default,xfersize=4k,fileio=random,fileselect=random,rdpct=100,threads=128 </span><br><span class="line">fwd=fwd1,fsd=fsd1,host=hd1 </span><br><span class="line">fwd=fwd2,fsd=fsd1,host=hd2 </span><br><span class="line">fwd=fwd3,fsd=fsd1,host=hd3</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fwd</td>
<td>default表示为所有工作负载设置统一的默认参数</td>
</tr>
<tr>
<td>xfersize</td>
<td>数据块大小</td>
</tr>
<tr>
<td>fileio</td>
<td>取值为random或sequential，表示文件IO将执行的方式</td>
</tr>
<tr>
<td>fileselect</td>
<td>取值为random或sequential，标识选择文件或目录的方式</td>
</tr>
<tr>
<td>rdpct</td>
<td>读写百分比 <br> rdpct=100表示只有读请求 <br> rdpct=0表示只有写请求</td>
</tr>
<tr>
<td>operation</td>
<td>取值为read或write，确定文件系统的操作</td>
</tr>
<tr>
<td>threads</td>
<td>此工作负载的并发线程数量</td>
</tr>
<tr>
<td>fsd</td>
<td>要使用的文件系统ID</td>
</tr>
<tr>
<td>host</td>
<td>要用于此工作负载的主机ID</td>
</tr>
</tbody>
</table>
<p>5.运行定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rd=rd1,fwd=fwd*,fwdrate=max,elapsed=600,interval=5</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>rd</td>
<td>表示运行的名称</td>
</tr>
<tr>
<td>fwd</td>
<td>要使用的文件系统工作负载ID</td>
</tr>
<tr>
<td>fwdrate</td>
<td>每秒执行的文件系统操作数量</td>
</tr>
<tr>
<td>elapsed</td>
<td>以秒为单位的运行持续时间</td>
</tr>
<tr>
<td>interval</td>
<td>终端报告间隔</td>
</tr>
</tbody>
</table>
<h3 id="执行vdbench测试"><a href="#执行vdbench测试" class="headerlink" title="执行vdbench测试"></a>执行vdbench测试</h3><blockquote>
<p>说明：<br>本文默认每台客户端的“/mnt/cephfs”目录已挂载Ceph文件系统，创建100个子目录，每个子目录下包含200个文件，每个文件20MB（可用dd写满20MB）。若实际测试时，客户端内无测试文件，可参考以下步骤创建文件以供测试。</p>
</blockquote>
<p>1.创建文件生成脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim create_file.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">for i in &#123;1..10&#125;</span><br><span class="line">do</span><br><span class="line">        cd /mnt/cephfs</span><br><span class="line">        mkdir $i</span><br><span class="line">        cd $i</span><br><span class="line">        seq 200 |xargs -i dd if=/dev/zero of=&#123;&#125; bs=1024000 count=20</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>2.执行脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh  create_file.sh</span><br></pre></td></tr></table></figure>
<p>以创建Vdbench工作负载创建好的4k_randread.txt负载为例进行说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home</span><br><span class="line">/home/vdbench50406/vdbench -f /home/4k_randread.txt -o 4k_randread_output</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<br>-f 指定待测试的工作负载配置文件；-o表示测试结果存放的目录。</p>
</blockquote>
<h3 id="收集测试结果"><a href="#收集测试结果" class="headerlink" title="收集测试结果"></a>收集测试结果</h3><p>测试完成后默认会在当前目录下创建一个名为“output”的目录存放测试结果，若测试命令中添加-o参数指定结果输出路径，则测试结果存放到该路径下。<br>以执行Vdbench测试的测试命令为例，会在“/home/4k_randread_output”目录下存放测试结果。<br>查看测试结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/4k_randread_output</span><br><span class="line">cat totals.html</span><br></pre></td></tr></table></figure>
<p>totals.html内容如下，其中i/o rate表示IOPS，MB/sec表示带宽，resp time表示时延：</p>
<p><img src="https://z3.ax1x.com/2021/11/24/oFAxu8.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://support.huaweicloud.com/tstg-kunpengsdss/kunpengcephfile_11_0008.html">Vdbench测试步骤</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>vdbench</tag>
      </tags>
  </entry>
  <entry>
    <title>初探JuiceFS</title>
    <url>/2021/11/05/%E5%88%9D%E6%8E%A2JuiceFS/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/28/omvzIH.png" alt=""></p>
<span id="more"></span>
<p>本文主要简要介绍一下JuiceFS，不错从本文开始又要开一个新坑了，计划后续还会出JuiceFS源码分析的文章。本文就打算先用JuiceFS的官方的资料来介绍一下JuiceFS，最后再说一下自己的一些想法。下面提到的核心特性、技术架构、应用场景均出自文末链接中的官方资料。</p>
<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ol>
<li><strong>POSIX 兼容</strong>：像本地文件系统一样使用，无缝对接已有应用，无业务侵入性；</li>
<li><strong>HDFS 兼容</strong>：完整兼容 <a href="https://juicefs.com/docs/zh/community/hadoop_java_sdk">HDFS API</a>，提供更强的元数据性能；</li>
<li><strong>S3 兼容</strong>：提供 <a href="https://juicefs.com/docs/zh/community/s3_gateway">S3 网关</a> 实现 S3 协议兼容的访问接口；</li>
<li><strong>云原生</strong>：通过 <a href="https://juicefs.com/docs/zh/community/how_to_use_on_kubernetes">Kubernetes CSI Driver</a> 可以很便捷地在 Kubernetes 中使用 JuiceFS；</li>
<li><strong>多端共享</strong>：同一文件系统可在上千台服务器同时挂载，高性能并发读写，共享数据；</li>
<li><strong>强一致性</strong>：确认的修改会在所有挂载了同一文件系统的服务器上立即可见，保证强一致性；</li>
<li><strong>强悍性能</strong>：毫秒级的延迟，近乎无限的吞吐量（取决于对象存储规模），查看<a href="https://juicefs.com/docs/zh/community/benchmark">性能测试结果</a>；</li>
<li><strong>数据安全</strong>：支持传输中加密（encryption in transit）以及静态加密（encryption at rest），<a href="https://juicefs.com/docs/zh/community/encrypt">查看详情</a>；</li>
<li><strong>文件锁</strong>：支持 BSD 锁（flock）及 POSIX 锁（fcntl）；</li>
<li><strong>数据压缩</strong>：支持使用 <a href="https://lz4.github.io/lz4">LZ4</a> 或 <a href="https://facebook.github.io/zstd">Zstandard</a> 压缩数据，节省存储空间；</li>
</ol>
<h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><p>JuiceFS 文件系统由三个部分组成：</p>
<ol>
<li><strong>JuiceFS 客户端</strong>：协调对象存储和元数据存储引擎，以及 POSIX、Hadoop、Kubernetes、S3 Gateway 等文件系统接口的实现；</li>
<li><strong>数据存储</strong>：存储数据本身，支持本地磁盘、对象存储；</li>
<li><strong>元数据引擎</strong>：存储数据对应的元数据，支持 Redis、MySQL、TiKV 等多种引擎；</li>
</ol>
<p><img src="https://juicefs.com/docs/zh/assets/images/juicefs-arch-new-a58938733d246f30089d5302dd268c29.png" alt="JuiceFS Architecture"></p>
<p>作为文件系统，JuiceFS 会分别处理数据及其对应的元数据，数据会被存储在对象存储中，元数据会被存储在元数据服务引擎中。</p>
<p>在<strong>数据存储</strong>方面，JuiceFS 支持几乎所有的公有云对象存储，同时也支持 OpenStack Swift、Ceph、MinIO 等私有化的对象存储。</p>
<p>在<strong>元数据存储</strong>方面，JuiceFS 采用多引擎设计，目前已支持 <a href="https://redis.io/">Redis</a>、MySQL/MariaDB、TiKV 等作为元数据服务引擎，也将陆续实现更多元数据存储引擎。欢迎 <a href="https://github.com/juicedata/juicefs/issues">提交 Issue</a> 反馈你的需求！</p>
<p>在<strong>文件系统接口</strong>实现方面：</p>
<ul>
<li>通过 <strong>FUSE</strong>，JuiceFS 文件系统能够以 POSIX 兼容的方式挂载到服务器，将海量云端存储直接当做本地存储来使用。</li>
<li>通过 <strong>Hadoop Java SDK</strong>，JuiceFS 文件系统能够直接替代 HDFS，为 Hadoop 提供低成本的海量存储。</li>
<li>通过 <strong>Kubernetes CSI driver</strong>，JuiceFS 文件系统能够直接为 Kubernetes 提供海量存储。</li>
<li>通过 <strong>S3 Gateway</strong>，使用 S3 作为存储层的应用可直接接入，同时可使用 AWS CLI、s3cmd、MinIO client 等工具访问 JuiceFS 文件系统。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>JuiceFS 广泛适用于各种数据存储和共享场景，本页汇总来自世界各地的 JuiceFS 应用案例，欢迎所有社区用户共同来维护这份案例列表。</p>
<h3 id="数据备份、迁移与恢复​"><a href="#数据备份、迁移与恢复​" class="headerlink" title="数据备份、迁移与恢复​"></a>数据备份、迁移与恢复<a href="https://juicefs.com/docs/zh/community/case#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E8%BF%81%E7%A7%BB%E4%B8%8E%E6%81%A2%E5%A4%8D" title="标题链接">​</a></h3><ul>
<li><a href="https://juicefs.com/blog/cn/posts/optimize-xtrabackup-prepare-by-oplog/">利用 JuiceFS 把 MySQL 备份验证性能提升 10 倍</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/juicesync/">跨云数据搬迁利器：Juicesync</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/xiachufang-mysql-backup-practice-on-juicefs/">下厨房基于 JuiceFS 的 MySQL 备份实践</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/backup-nginx-logs-on-juicefs/">如何用 JuiceFS 归档备份 Nginx 日志</a></li>
</ul>
<h3 id="大数据​"><a href="#大数据​" class="headerlink" title="大数据​"></a>大数据<a href="https://juicefs.com/docs/zh/community/case#%E5%A4%A7%E6%95%B0%E6%8D%AE" title="标题链接">​</a></h3><ul>
<li><a href="https://juicefs.com/blog/cn/posts/qutoutiao-big-data-platform-user-case/">JuiceFS 如何帮助趣头条超大规模 HDFS 降负载</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/globalegrow-big-data-platform-user-case/">环球易购数据平台如何做到既提速又省钱？</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/juicefs-practice-in-souche/">JuiceFS 在大搜车数据平台的实践</a></li>
<li><a href="https://aws.amazon.com/cn/blogs/china/use-aws-cloudformation-to-configure-juicefs-in-amazon-emr-in-one-minute/">使用 AWS Cloudformation 在 Amazon EMR 中一分钟配置 JuiceFS</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/optimize-kylin-on-juicefs/">使用 JuiceFS 在云上优化 Kylin 4.0 的存储性能</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/clickhouse-disaggregated-storage-and-compute-practice/">ClickHouse 存算分离架构探索</a></li>
</ul>
<h3 id="AI​"><a href="#AI​" class="headerlink" title="AI​"></a>AI<a href="https://juicefs.com/docs/zh/community/case#ai" title="标题链接">​</a></h3><ul>
<li><a href="https://juicefs.com/blog/cn/posts/how-to-use-juicefs-to-speed-up-ai-model-training-by-7-times/">如何借助 JuiceFS 为 AI 模型训练提速 7 倍</a></li>
</ul>
<h3 id="数据共享​"><a href="#数据共享​" class="headerlink" title="数据共享​"></a>数据共享<a href="https://juicefs.com/docs/zh/community/case#%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB" title="标题链接">​</a></h3><ul>
<li><a href="https://juicefs.com/blog/cn/posts/build-milvus-distributed-cluster-based-on-juicefs">基于 JuiceFS 搭建 Milvus 分布式集群</a></li>
<li><a href="https://juicefs.com/blog/cn/posts/modao-replace-nas-with-juicefs/">如何解决 NAS 单点故障还顺便省了 90% 的成本？</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面三个方面的介绍可以总结如下图：</p>
<p><img src="https://z3.ax1x.com/2021/11/27/omLr1f.png" alt=""></p>
<p>个人觉得JuiceFS的想法挺好的，官方提了很多的优点，个人比较喜欢的优点如下：</p>
<ol>
<li><p>能抓到目标用户的痛点，尤其是其核心特性兼容POXIS、HDFS、S3这个特性。</p>
<p>在HDFS和对象存储广泛使用的今天，在很多公司都有广泛的应用。</p>
<blockquote>
<p>如果只在大数据生态里面往往不容易看到 POSIX 的意义，因为 Hadoop 生态都是基于 HDFS 设计的，但是在今天我们的应用生态正在发生一些变化，尤其最近两年深度学习和机器学习的应用越来越普及，很多团队都在用 TensorFlow、PyTorch 这样的深度学习框架做模型训练。这些框架大部分是基于 POSIX 文件系统设计的，而这些数据集的规模往往又非常庞大，很多时候要用 Hadoop 的计算引擎做预处理。这就意味着我们需要把数据在 HDFS 中做预处理，把结果再搬到 POSIX 文件系统中做训练。如果有一个文件系统，同时兼容 POSIX、HDFS，可能还有其他的接口，能够支持你需要的所有应用生态，数据可以在其中被共享访问，Data Pipeline 可以简化很多。</p>
</blockquote>
</li>
<li><p>架构设计的思考演进，不重复造轮子，把握能力边界，而不至于把整个项目搞得非常庞大</p>
<p>架构方面JuiceFS总共三个模块，想想GFS也不就是三个模块：master，client，chunkserver（datanode）。JuiceFS也类似，不过JuiceFS没有把重点放在重复造轮子，比如说去做数据节点的存储，而是直接使用现在非常普遍的对象存储。元数据也可以直接使用开源的Redis、SQL等（当然商业版元数据这块他们还是使用的自己研发的元数据存储引擎）。他们开源的JuiceFS等于是重点放在做client，解决用户实际使用现有的各种存储上存在的一些容易被我们忽略的痛点。<br>对于JuiceFS架构设计这块可以看看官方这篇文档：<a href="https://juicefs.com/blog/cn/posts/how-to-build-full-managed-hdfs-in-cloud/">云上全托管 HDFS 技术解析</a>，比较详细的介绍他们为什么会这样设计。</p>
</li>
</ol>
<p>   优点说了，也说说缺点：</p>
<ul>
<li>目前开源JuiceFS还并没有经过充分的测试验证，可能还存在一些未知的bug</li>
<li>有的逻辑比较复杂的代码也没注释，导致理解困难</li>
</ul>
<p>不过开源JuiceFS也还在继续完善中，可以看到官方也不断地加入新的功能，支持的元数据引擎也越来越多，而且社区也比较活跃，笔者在测试使用的时候发现了一个小bug，提issue当天就修复了该bug，响应速度很快[手动赞一个]。</p>
<p>最后再列一下JuiceFS目前支持的对象存储和元数据存储引擎。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#amazon-s3">Amazon S3</a></td>
<td><code>s3</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#google-%E4%BA%91%E5%AD%98%E5%82%A8">Google 云存储</a></td>
<td><code>gs</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#azure-blob-%E5%AD%98%E5%82%A8">Azure Blob 存储</a></td>
<td><code>wasb</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#backblaze-b2">Backblaze B2</a></td>
<td><code>b2</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#ibm-%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8">IBM 云对象存储</a></td>
<td><code>ibmcos</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#scaleway">Scaleway</a></td>
<td><code>scw</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#digitalocean-spaces">DigitalOcean Spaces</a></td>
<td><code>space</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#wasabi">Wasabi</a></td>
<td><code>wasabi</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#storj-dcs">Storj DCS</a></td>
<td><code>s3</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#vultr-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8">Vultr 对象存储</a></td>
<td><code>s3</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E9%98%BF%E9%87%8C%E4%BA%91-oss">阿里云 OSS</a></td>
<td><code>oss</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E8%85%BE%E8%AE%AF%E4%BA%91-cos">腾讯云 COS</a></td>
<td><code>cos</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E5%8D%8E%E4%B8%BA%E4%BA%91-obs">华为云 OBS</a></td>
<td><code>obs</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E7%99%BE%E5%BA%A6%E4%BA%91-bos">百度云 BOS</a></td>
<td><code>bos</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E9%87%91%E5%B1%B1%E4%BA%91-ks3">金山云 KS3</a></td>
<td><code>ks3</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E7%BE%8E%E5%9B%A2%E4%BA%91-mms">美团云 MMS</a></td>
<td><code>mss</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E7%BD%91%E6%98%93%E4%BA%91-nos">网易云 NOS</a></td>
<td><code>nos</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E9%9D%92%E4%BA%91-qingstor">青云 QingStor</a></td>
<td><code>qingstor</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E4%B8%83%E7%89%9B%E4%BA%91-kodo">七牛云 Kodo</a></td>
<td><code>qiniu</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E6%96%B0%E6%B5%AA%E4%BA%91-scs">新浪云 SCS</a></td>
<td><code>scs</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E5%A4%A9%E7%BF%BC%E4%BA%91-oos">天翼云 OOS</a></td>
<td><code>oos</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E7%A7%BB%E5%8A%A8%E4%BA%91-eos">移动云 EOS</a></td>
<td><code>eos</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E4%BC%98%E5%88%BB%E5%BE%97-us3">优刻得 US3</a></td>
<td><code>ufile</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#ceph-rados">Ceph RADOS</a></td>
<td><code>ceph</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#ceph-rgw">Ceph RGW</a></td>
<td><code>s3</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#swift">Swift</a></td>
<td><code>swift</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#minio">MinIO</a></td>
<td><code>minio</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#webdav">WebDAV</a></td>
<td><code>webdav</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#hdfs">HDFS</a></td>
<td><code>hdfs</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#redis">Redis</a></td>
<td><code>redis</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#tikv">TiKV</a></td>
<td><code>tikv</code></td>
</tr>
<tr>
<td><a href="https://juicefs.com/docs/zh/community/how_to_setup_object_storage#%E6%9C%AC%E5%9C%B0%E7%A3%81%E7%9B%98">本地磁盘</a></td>
<td><code>file</code></td>
</tr>
</tbody>
</table>
<p>JuiceFS 已经支持的元数据存储引擎：</p>
<ul>
<li><a href="https://juicefs.com/docs/zh/community/databases_for_metadata#redis">Redis</a></li>
<li><a href="https://juicefs.com/docs/zh/community/databases_for_metadata#postgresql">PostgreSQL</a></li>
<li><a href="https://juicefs.com/docs/zh/community/databases_for_metadata#mysql">MySQL</a></li>
<li><a href="https://juicefs.com/docs/zh/community/databases_for_metadata#mariadb">MariaDB</a></li>
<li><a href="https://juicefs.com/docs/zh/community/databases_for_metadata#sqlite">SQLite</a></li>
<li><a href="https://juicefs.com/docs/zh/community/databases_for_metadata#tikv">TiKV</a></li>
<li><a href="https://juicefs.com/docs/zh/community/databases_for_metadata#foundationdb">FoundationDB</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juicefs.com/docs/zh/community/introduction">JuiceFS是什么</a></p>
<p><a href="https://juicefs.com/docs/zh/community/architecture">JuiceFS 技术架构</a></p>
<p><a href="https://juicefs.com/docs/zh/community/case">JuiceFS 应用场景 &amp; 案例</a></p>
<p><a href="https://juicefs.com/blog/cn/posts/how-to-build-full-managed-hdfs-in-cloud/">云上全托管 HDFS 技术解析</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>文件存储</tag>
        <tag>JuiceFS</tag>
      </tags>
  </entry>
  <entry>
    <title>JuiceFS性能怎么样</title>
    <url>/2021/11/07/JuiceFS%E6%80%A7%E8%83%BD%E6%80%8E%E4%B9%88%E6%A0%B7/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/12/02/oNOv0e.png" alt=""></p>
<span id="more"></span>
<p>本文主要记录用vdbench测试JuiceFS的性能表现情况及遇到的问题。vdbench的安装使用，请参考<a href="https://www.a-programmer.top/2021/10/31/vdbench安装与使用/">vdbench安装使用</a>。本文的测试环境请见下文，另外也可以看看JuiceFS官方给出的性能数据：<a href="https://juicefs.com/docs/zh/cloud/single_node_benchmark/">单机性能测试</a>。</p>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><ul>
<li><p>CPU： Intel(R) Xeon(R) Silver 4214R CPU @ 2.40GHz</p>
</li>
<li><p>内存: 128GB</p>
</li>
</ul>
<h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><ul>
<li><p>fio 3.12</p>
</li>
<li><p>juices version 1.0-dev (2021-11-03 d98cd00f)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">juicefs -V</span><br><span class="line">juicefs version 1.0-dev (2021-11-03 d98cd00f)</span><br><span class="line">root@xxx:/home/xxx/juicefs# ls /mnt/jfs/</span><br></pre></td></tr></table></figure>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>使用向DB申请的8GB的Redis环境</p>
<h4 id="S3实例信息"><a href="#S3实例信息" class="headerlink" title="S3实例信息"></a>S3实例信息</h4><p>机房S3实例信息略</p>
<h2 id="4k小文件场景"><a href="#4k小文件场景" class="headerlink" title="4k小文件场景"></a>4k小文件场景</h2><p>本文中默认vdbench放在/home/xxx/software/vdbench目录下。</p>
<h3 id="单机执行vdbench测试"><a href="#单机执行vdbench测试" class="headerlink" title="单机执行vdbench测试"></a>单机执行vdbench测试</h3><p>单机4k小文件场景的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#hd=default,vdbench=/home/xxx/software/vdbench/,user=root,shell=vdbench</span><br><span class="line">#hd=hd1,system=xxx</span><br><span class="line"></span><br><span class="line">fsd=fsd1,anchor=/mnt/jfs,depth=3,width=10,files=30,size=20M,openflags=o_direct</span><br><span class="line"></span><br><span class="line">fwd=fwd1,fsd=fsd1,operation=write,xfersize=4k,fileio=random,fileselect=random,threads=10</span><br><span class="line"></span><br><span class="line">fwd=fwd2,fsd=fsd1,operation=read,xfersize=4k,fileio=random,fileselect=random,threads=10</span><br><span class="line"></span><br><span class="line">fwd=fwd3,fsd=fsd1,operation=write,xfersize=4k,fileio=sequential,fileselect=sequential,threads=10</span><br><span class="line"></span><br><span class="line">fwd=fwd4,fsd=fsd1,operation=read,xfersize=4k,fileio=sequential,fileselect=sequential,threads=10</span><br><span class="line"></span><br><span class="line">fwd=fwd5,fsd=fsd1,operation=read,rdpct=70,xfersize=4k,fileio=random,fileselect=random,threads=10</span><br><span class="line"></span><br><span class="line">rd=rd1,fwd=fwd1,fwdrate=max,format=restart,elapsed=600,interval=2</span><br><span class="line">rd=rd2,fwd=fwd2,fwdrate=max,format=restart,elapsed=600,interval=2</span><br><span class="line">rd=rd3,fwd=fwd3,fwdrate=max,format=restart,elapsed=600,interval=2</span><br><span class="line">rd=rd4,fwd=fwd4,fwdrate=max,format=restart,elapsed=600,interval=2</span><br><span class="line">rd=rd5,fwd=fwd5,fwdrate=max,format=restart,elapsed=600,interval=2</span><br></pre></td></tr></table></figure>
<p>准备好配置文件之后，就可以执行如下命令了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@xxx:/home/xxxx/software/vdbench# nohup /home/xxx/software/vdbench/vdbench -f /home/xxx/software/vdbench/conf/4k_test.cfg -o /home/xxx/software/vdbench/output_4K &amp;</span><br><span class="line">[1] 2026642</span><br><span class="line">nohup: ignoring input and appending output to &#x27;nohup.out&#x27;</span><br><span class="line">root@xxx:/home/xxx/software/vdbench# ps -ef | grep vdbench</span><br><span class="line">root     2026642 2008208  0 16:48 pts/1    00:00:00 /bin/bash /home/xxx/software/vdbench/vdbench -f /home/xxx/software/vdbench/conf/4k_test.cfg -o /home/xxx/software/vdbench/output_4K</span><br><span class="line">root     2026651 2026642 19 16:48 pts/1    00:00:01 java -client -Xmx512m -Xms64m -cp /home/xxx/software/vdbench/:/home/xxx/software/vdbench/classes:/home/xxx/software/vdbench/vdbench.jar Vdb.Vdbmain -f /home/xxx/software/vdbench/conf/4k_test.cfg -o /home/xxx/software/vdbench/output_4K</span><br><span class="line">root     2026688 2026651  0 16:48 pts/1    00:00:00 /bin/bash /home/xxx/software/vdbench/vdbench SlaveJvm -m localhost -n localhost-10-211109-16.48.06.714 -l localhost-0 -p 5570</span><br><span class="line">root     2026692 2026688 99 16:48 pts/1    00:00:10 java -client -Xmx1024m -Xms128m -cp /home/xxx/software/vdbench/:/home/xxx/software/vdbench/classes:/home/xxx/software/vdbench/vdbench.jar Vdb.SlaveJvm SlaveJvm -m localhost -n localhost-10-211109-16.48.06.714 -l localhost-0 -p 5570</span><br><span class="line">root     2026809 2008208  0 16:48 pts/1    00:00:00 grep vdbench</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在单机执行的时候，配置文件中不需要写host相关信息了。<br>如果配置了，很可能因为防火墙等原因会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@xxx:/home/xxx/software/vdbench# /home/xxx/software/vdbench/vdbench -f /home/xxx/software/vdbench/conf/4k_test.cfg -o /home/xxx/software/vdbench/output_4K</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Vdbench distribution: vdbench50407 Tue June 05  9:49:29 MDT 2018</span><br><span class="line">For documentation, see &#x27;vdbench.pdf&#x27;.</span><br><span class="line"></span><br><span class="line">16:37:06.842 input argument scanned: &#x27;-f/home/xxx/software/vdbench/conf/4k_test.cfg&#x27;</span><br><span class="line">16:37:06.843 input argument scanned: &#x27;-o/home/xxx/software/vdbench/output_4K&#x27;</span><br><span class="line">16:37:06.898 Anchor size: anchor=/mnt/jfs: dirs:        1,110; files:       30,000; bytes:   585.938g (629,145,600,000)</span><br><span class="line">16:37:06.936 Starting slave: /home/xxx/software/vdbench/vdbench SlaveJvm -m 7.32.198.214 -n xxx-10-211109-16.37.06.805 -l hd1-0 -p 5570</span><br><span class="line">16:37:10.076 hd1-0       : 16:37:10.076 common.failure(): System.exit(-99)</span><br><span class="line">16:37:11.088</span><br><span class="line">16:37:11.088 Slave hd1-0 prematurely terminated.</span><br><span class="line">16:37:11.088 Look at file hd1-0.stdout.html for more information.</span><br><span class="line">16:37:11.589</span><br><span class="line">16:37:11.589 Slave hd1-0 prematurely terminated.</span><br><span class="line">16:37:11.589</span><br><span class="line">java.lang.RuntimeException: Slave hd1-0 prematurely terminated.</span><br><span class="line">    at Vdb.common.failure(common.java:350)</span><br><span class="line">    at Vdb.SlaveStarter.startSlave(SlaveStarter.java:188)</span><br><span class="line">    at Vdb.SlaveStarter.run(SlaveStarter.java:47)</span><br><span class="line">root@xxx:/home/xxx/software/vdbench#</span><br><span class="line">root@xxx:/home/xxx/software/vdbench#</span><br><span class="line">root@xxx:/home/xxx/software/vdbench# cat output_4K/hd1-0.stdout.html</span><br><span class="line"></span><br><span class="line">&lt;title&gt;Vdbench output_4K/hd1-0.stdout.html&lt;/title&gt;&lt;pre&gt;</span><br><span class="line">stdout/stderr for slave=hd1-0</span><br><span class="line"></span><br><span class="line">16:37:07.010 16:37:07.009 SlaveJvm execution parameter:  &#x27;-m 7.32.198.214&#x27;</span><br><span class="line">16:37:07.010 16:37:07.009 SlaveJvm execution parameter:  &#x27;-n xxx-10-211109-16.37.06.805&#x27;</span><br><span class="line">16:37:07.010 16:37:07.009 SlaveJvm execution parameter:  &#x27;-l hd1-0&#x27;</span><br><span class="line">16:37:07.010 16:37:07.010 SlaveJvm execution parameter:  &#x27;-p 5570&#x27;</span><br><span class="line">16:37:07.010 16:37:07.010 SlaveJvm positional parameter: &#x27;SlaveJvm&#x27;</span><br><span class="line">16:37:10.067 16:37:10.067 java.net.ConnectException</span><br><span class="line">16:37:10.067 java.net.ConnectException: Connection timed out (Connection timed out)</span><br><span class="line">16:37:10.068     at java.base/java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">16:37:10.068     at java.base/java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:399)</span><br><span class="line">16:37:10.068     at java.base/java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:242)</span><br><span class="line">#hd=default,vdbench=/home/xxx/software/vdbench/,user=root,shell=vdbench</span><br><span class="line">16:37:10.068     at java.base/java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:224)</span><br><span class="line">16:37:10.068     at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:403)</span><br><span class="line">16:37:10.068     at java.base/java.net.Socket.connect(Socket.java:609)</span><br><span class="line">16:37:10.068     at java.base/java.net.Socket.connect(Socket.java:558)</span><br><span class="line">16:37:10.068     at java.base/java.net.Socket.&lt;init&gt;(Socket.java:454)</span><br><span class="line">16:37:10.068     at java.base/java.net.Socket.&lt;init&gt;(Socket.java:231)</span><br><span class="line">16:37:10.069     at Vdb.SlaveSocket.&lt;init&gt;(SlaveSocket.java:61)</span><br><span class="line">16:37:10.069     at Vdb.SlaveJvm.connectToMaster(SlaveJvm.java:98)</span><br><span class="line">16:37:10.069     at Vdb.SlaveJvm.main(SlaveJvm.java:425)</span><br><span class="line">16:37:10.069 java.net.ConnectException: Connection timed out (Connection timed out)</span><br><span class="line">16:37:10.069     at java.base/java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">16:37:10.069     at java.base/java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:399)</span><br><span class="line">16:37:10.069     at java.base/java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:242)</span><br><span class="line">16:37:10.069     at java.base/java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:224)</span><br><span class="line">16:37:10.069     at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:403)</span><br><span class="line">16:37:10.069     at java.base/java.net.Socket.connect(Socket.java:609)</span><br><span class="line">16:37:10.070     at java.base/java.net.Socket.connect(Socket.java:558)</span><br><span class="line">16:37:10.070     at java.base/java.net.Socket.&lt;init&gt;(Socket.java:454)</span><br><span class="line">16:37:10.070     at java.base/java.net.Socket.&lt;init&gt;(Socket.java:231)</span><br><span class="line">16:37:10.070     at Vdb.SlaveSocket.&lt;init&gt;(SlaveSocket.java:61)</span><br><span class="line">16:37:10.070     at Vdb.SlaveJvm.connectToMaster(SlaveJvm.java:98)</span><br><span class="line">16:37:10.070     at Vdb.SlaveJvm.main(SlaveJvm.java:425)</span><br><span class="line">#hd=default,vdbench=/home/xxx/software/vdbench/,user=root,shell=vdbench</span><br><span class="line">16:37:10.070 16:37:10.068 Slave ConnectException.</span><br><span class="line">16:37:10.070 16:37:10.069</span><br><span class="line">16:37:10.070 16:37:10.069 It took at least 60 seconds to connect. SlaveJvm terminated</span><br><span class="line">16:37:10.070 16:37:10.070</span><br><span class="line">16:37:10.070 java.lang.RuntimeException: It took at least 60 seconds to connect. SlaveJvm terminated</span><br><span class="line">16:37:10.070     at Vdb.common.failure(common.java:350)</span><br><span class="line">16:37:10.070     at Vdb.SlaveJvm.connectToMaster(SlaveJvm.java:113)</span><br><span class="line">16:37:10.071     at Vdb.SlaveJvm.main(SlaveJvm.java:425)</span><br><span class="line">16:37:10.076 16:37:10.076 Trying to send message &#x27;It took at least 60 seconds to connect. SlaveJvm terminated&#x27; to master, but we have no socket yet:</span><br><span class="line">16:37:10.076 16:37:10.076 common.failure(): System.exit(-99)</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table>
<thead>
<tr>
<th style="text-align:left">负载名称</th>
<th style="text-align:center">写IOPS</th>
<th style="text-align:center">写时延/ms</th>
<th style="text-align:right">写带宽MB/s</th>
<th style="text-align:right">读IOPS</th>
<th style="text-align:right">读时延/ms</th>
<th style="text-align:right">读带宽MB/s</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">rd1 随机写</td>
<td style="text-align:center">2316.6</td>
<td style="text-align:center">3.939</td>
<td style="text-align:right">9.05</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
</tr>
<tr>
<td style="text-align:left">rd2 随机读</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">26279</td>
<td style="text-align:right">0.376</td>
<td style="text-align:right">102.6</td>
</tr>
<tr>
<td style="text-align:left">rd3 顺序写</td>
<td style="text-align:center">211550</td>
<td style="text-align:center">0.025</td>
<td style="text-align:right">826.3</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
</tr>
<tr>
<td style="text-align:left">rd4 顺序读</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">57102</td>
<td style="text-align:right">0.173</td>
<td style="text-align:right">223.0</td>
</tr>
<tr>
<td style="text-align:left">rd5 随机混合</td>
<td style="text-align:center">1103.1</td>
<td style="text-align:center">0.045</td>
<td style="text-align:right">14.37</td>
<td style="text-align:right">2576.0</td>
<td style="text-align:right">3.855</td>
<td style="text-align:right">4.31</td>
</tr>
</tbody>
</table>
<h2 id="4M大文件场景"><a href="#4M大文件场景" class="headerlink" title="4M大文件场景"></a>4M大文件场景</h2><h3 id="单机执行vdbench测试-1"><a href="#单机执行vdbench测试-1" class="headerlink" title="单机执行vdbench测试"></a>单机执行vdbench测试</h3><p>配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fsd=fsd1,anchor=/mnt/jfs,depth=3,width=10,files=30,size=20M,openflags=o_direct</span><br><span class="line"></span><br><span class="line">fwd=fwd1,fsd=fsd1,operation=write,xfersize=4M,fileio=random,fileselect=random,threads=10</span><br><span class="line"></span><br><span class="line">fwd=fwd2,fsd=fsd1,operation=read,xfersize=4M,fileio=random,fileselect=random,threads=10</span><br><span class="line"></span><br><span class="line">fwd=fwd3,fsd=fsd1,operation=write,xfersize=4M,fileio=sequential,fileselect=sequential,threads=10</span><br><span class="line"></span><br><span class="line">fwd=fwd4,fsd=fsd1,operation=read,xfersize=4M,fileio=sequential,fileselect=sequential,threads=10</span><br><span class="line"></span><br><span class="line">fwd=fwd5,fsd=fsd1,operation=read,rdpct=70,xfersize=4M,fileio=random,fileselect=random,threads=10</span><br><span class="line"></span><br><span class="line">rd=rd1,fwd=fwd1,fwdrate=max,format=restart,elapsed=600,interval=2</span><br><span class="line">rd=rd2,fwd=fwd2,fwdrate=max,format=restart,elapsed=600,interval=2</span><br><span class="line">rd=rd3,fwd=fwd3,fwdrate=max,format=restart,elapsed=600,interval=2</span><br><span class="line">rd=rd4,fwd=fwd4,fwdrate=max,format=restart,elapsed=600,interval=2</span><br><span class="line">rd=rd5,fwd=fwd5,fwdrate=max,format=restart,elapsed=600,interval=2</span><br></pre></td></tr></table></figure>
<h3 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h3><table>
<thead>
<tr>
<th style="text-align:left">负载名称</th>
<th style="text-align:center">写IOPS</th>
<th style="text-align:center">写时延/ms</th>
<th style="text-align:right">写带宽MB/s</th>
<th style="text-align:right">读IOPS</th>
<th style="text-align:right">读时延/ms</th>
<th style="text-align:right">读带宽MB/s</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">rd1 随机写</td>
<td style="text-align:center">224.1</td>
<td style="text-align:center">2.615</td>
<td style="text-align:right">896.3</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
</tr>
<tr>
<td style="text-align:left">rd2 随机读</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">303.7</td>
<td style="text-align:right">32.758</td>
<td style="text-align:right">1214</td>
</tr>
<tr>
<td style="text-align:left">rd3 顺序写</td>
<td style="text-align:center">224.7</td>
<td style="text-align:center">2.527</td>
<td style="text-align:right">898.7</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">-</td>
</tr>
<tr>
<td style="text-align:left">rd4 顺序读</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">361.6</td>
<td style="text-align:right">27.534</td>
<td style="text-align:right">1446</td>
</tr>
<tr>
<td style="text-align:left">rd5 随机混合</td>
<td style="text-align:center">59.6</td>
<td style="text-align:center">3.022</td>
<td style="text-align:right">238.2</td>
<td style="text-align:right">137.4</td>
<td style="text-align:right">61.330</td>
<td style="text-align:right">549.4</td>
</tr>
</tbody>
</table>
<h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><h3 id="java-lang-RuntimeException-Slave-hd1-0-prematurely-terminated"><a href="#java-lang-RuntimeException-Slave-hd1-0-prematurely-terminated" class="headerlink" title="java.lang.RuntimeException: Slave hd1-0 prematurely terminated."></a>java.lang.RuntimeException: Slave hd1-0 prematurely terminated.</h3><p>该错误上面已经提到过了，主要是防火墙的问题，所以会报错。<br>解决办法是：直接不填hd相关信息，默认就是单机执行，会自行拉起相关进程，通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep vdbench</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@xxx:/home/xxx/software/vdbench# ps -ef | grep vdbench</span><br><span class="line">root     2026642 2008208  0 16:48 pts/1    00:00:00 /bin/bash /home/xxx/software/vdbench/vdbench -f /home/xxx/software/vdbench/conf/4k_test.cfg -o /home/xxx/software/vdbench/output_4K</span><br><span class="line">root     2026651 2026642  1 16:48 pts/1    00:00:07 java -client -Xmx512m -Xms64m -cp /home/xxx/software/vdbench/:/home/xxx/software/vdbench/classes:/home/xxx/software/vdbench/vdbench.jar Vdb.Vdbmain -f /home/xxx/software/vdbench/conf/4k_test.cfg -o /home/xxx/software/vdbench/output_4K</span><br><span class="line">root     2026688 2026651  0 16:48 pts/1    00:00:00 /bin/bash /home/xxx/software/vdbench/vdbench SlaveJvm -m localhost -n localhost-10-211109-16.48.06.714 -l localhost-0 -p 5570</span><br><span class="line">root     2026692 2026688 20 16:48 pts/1    00:02:15 java -client -Xmx1024m -Xms128m -cp /home/xxx/software/vdbench/:/home/xxx/software/vdbench/classes:/home/xxx/software/vdbench/vdbench.jar Vdb.SlaveJvm SlaveJvm -m localhost -n localhost-10-211109-16.48.06.714 -l localhost-0 -p 5570</span><br><span class="line">root     2031420 2008208  0 16:58 pts/1    00:00:00 grep vdbench</span><br></pre></td></tr></table></figure>
<h3 id="Make-sure-you-also-specify-‘format-yes’-in-the-Run-Definition-RD"><a href="#Make-sure-you-also-specify-‘format-yes’-in-the-Run-Definition-RD" class="headerlink" title="Make sure you also specify ‘format=yes’ in the Run Definition (RD)"></a>Make sure you also specify ‘format=yes’ in the Run Definition (RD)</h3><p>在多次测试时候，可能那个目录深度和文件数量都有变量，于是遇到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@xxx:/home/xxx/software/vdbench# /home/xxx/software/vdbench/vdbench -f /home/xxx/software/vdbench/conf/4k_test_multi_machine_4M.cfg -o /home/xxx/software/vdbench/output_4K_multi_machine_4M</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line">Vdbench distribution: vdbench50407 Tue June 05  9:49:29 MDT 2018</span><br><span class="line">For documentation, see &#x27;vdbench.pdf&#x27;.</span><br><span class="line"></span><br><span class="line">16:44:32.484 input argument scanned: &#x27;-f/home/xxx/software/vdbench/conf/4k_test_multi_machine_4M.cfg&#x27;</span><br><span class="line">16:44:32.485 input argument scanned: &#x27;-o/home/xxx/software/vdbench/output_4K_multi_machine_4M&#x27;</span><br><span class="line">16:44:32.742 Anchor size: anchor=/mnt/jfs/test1: dirs:       11,110; files:      400,000; bytes:     1.526t (1,677,721,600,000)</span><br><span class="line">16:44:32.748 Anchor size: anchor=/mnt/jfs/test2: dirs:       11,110; files:      400,000; bytes:     1.526t (1,677,721,600,000)</span><br><span class="line">16:44:32.752 Anchor size: anchor=/mnt/jfs/test3: dirs:       11,110; files:      400,000; bytes:     1.526t (1,677,721,600,000)</span><br><span class="line">16:44:32.805 Estimated totals for all 3 anchors: dirs: 33,330; files: 1,200,000; bytes: 4.578t</span><br><span class="line">16:44:32.842 Starting slave: /home/xxx/software/vdbench/vdbench SlaveJvm -m 7.32.198.214 -n xxx-10-211110-16.44.32.445 -l hd1-0 -p 5570</span><br><span class="line">16:44:32.863 Starting slave: /home/xxx/software/vdbench/vdbench SlaveJvm -m 7.32.198.214 -n xxx-11-211110-16.44.32.445 -l hd2-0 -p 5570</span><br><span class="line">16:44:32.869 Successfully connected to the Vdbench rsh daemon on host xxx</span><br><span class="line">16:44:32.869 RSH Connection to xxx using port 5560 successful</span><br><span class="line">16:44:32.883 Starting slave: /home/xxx/software/vdbench/vdbench SlaveJvm -m 7.32.198.214 -n xxx-12-211110-16.44.32.445 -l hd3-0 -p 5570</span><br><span class="line">16:44:32.883 Successfully connected to the Vdbench rsh daemon on host xxx</span><br><span class="line">16:44:32.883 RSH Connection to xxx using port 5560 successful</span><br><span class="line">16:44:33.098 All slaves are now connected</span><br><span class="line">16:44:33.327 hd2-0:</span><br><span class="line"></span><br><span class="line">fwd=format</span><br><span class="line">when=end</span><br><span class="line">old depth=3; new depth=4</span><br><span class="line">old width=10; new width=10</span><br><span class="line">old files=30; new files=40</span><br><span class="line">old dist=bottom; new dist=bottom</span><br><span class="line">also check the sizes=() parameters from previous and current execution.</span><br><span class="line">The FWD parameters defined for &#x27;fwd=format&#x27; do not</span><br><span class="line">match the parameters used in the previous run.</span><br><span class="line"></span><br><span class="line">- Correct the parameters, or</span><br><span class="line">- use the &#x27;format=&#x27; RD parameter, or</span><br><span class="line">- Add &#x27;-c&#x27; execution parameter</span><br><span class="line">  Make sure you also specify &#x27;format=yes&#x27; in the Run Definition (RD)</span><br><span class="line">  16:44:33.329 hd3-0:</span><br><span class="line"></span><br><span class="line">fwd=format</span><br><span class="line">when=end</span><br><span class="line">old depth=3; new depth=4</span><br><span class="line">old width=10; new width=10</span><br><span class="line">old files=30; new files=40</span><br><span class="line">old dist=bottom; new dist=bottom</span><br><span class="line">also check the sizes=() parameters from previous and current execution.</span><br><span class="line">The FWD parameters defined for &#x27;fwd=format&#x27; do not</span><br><span class="line">match the parameters used in the previous run.</span><br><span class="line"></span><br><span class="line">- Correct the parameters, or</span><br><span class="line">- use the &#x27;format=&#x27; RD parameter, or</span><br><span class="line">- Add &#x27;-c&#x27; execution parameter</span><br><span class="line">  Make sure you also specify &#x27;format=yes&#x27; in the Run Definition (RD)</span><br><span class="line">  16:44:33.337 hd1-0:</span><br><span class="line"></span><br><span class="line">fwd=format</span><br><span class="line">when=end</span><br><span class="line">old depth=3; new depth=4</span><br><span class="line">old width=10; new width=10</span><br><span class="line">old files=30; new files=40</span><br><span class="line">old dist=bottom; new dist=bottom</span><br><span class="line">also check the sizes=() parameters from previous and current execution.</span><br><span class="line">The FWD parameters defined for &#x27;fwd=format&#x27; do not</span><br><span class="line">match the parameters used in the previous run.</span><br><span class="line"></span><br><span class="line">- Correct the parameters, or</span><br><span class="line"></span><br><span class="line">- use the &#x27;format=&#x27; RD parameter, or</span><br><span class="line"></span><br><span class="line">- Add &#x27;-c&#x27; execution parameter</span><br><span class="line">  Make sure you also specify &#x27;format=yes&#x27; in the Run Definition (RD)</span><br><span class="line">  16:44:33.338 *</span><br><span class="line">  16:44:33.338 ****************************************************</span><br><span class="line">  16:44:33.338 * Slave hd2-0 aborting: Parameter definition error *</span><br><span class="line">  16:44:33.338 ****************************************************</span><br><span class="line">  16:44:33.338 *</span><br><span class="line">  16:44:33.338 Slave hd1-0 killed by master</span><br><span class="line">  16:44:33.338 Slave hd3-0 killed by master</span><br><span class="line">  16:44:35.657</span><br><span class="line">  16:44:35.657 Slave hd2-0 prematurely terminated.</span><br><span class="line">  16:44:35.657</span><br><span class="line">  16:44:35.657 Slave aborted. Abort message received:</span><br><span class="line">  16:44:35.657 Parameter definition error</span><br><span class="line">  16:44:35.657</span><br><span class="line">  16:44:35.657 Look at file hd2-0.stdout.html for more information.</span><br><span class="line">  16:44:36.161</span><br><span class="line">  16:44:36.161 Slave hd2-0 prematurely terminated.</span><br><span class="line">  16:44:36.161</span><br><span class="line">  java.lang.RuntimeException: Slave hd2-0 prematurely terminated.</span><br><span class="line">    at Vdb.common.failure(common.java:350)</span><br><span class="line">    at Vdb.SlaveStarter.startSlave(SlaveStarter.java:188)</span><br><span class="line">    at Vdb.SlaveStarter.run(SlaveStarter.java:47)</span><br></pre></td></tr></table></figure>
<p>  错误提示说得很明显了，解决办法就是在rd中加上“ format=yes”</p>
<ul>
<li>format= 可选值为yes、no或restart，标识预处理目录和文件结构的方式<br>–yes表示删除目录和文件结构再重新创建<br>–no表示不删除目录和文件结构<br>–restart表示只创建未生成的目录或文件，并且增大未达到实际大小的文件</li>
</ul>
<h3 id="本来预期一个小时的测试，实际时间花了几个小时"><a href="#本来预期一个小时的测试，实际时间花了几个小时" class="headerlink" title="本来预期一个小时的测试，实际时间花了几个小时"></a>本来预期一个小时的测试，实际时间花了几个小时</h3><p>在测试多机多线程（大文件4M）场景时，实际测试完成时间花了几个小时，本来预期是一个小时完成的。<br>经研究发现跑测试的时候确实是一个小时，而每次测试完成后，因为选的运行参数format设置为<strong>yes</strong>，这样每次都会重新去准备测试环境，包括清理掉上次的环境，但是此时由于环境中有大量小文件，删除耗时很长，我自己尝试删除了一下，很久才完全删除。这就是实际整个测试花了几个小时的原因。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.a-programmer.top/2021/10/31/vdbench安装与使用/">vdbench安装使用</a>。</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>文件存储</tag>
        <tag>JuiceFS</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>JuiceFS源码阅读（一）format流程</title>
    <url>/2021/11/09/JuiceFS%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89format%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://s4.ax1x.com/2021/12/08/ogfra8.png" alt=""></p>
<span id="more"></span>
<p>通过上一篇文章<a href="https://www.a-programmer.top/2021/11/07/JuiceFS性能怎么样/">JuiceFS性能怎么样</a>，对JuiceFS的性能有了初步的了解，本文开始将会用一系列的文章来介绍JuiceFS的源码。本文是JuiceFS源码阅读的开篇，主要带大家了解一下JuiceFS的目录结构，知道各个文件大概功能是做什么的，然后介绍JuiceFS的format流程。</p>
<h2 id="JuiceFS的目录结构"><a href="#JuiceFS的目录结构" class="headerlink" title="JuiceFS的目录结构"></a>JuiceFS的目录结构</h2><p><img src="https://s4.ax1x.com/2021/12/08/ogfoIU.png" alt=""><br>先看一眼目录结构:</p>
<ul>
<li>cmd 目录是总入口，如 juicefs format 命令的入口是 cmd/format.go。</li>
<li>pkg 目录是具体实现，核心逻辑都在这里，其中：</li>
<li>pkg/fuse/fuse.go 是 FUSE 实现的入口，基本是一个 wrapper，具体逻辑在下面。</li>
<li>pkg/vfs 是具体的 FUSE 接口实现，元数据请求会调用 pkg/meta 中的实现，读请求会调用 pkg/vfs/reader.go，写请求会调用 pkg/vfs/writer.go。</li>
<li>pkg/meta/redis.go 是 Redis 版本的元数据引擎，pkg/meta/sql.go 是 SQL 版本的元数据引擎。</li>
<li>pkg/object 是与各种对象存储对接的实现</li>
<li>sdk/java 是 Hadoop Java SDK 的实现，底层依赖 sdk/java/libjfs 这个库（通过 JNI 调用）。<br>pkg目录：<br><img src="https://s4.ax1x.com/2021/12/08/ogfbRJ.png" alt=""><br>pkg目录下的各个目录基本都可以通过名字知道其大概功能。<br>juicefs是通过<a href="https://github.com/urfave/cli">https://github.com/urfave/cli</a>这个go语言 commandline库来支持各种命令的。<br>程序的入口在cmd目录下的main.go文件中：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#cmd/main.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cli.VersionFlag = &amp;cli.BoolFlag&#123;</span><br><span class="line">        Name: <span class="string">&quot;version&quot;</span>, Aliases: []<span class="type">string</span>&#123;<span class="string">&quot;V&quot;</span>&#125;,</span><br><span class="line">        Usage: <span class="string">&quot;print only the version&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    app := &amp;cli.App&#123;</span><br><span class="line">        Name:                 <span class="string">&quot;juicefs&quot;</span>,</span><br><span class="line">        Usage:                <span class="string">&quot;A POSIX file system built on Redis and object storage.&quot;</span>,</span><br><span class="line">        Version:              version.Version(),</span><br><span class="line">        Copyright:            <span class="string">&quot;AGPLv3&quot;</span>,</span><br><span class="line">        EnableBashCompletion: <span class="literal">true</span>,</span><br><span class="line">        Flags:                globalFlags(),</span><br><span class="line">        Commands: []*cli.Command&#123;</span><br><span class="line">            formatFlags(),</span><br><span class="line">            mountFlags(),</span><br><span class="line">            umountFlags(),</span><br><span class="line">            gatewayFlags(),</span><br><span class="line">            syncFlags(),</span><br><span class="line">            rmrFlags(),</span><br><span class="line">            infoFlags(),</span><br><span class="line">            benchFlags(),</span><br><span class="line">            gcFlags(),</span><br><span class="line">            checkFlags(),</span><br><span class="line">            profileFlags(),</span><br><span class="line">            statsFlags(),</span><br><span class="line">            statusFlags(),</span><br><span class="line">            warmupFlags(),</span><br><span class="line">            dumpFlags(),</span><br><span class="line">            loadFlags(),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called via mount or fstab.</span></span><br><span class="line">    <span class="keyword">if</span> strings.HasSuffix(os.Args[<span class="number">0</span>], <span class="string">&quot;/mount.juicefs&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> newArgs, err := handleSysMountArgs(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            os.Args = newArgs</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err := app.Run(reorderOptions(app, os.Args))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到main函数中包含了支持的各种命令：format, mount, umount, gateway, sync等等。</p>
<h2 id="format流程"><a href="#format流程" class="headerlink" title="format流程"></a>format流程</h2><p>使用过JuiceFS的朋友都知道，使用JuiceFS需要使用format和mount两个命令，这里就先介绍format流程，让大家都知道format究竟做了什么事情。我们先看format命令，这也是创建JuiceFS文件系统的第一步，通常我们会输入如下类似的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ juicefs format \</span><br><span class="line">    --storage minio \</span><br><span class="line">    --bucket http://127.0.0.1:9000/pics \</span><br><span class="line">    --access-key minioadmin \</span><br><span class="line">    --secret-key minioadmin \</span><br><span class="line">    redis://127.0.0.1:6379/1 \</span><br><span class="line">    pics</span><br></pre></td></tr></table></figure>
<p>format整个过程的调用流程为：<br><img src="https://s4.ax1x.com/2021/12/08/ogWRHK.png" alt=""><br>formatFlags()：这个函数没有什么好说的，就是按照<code>cli.Command</code>的结构封装了format命令，其中就注册了要执行的format()。<br>meta.NewClient(): 新建元数据服务的client，其中主要检查输入元数据相关参数的信息，根据传入的参数去调用具体的元数据服务，目前JuiceFS支持的元数据服务有redis/tikv/sql等,比如上面命令中是<code>redis://...</code>就会去调用redis的具体实现。</p>
<p>整个format过程中最重要的两点是<strong>数据存储的创建</strong>和<strong>元数据服务的初始化</strong>。这两点对应代码中函数为createStorage()和m.Init()。那么这两个函数究竟做了什么事情呢。</p>
<p>其实createStorage()主要是用传入的参数调用具体的对象存储，整个过程相当于创建了一个与对象存储连接的”client”，当然为了兼容市面上常见的对象存储，可以看到juicefs做了相当多的适配工作。这个createStorage的过程简单的说也就是根据参数去调用对应的对象存储，然后返回一个可以与对应的对象存储可以交互的”client”。</p>
<p>m.init()其实就是进行元数据的初始化，那么究竟需要初始化些什么呢。目前juicefs支持redis，tikv，sql等元数据服务，所以也对这几种服务进行相应的初始化实现。其实简单的说，就是在初始化的时候会去验证是不是已经创建过该juicefs的元数据了，如果没有就会生成一些关于juicefs的元数据信息，然后把这些信息写入对应的元数据服务中，比如使用Redis就会写入Redis中。如果有对应的信息，说明已经创建过juicefs，那么就会校验更新，如果有信息不匹配就会报“cannot update format from ”错误之类的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/juicedata/juicefs">JuiceFS源码</a><br><a href="https://juicefs.com/blog/cn/posts/juicefs-office-hours-recap-2021-06-07/">JuiceFS Office Hours 近期问题回顾</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>文件存储</tag>
        <tag>JuiceFS</tag>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>JuiceFS源码阅读（二）mount流程</title>
    <url>/2021/11/20/JuiceFS%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89mount%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://s4.ax1x.com/2021/12/20/TuUXMn.png" alt=""></p>
<span id="more"></span>
<p>注：本系列源码基于juicefs 0.17.2版本</p>
<p>前一篇文章介绍了<a href="https://www.a-programmer.top/2021/11/09/JuiceFS源码阅读（一）format流程/">juicefs的format流程</a>，本文将简单介绍juicefs的mount流程。<br>使用juicefs的第二步需要mount，用如下类似的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo juicefs mount -d redis://127.0.0.1:6379/1 /mnt/jfs</span><br></pre></td></tr></table></figure>
<p>然后就可以愉快地把juicefs当本地文件系统来使用了。<br>juicefs的fuse客户端是基于go-fuse开发的（<a href="https://github.com/hanwen/go-fuse/">https://github.com/hanwen/go-fuse/</a> ），文档可参考 <a href="https://pkg.go.dev/github.com/hanwen/go-fuse">https://pkg.go.dev/github.com/hanwen/go-fuse</a> ，支持3种文件系统模式，juicefs用到的是RawFileSystem，全部操作需要自己实现，另外两种模式文档里有介绍。<br>此外，关于FUSE的介绍可以参考<a href="https://zhuanlan.zhihu.com/p/378429806">FUSE 框架</a>。</p>
<h2 id="mount-流程"><a href="#mount-流程" class="headerlink" title="mount 流程"></a>mount 流程</h2><p>整个mount流程简单地说，就是执行juicefs mount命令之后，会检查输入的参数，接着初始化元数据连接、数据连接、初始化各种配置及vfs，然后创建FUSE文件系统，启动fuse server进程，接受用户文件操作请求。</p>
<p>mount流程图如下：<br><img src="https://s4.ax1x.com/2021/12/20/TuUkHf.png" alt=""><br>main()-&gt;mountFlags()-&gt;mount_flags()-&gt;clientFlags()-&gt;mount()….，mount()中先设置日志级别，然后检查参数是否正确以及挂载点是否正常，然后新建元数据服务客户端，从元数据服务上获取元数据信息，注册普罗米修斯，初始化各种挂载点配置（如cache目录、写入策略write through或write back、预读取策略、内存buffer大小等），获取使用的对象存储，对对象存储设置上传和下载限速，新建cacheStore，注册特定消息类型的回调函数（比如DeleteChunk注册对应的store.Remove）， VFS初始化，检查挂载点，新建NewSession，installHandler中做好信号处理（比如kill信号，ctrl+c之类的处理），暴露数据采集接口，在fuse.Serve中新建文件系统fuse.RawFileSystem，在指定的挂载点创建FUSE文件系统，之后启动fuse server进程，随后开始接受用户文件操作请求。</p>
<p>其中NewSession()会调用元数据模块具体的实现（redis/sql等），大致做了如下事情：<br>（1）启动一个goroutine专门刷新空间及inode使用情况（每10秒一次）<br>（2）将本session id和session info(juicefs version, hostname, process id)记录到元数据服务(redis或sql等，具体看使用的什么来存元数据)中<br>（3）启动一个goroutine专门刷新session并会清理过期的session（每分钟一次）<br>（4）启动一个goroutine专门清理删除掉的文件（每分钟一次）<br>（5）启动一个goroutine专门清理slices（每小时一次，至于什么是slices，这个涉及到juicefs是如何存储文件的，本文不多做介绍，可以看文末参考资料中juicefs官方的《juicefs是如何存储文件的》），真正删除对象存储上对象时会调用前面注册的回调函数。<br>（6）还有一个flushStats goroutine，看起来是如果有新的空间和新的inodes则更新相应的信息（每秒一次）</p>
<p>本文主要介绍mount流程的主要逻辑，还有很多细节没有提，感兴趣的小伙伴可以自己去查阅源码。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/juicedata/juicefs">JuiceFS源码</a></p>
<p><a href="https://juicefs.com/docs/zh/community/architecture#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6">JuiceFS如何存储文件</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/378429806">FUSE 框架</a></p>
<p><a href="https://www.cnblogs.com/luohaixian/p/15374849.html">JuiceFS框架介绍和读写流程解析</a><br><a href="http://aspirer.wang/?p=1553">juicefs使用及关键流程源码分析</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>文件存储</tag>
        <tag>JuiceFS</tag>
        <tag>mount</tag>
      </tags>
  </entry>
  <entry>
    <title>JuiceFS的编译安装及Mac上使用JuiceFS</title>
    <url>/2021/11/06/JuiceFS%E7%9A%84%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%8F%8AMac%E4%B8%8A%E5%AE%89%E8%A3%85JuiceFS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://z3.ax1x.com/2021/11/30/oQzCRg.png" alt=""></p>
<span id="more"></span>
<p>本文主要记录JuiceFS在debian系统上的编译安装和升级，也记录了在Mac上的安装遇到的问题和解决办法。</p>
<h2 id="安装git工具"><a href="#安装git工具" class="headerlink" title="安装git工具"></a>安装git工具</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install git -y</span><br></pre></td></tr></table></figure>
<p>JuiceFS 客户端使用 Go 语言开发，因此在编译之前，你提前在本地安装好依赖的工具：<br>Go 1.15+<br>GCC 5.4+<br>提示：对于中国地区用户，为了加快获取 Go 模块的速度，建议通过 GOPROXY 环境变量设置国内的镜像服务器。例如：Goproxy China。</p>
<h2 id="下载安装GO"><a href="#下载安装GO" class="headerlink" title="下载安装GO"></a>下载安装GO</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://golang.org/dl/go1.17.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>使用sha256sum工具来验证下载的文件是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sha256sum go1.17.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>确保哈希值与<a href="https://golang.org/dl/">下载页面</a>上的哈希值相同。</p>
<p>设置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.profile</span><br></pre></td></tr></table></figure>
<p>添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure>
<p>保存文件，并将新的PATH环境变量应用于当前的shell会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure>
<p>验证是否安装成功，安装成功显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~# go version</span><br><span class="line">go version go1.17.2 linux/amd64</span><br></pre></td></tr></table></figure>
<h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><p>机器上已经有gcc了，此步骤略过，可以看下网上的安装步骤，很简单。</p>
<h2 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h2><p>进入源代码目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd juicefs</span><br></pre></td></tr></table></figure>
<p>开始编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>编译成功以后，可以在当前目录中找到编译好的 juicefs 二进制程序。</p>
<h2 id="安装JuiceFS"><a href="#安装JuiceFS" class="headerlink" title="安装JuiceFS"></a>安装JuiceFS</h2><p>编译好juicefs的二进制程序后，使用如下命令安装juicefs：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install juicefs /usr/local/bin</span><br></pre></td></tr></table></figure>
<h2 id="升级juicefs"><a href="#升级juicefs" class="headerlink" title="升级juicefs"></a>升级juicefs</h2><p>升级juicefs很简单，直接使用新版本juicefs二进制替换旧版本即可。</p>
<h2 id="Mac上安装juicefs"><a href="#Mac上安装juicefs" class="headerlink" title="Mac上安装juicefs"></a>Mac上安装juicefs</h2><p>Mac上安装JuiceFS可以直接参考文章:<a href="https://juicefs.com/docs/zh/community/juicefs_on_macos">macOS 系统使用 JuiceFS</a> ，不再赘述。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="1-直接用linux设备上的juicefs二进制文件执行报错"><a href="#1-直接用linux设备上的juicefs二进制文件执行报错" class="headerlink" title="1.直接用linux设备上的juicefs二进制文件执行报错"></a>1.直接用linux设备上的juicefs二进制文件执行报错</h3><p><strong>解决办法</strong>：参考文章:<a href="https://juicefs.com/docs/zh/community/juicefs_on_macos">macOS 系统使用 JuiceFS</a>进行操作</p>
<h3 id="2-juicefs-create-mnt-jfs-mkdir-mnt-read-only-file-system"><a href="#2-juicefs-create-mnt-jfs-mkdir-mnt-read-only-file-system" class="headerlink" title="2.juicefs create /mnt/jfs: mkdir /mnt: read-only file system"></a>2.juicefs create /mnt/jfs: mkdir /mnt: read-only file system</h3><p>/mnt是只读的。</p>
<p> <strong>解决办法：</strong> 换一个可读写的挂载目录。</p>
<h3 id="3-fail-to-mount-after-10-seconds-please-mount-in-foreground"><a href="#3-fail-to-mount-after-10-seconds-please-mount-in-foreground" class="headerlink" title="3.fail to mount after 10 seconds, please mount in foreground"></a>3.fail to mount after 10 seconds, please mount in foreground</h3><p><strong>解决办法</strong>：首先需要安装macFUSE，然后重新mount。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo juicefs mount redis://:password@x.x.x.x:6379/1 /tmp/jfs --debug</span><br></pre></td></tr></table></figure>
<p>会弹出提示窗口显示:</p>
<blockquote>
<p>“Please open the Security &amp; Privacy System Preferences pane, go to the General preferences and allow loading system software from developer “Benjamin Fleischer”. A restart might be required before the system extension can be loaded.”</p>
</blockquote>
<p>所以我们需要打开“系统偏好设置”-&gt;“安全与隐私”-&gt;“通用”-&gt;“allow loading system software from developer “Benjamin Fleischer”.” -&gt;“重启电脑”。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/juicedata/juicefs/blob/main/docs/zh_cn/client_compile_and_upgrade.md">JuiceFS 编译安装和升级</a></p>
<p><a href="https://juicefs.com/docs/zh/community/juicefs_on_macos">macOS 系统使用 JuiceFS</a></p>
<p><a href="https://www.modb.pro/db/156742">Apple M1 芯片如何使用 JuiceFS</a></p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>文件存储</tag>
        <tag>JuiceFS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于brpc的stream方式实现双向通信</title>
    <url>/2022/03/12/%E5%9F%BA%E4%BA%8Ebrpc%E7%9A%84stream%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p><img src="https://brpc.incubator.apache.org/images/docs/logo.png" alt=""></p>
<span id="more"></span>
<p>本文先简单介绍一下brpc，然后是brpc官方对stream方式使用的介绍，再看brpc官方的stream方式的使用示例。不过brpc官方示例是client通过stream一直向server发消息，而笔者希望能通过stream进行双向通信，所以对示例进行了修改，以实现client和server的通过stream方式的双向通信。</p>
<h2 id="bRPC简介"><a href="#bRPC简介" class="headerlink" title="bRPC简介"></a>bRPC简介</h2><p>bRPC基础介绍。</p>
<h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC?"></a>什么是RPC?</h3><p>互联网上的机器大都通过TCP/IP协议相互访问，但TCP/IP只是往远端发送了一段二进制数据，为了建立服务还有很多问题需要抽象：</p>
<ul>
<li><p>数据以什么格式传输？不同机器间，网络间可能是不同的字节序，直接传输内存数据显然是不合适的；随着业务变化，数据字段往往要增加或删减，怎么兼容前后不同版本的格式？</p>
</li>
<li><p>一个TCP连接可以被多个请求复用以减少开销么？多个请求可以同时发往一个TCP连接么?</p>
</li>
<li><p>如何管理和访问很多机器？</p>
</li>
<li><p>连接断开时应该干什么？</p>
</li>
<li><p>万一server不发送回复怎么办？<br>…<br>RPC可以解决这些问题，它把网络交互类比为“client访问server上的函数”：client向server发送request后开始等待，直到server收到、处理、回复client后，client又再度恢复并根据response做出反应。<br><img src="https://brpc.incubator.apache.org/images/docs/rpc.png" alt=""><br>我们来看看上面的一些问题是如何解决的：</p>
</li>
<li><p>数据需要序列化，<a href="https://github.com/protocolbuffers/protobuf">protobuf</a>在这方面做的不错。用户填写protobuf::Message类型的request，RPC结束后，从同为protobuf::Message类型的response中取出结果。protobuf有较好的前后兼容性，方便业务调整字段。http广泛使用json作为序列化方法。</p>
</li>
<li><p>用户无需关心连接如何建立，但可以选择不同的<a href="https://brpc.incubator.apache.org/docs/client/basics/#%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">连接方式</a>：短连接，连接池，单连接。</p>
</li>
<li><p>大量机器一般通过命名服务被发现，可基于DNS, ZooKeeper, etcd等实现。在百度内，我们使用BNS (Baidu Naming Service)。brpc也提供“list://“和”file://“。用户可以指定负载均衡算法，让RPC每次选出一台机器发送请求，包括: round-robin, randomized, consistent-hashing(murmurhash3 or md5)和 <a href="https://brpc.incubator.apache.org/docs/rpc-in-depth/locality-aware/">locality-aware</a>.</p>
</li>
<li><p>连接断开时可以重试。</p>
</li>
<li><p>如果server没有在给定时间内回复，client会返回超时错误。</p>
</li>
</ul>
<h3 id="哪里可以使用RPC"><a href="#哪里可以使用RPC" class="headerlink" title="哪里可以使用RPC?"></a>哪里可以使用RPC?</h3><p>几乎所有的网络交互。</p>
<p>RPC不是万能的抽象，否则我们也不需要TCP/IP这一层了。但是在我们绝大部分的网络交互中，RPC既能解决问题，又能隔离更底层的网络问题。</p>
<p>对于RPC常见的质疑有：</p>
<ul>
<li>我的数据非常大，用protobuf序列化太慢了。首先这可能是个伪命题，你得用profiler证明慢了才是真的慢，其次很多协议支持携带二进制数据以绕过序列化。</li>
<li>我传输的是流数据，RPC表达不了。事实上brpc中很多协议支持传递流式数据，包括http中的ProgressiveReader, h2的streams, streaming rpc, 和专门的流式协议RTMP。</li>
<li>我的场景不需要回复。简单推理可知，你的场景中请求可丢可不丢，可处理也可不处理，因为client总是无法感知，你真的确认这是OK的？即使场景真的不需要，我们仍然建议用最小的结构体回复，因为这不大会是瓶颈，并且追查复杂bug时可能是很有价值的线索。</li>
</ul>
<h3 id="什么是brpc"><a href="#什么是brpc" class="headerlink" title="什么是brpc?"></a>什么是brpc?</h3><p>百度内最常使用的工业级RPC框架, 有1,000,000+个实例(不包含client)和上千种服务, 在百度内叫做”baidu-rpc”. 目前只开源C++版本。</p>
<p>你可以使用它：</p>
<ul>
<li>搭建能在一个端口支持多协议的服务, 或访问各种服务</li>
<li>Server能同步或异步处理请求。</li>
<li>Client支持同步、异步、半同步，或使用组合channels简化复杂的分库或并发访问。</li>
<li>通过http界面调试服务, 使用cpu, heap, contention profilers.</li>
<li>获得更好的延时和吞吐.</li>
<li>把你组织中使用的协议快速地加入brpc，或定制各类组件, 包括命名服务 (dns, zk, etcd), 负载均衡 (rr, random, consistent hashing)</li>
</ul>
<h2 id="流式-stream-RPC概述"><a href="#流式-stream-RPC概述" class="headerlink" title="流式(stream)RPC概述"></a>流式(stream)RPC概述</h2><p>在一些应用场景中， client或server需要向对面发送大量数据，这些数据非常大或者持续地在产生以至于无法放在一个RPC的附件中。比如一个分布式系统的不同节点间传递replica或snapshot。client/server之间虽然可以通过多次RPC把数据切分后传输过去，但存在如下问题：</p>
<ul>
<li>如果这些RPC是并行的，无法保证接收端有序地收到数据，拼接数据的逻辑相当复杂。</li>
<li>如果这些RPC是串行的，每次传递都得等待一次网络RTT+处理数据的延时，特别是后者的延时可能是难以预估的。<br>为了让大块数据以流水线的方式在client/server之间传递， 我们提供了Streaming RPC这种交互模型。Streaming RPC让用户能够在client/service之间建立用户态连接，称为Stream, 同一个TCP连接之上能同时存在多个Stream。 Stream的传输数据以消息为基本单位， 输入端可以源源不断的往Stream中写入消息， 接收端会按输入端写入顺序收到消息。<br>Streaming RPC保证：</li>
<li>有消息边界。</li>
<li>接收消息的顺序和发送消息的顺序严格一致。</li>
<li>全双工。</li>
<li>支持流控。</li>
<li>提供超时提醒<br>目前的实现还没有自动切割过大的消息，同一个tcp连接上的多个Stream之间可能有<a href="https://en.wikipedia.org/wiki/Head-of-line_blocking">Head-of-line blocking</a>问题，请尽量避免过大的单个消息，实现自动切割后我们会告知并更新文档。<br>例子见<a href="https://github.com/apache/incubator-brpc/tree/master/example/streaming_echo_c++">example/streaming_echo_c++</a>。</li>
</ul>
<h2 id="建立Stream"><a href="#建立Stream" class="headerlink" title="建立Stream"></a>建立Stream</h2><p>目前Stream都由Client端建立。Client先在本地创建一个Stream，再通过一次RPC（必须使用baidu_std协议）与指定的Service建立一个Stream，如果Service在收到请求之后选择接受这个Stream， 那在response返回Client后Stream就会建立成功。过程中的任何错误都把RPC标记为失败，同时也意味着Stream创建失败。用linux下建立连接的过程打比方，Client先创建socket（创建Stream），再调用connect尝试与远端建立连接（通过RPC建立Stream），远端accept后连接就建立了（service接受后创建成功）。<br>如果Client尝试向不支持Streaming RPC的老Server建立Stream，将总是失败。<br>程序中我们用StreamId代表一个Stream，对Stream的读写，关闭操作都将作用在这个Id上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StreamOptions</span></span><br><span class="line">    <span class="comment">// The max size of unconsumed data allowed at remote side.</span></span><br><span class="line">    <span class="comment">// If |max_buf_size| &lt;= 0, there&#x27;s no limit of buf size</span></span><br><span class="line">    <span class="comment">// default: 2097152 (2M)</span></span><br><span class="line">    <span class="type">int</span> max_buf_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify user when there&#x27;s no data for at least |idle_timeout_ms|</span></span><br><span class="line">    <span class="comment">// milliseconds since the last time that on_received_messages or on_idle_timeout</span></span><br><span class="line">    <span class="comment">// finished.</span></span><br><span class="line">    <span class="comment">// default: -1</span></span><br><span class="line">    <span class="type">long</span> idle_timeout_ms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maximum messages in batch passed to handler-&gt;on_received_messages</span></span><br><span class="line">    <span class="comment">// default: 128</span></span><br><span class="line">    <span class="type">size_t</span> messages_in_batch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle input message, if handler is NULL, the remote side is not allowd to</span></span><br><span class="line">    <span class="comment">// write any message, who will get EBADF on writting</span></span><br><span class="line">    <span class="comment">// default: NULL</span></span><br><span class="line">    StreamInputHandler* handler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Called at the client side]</span></span><br><span class="line"><span class="comment">// Create a Stream at client-side along with the |cntl|, which will be connected</span></span><br><span class="line"><span class="comment">// when receiving the response with a Stream from server-side. If |options| is</span></span><br><span class="line"><span class="comment">// NULL, the Stream will be created with default options</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 otherwise</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StreamCreate</span><span class="params">(StreamId* request_stream, Controller &amp;cntl, <span class="type">const</span> StreamOptions* options)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="读取Stream"><a href="#读取Stream" class="headerlink" title="读取Stream"></a>读取Stream</h2><p>在建立或者接受一个Stream的时候， 用户可以继承StreamInputHandler并把这个handler填入StreamOptions中. 通过这个handler，用户可以处理对端的写入数据，连接关闭以及idle timeout</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamInputHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 当接收到消息后被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">on_received_messages</span><span class="params">(StreamId id, butil::IOBuf *<span class="type">const</span> messages[], <span class="type">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Stream上长时间没有数据交互后被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">on_idle_timeout</span><span class="params">(StreamId id)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Stream被关闭时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">on_closed</span><span class="params">(StreamId id)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一次收到请求的时间<br>在client端，如果建立过程是一次同步RPC， 那在等待的线程被唤醒之后，on_received_message就可能会被调用到。 如果是异步RPC请求， 那等到这次请求的done-&gt;Run() 执行完毕之后， on_received_message就可能会被调用。<br>在server端， 当框架传入的done-&gt;Run()被调用完之后， on_received_message就可能会被调用。</p>
</blockquote>
<h2 id="写入Stream"><a href="#写入Stream" class="headerlink" title="写入Stream"></a>写入Stream</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write |message| into |stream_id|. The remote-side handler will received the</span></span><br><span class="line"><span class="comment">// message by the written order</span></span><br><span class="line"><span class="comment">// Returns 0 on success, errno otherwise</span></span><br><span class="line"><span class="comment">// Errno:</span></span><br><span class="line"><span class="comment">//  - EAGAIN: |stream_id| is created with positive |max_buf_size| and buf size</span></span><br><span class="line"><span class="comment">//            which the remote side hasn&#x27;t consumed yet excceeds the number.</span></span><br><span class="line"><span class="comment">//  - EINVAL: |stream_id| is invalied or has been closed</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StreamWrite</span><span class="params">(StreamId stream_id, <span class="type">const</span> butil::IOBuf &amp;message)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h2><p>当存在较多已发送但未接收的数据时，发送端的Write操作会立即失败(返回EAGAIN）， 这时候可以通过同步或异步的方式等待对端消费掉数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wait util the pending buffer size is less than |max_buf_size| or error occurs</span></span><br><span class="line"><span class="comment">// Returns 0 on success, errno otherwise</span></span><br><span class="line"><span class="comment">// Errno:</span></span><br><span class="line"><span class="comment">//  - ETIMEDOUT: when |due_time| is not NULL and time expired this</span></span><br><span class="line"><span class="comment">//  - EINVAL: the Stream was close during waiting</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StreamWait</span><span class="params">(StreamId stream_id, <span class="type">const</span> timespec* due_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async wait</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamWait</span><span class="params">(StreamId stream_id, <span class="type">const</span> timespec *due_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">void</span> (*on_writable)(StreamId stream_id, <span class="type">void</span>* arg, <span class="type">int</span> error_code),</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="关闭Stream"><a href="#关闭Stream" class="headerlink" title="关闭Stream"></a>关闭Stream</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Close |stream_id|, after this function is called:</span></span><br><span class="line"><span class="comment">//  - All the following |StreamWrite| would fail</span></span><br><span class="line"><span class="comment">//  - |StreamWait| wakes up immediately.</span></span><br><span class="line"><span class="comment">//  - Both sides |on_closed| would be notifed after all the pending buffers have</span></span><br><span class="line"><span class="comment">//    been received</span></span><br><span class="line"><span class="comment">// This function could be called multiple times without side-effects</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StreamClose</span><span class="params">(StreamId stream_id)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="对原始例子的修改"><a href="#对原始例子的修改" class="headerlink" title="对原始例子的修改"></a>对原始例子的修改</h2><p>brpc stream使用的官方原始例子为<a href="https://github.com/apache/incubator-brpc/tree/master/example/streaming_echo_c++">https://github.com/apache/incubator-brpc/tree/master/example/streaming_echo_c++</a>。<br>不过官方的原始例子只是streaming_echo_client端一直往streaming_echo_server端发stream流消息。<br>client.cpp代码为：<a href="https://github.com/apache/incubator-brpc/blob/master/example/streaming_echo_c%2B%2B/client.cpp">streaming_echo_client端代码</a><br>server.cpp代码为：<a href="https://github.com/apache/incubator-brpc/blob/master/example/streaming_echo_c%2B%2B/server.cpp">https://github.com/apache/incubator-brpc/blob/master/example/streaming_echo_c%2B%2B/server.cpp</a></p>
<p>修改后client.cpp代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;butil/logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;brpc/channel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;brpc/stream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;echo.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_bool</span>(send_attachment, <span class="literal">true</span>, <span class="string">&quot;Carry attachment along with requests&quot;</span>);</span><br><span class="line"><span class="built_in">DEFINE_string</span>(connection_type, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Connection type. Available values: single, pooled, short&quot;</span>);</span><br><span class="line"><span class="built_in">DEFINE_string</span>(server, <span class="string">&quot;0.0.0.0:8001&quot;</span>, <span class="string">&quot;IP Address of server&quot;</span>);</span><br><span class="line"><span class="built_in">DEFINE_int32</span>(timeout_ms, <span class="number">100</span>, <span class="string">&quot;RPC timeout in milliseconds&quot;</span>);</span><br><span class="line"><span class="built_in">DEFINE_int32</span>(max_retry, <span class="number">3</span>, <span class="string">&quot;Max retries(not including the first RPC)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClientStreamReceiver</span> : <span class="keyword">public</span> brpc::StreamInputHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">on_received_messages</span><span class="params">(brpc::StreamId id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     butil::IOBuf *<span class="type">const</span> messages[],</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::ostringstream os;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;msg[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; *messages[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Received from Server Stream=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; os.<span class="built_in">str</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">on_idle_timeout</span><span class="params">(brpc::StreamId id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Server Stream=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; has no data transmission for a while&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">on_closed</span><span class="params">(brpc::StreamId id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Server Stream=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is closed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parse gflags. We recommend you to use gflags as well.</span></span><br><span class="line">    GFLAGS_NS::<span class="built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A Channel represents a communication line to a Server. Notice that</span></span><br><span class="line">    <span class="comment">// Channel is thread-safe and can be shared by all threads in your program.</span></span><br><span class="line">    brpc::Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the channel, NULL means using default options.</span></span><br><span class="line">    brpc::ChannelOptions options;</span><br><span class="line">    options.protocol = brpc::PROTOCOL_BAIDU_STD;</span><br><span class="line">    options.connection_type = FLAGS_connection_type;</span><br><span class="line">    options.timeout_ms = FLAGS_timeout_ms<span class="comment">/*milliseconds*/</span>;</span><br><span class="line">    options.max_retry = FLAGS_max_retry;</span><br><span class="line">    <span class="keyword">if</span> (channel.<span class="built_in">Init</span>(FLAGS_server.<span class="built_in">c_str</span>(), <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to initialize channel&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normally, you should not call a Channel directly, but instead construct</span></span><br><span class="line">    <span class="comment">// a stub Service wrapping it. stub can be shared by all threads as well.</span></span><br><span class="line">    <span class="function">example::EchoService_Stub <span class="title">stub</span><span class="params">(&amp;channel)</span></span>;</span><br><span class="line">    brpc::Controller cntl;</span><br><span class="line">    brpc::StreamId stream;</span><br><span class="line">    ClientStreamReceiver _receiver;</span><br><span class="line">    brpc::StreamOptions stream_options;</span><br><span class="line">    stream_options.handler = &amp;_receiver;</span><br><span class="line">    <span class="keyword">if</span> (brpc::<span class="built_in">StreamCreate</span>(&amp;stream, cntl, &amp;stream_options) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to create stream&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Created Stream=&quot;</span> &lt;&lt; stream;</span><br><span class="line">    example::EchoRequest request;</span><br><span class="line">    example::EchoResponse response;</span><br><span class="line">    request.<span class="built_in">set_message</span>(<span class="string">&quot;I&#x27;m a RPC to connect stream&quot;</span>);</span><br><span class="line">    stub.<span class="built_in">Echo</span>(&amp;cntl, &amp;request, &amp;response, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (cntl.<span class="built_in">Failed</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to connect stream, &quot;</span> &lt;&lt; cntl.<span class="built_in">ErrorText</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!brpc::<span class="built_in">IsAskedToQuit</span>()) &#123;</span><br><span class="line">        butil::IOBuf msg1;</span><br><span class="line">        msg<span class="number">1.</span><span class="built_in">append</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>);</span><br><span class="line">        <span class="built_in">CHECK_EQ</span>(<span class="number">0</span>, brpc::<span class="built_in">StreamWrite</span>(stream, msg1));</span><br><span class="line">        butil::IOBuf msg2;</span><br><span class="line">        msg<span class="number">2.</span><span class="built_in">append</span>(<span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line">        <span class="built_in">CHECK_EQ</span>(<span class="number">0</span>, brpc::<span class="built_in">StreamWrite</span>(stream, msg2));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK_EQ</span>(<span class="number">0</span>, brpc::<span class="built_in">StreamClose</span>(stream));</span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;EchoClient is going to quit&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后server.cpp代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gflags/gflags.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;butil/logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;brpc/server.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;echo.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;brpc/stream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DEFINE_bool</span>(send_attachment, <span class="literal">true</span>, <span class="string">&quot;Carry attachment along with response&quot;</span>);</span><br><span class="line"><span class="built_in">DEFINE_int32</span>(port, <span class="number">8001</span>, <span class="string">&quot;TCP Port of this server&quot;</span>);</span><br><span class="line"><span class="built_in">DEFINE_int32</span>(idle_timeout_s, <span class="number">-1</span>, <span class="string">&quot;Connection will be closed if there is no &quot;</span></span><br><span class="line">             <span class="string">&quot;read/write operations during the last `idle_timeout_s&#x27;&quot;</span>);</span><br><span class="line"><span class="built_in">DEFINE_int32</span>(logoff_ms, <span class="number">2000</span>, <span class="string">&quot;Maximum duration of server&#x27;s LOGOFF state &quot;</span></span><br><span class="line">             <span class="string">&quot;(waiting for client to close connection before server stops)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReceiver</span> : <span class="keyword">public</span> brpc::StreamInputHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">on_received_messages</span><span class="params">(brpc::StreamId id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     butil::IOBuf *<span class="type">const</span> messages[],</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::ostringstream os;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            os &lt;&lt; <span class="string">&quot;msg[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; *messages[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Received from client Stream=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; os.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">        butil::IOBuf msg1;</span><br><span class="line">        msg<span class="number">1.</span><span class="built_in">append</span>(<span class="string">&quot;server ===== send to client by stream....&quot;</span>);</span><br><span class="line">        <span class="built_in">CHECK_EQ</span>(<span class="number">0</span>, brpc::<span class="built_in">StreamWrite</span>(id, msg1));</span><br><span class="line">        butil::IOBuf msg2;</span><br><span class="line">        msg<span class="number">2.</span><span class="built_in">append</span>(<span class="string">&quot;server send to client by stream  0123456789&quot;</span>);</span><br><span class="line">        <span class="built_in">CHECK_EQ</span>(<span class="number">0</span>, brpc::<span class="built_in">StreamWrite</span>(id, msg2));</span><br><span class="line">        <span class="comment">//sleep(1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">on_idle_timeout</span><span class="params">(brpc::StreamId id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Stream=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; has no data transmission for a while&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">on_closed</span><span class="params">(brpc::StreamId id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Stream=&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is closed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your implementation of example::EchoService</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamingEchoService</span> : <span class="keyword">public</span> example::EchoService &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StreamingEchoService</span>() : _sd(brpc::INVALID_STREAM_ID) &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">StreamingEchoService</span>() &#123;</span><br><span class="line">        brpc::<span class="built_in">StreamClose</span>(_sd);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Echo</span><span class="params">(google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> example::EchoRequest* <span class="comment">/*request*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                      example::EchoResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                      google::protobuf::Closure* done)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This object helps you to call done-&gt;Run() in RAII style. If you need</span></span><br><span class="line">        <span class="comment">// to process the request asynchronously, pass done_guard.release().</span></span><br><span class="line">        <span class="function">brpc::ClosureGuard <span class="title">done_guard</span><span class="params">(done)</span></span>;</span><br><span class="line"></span><br><span class="line">        brpc::Controller* cntl =</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;brpc::Controller*&gt;(controller);</span><br><span class="line">        brpc::StreamOptions stream_options;</span><br><span class="line">        stream_options.handler = &amp;_receiver;</span><br><span class="line">        <span class="keyword">if</span> (brpc::<span class="built_in">StreamAccept</span>(&amp;_sd, *cntl, &amp;stream_options) != <span class="number">0</span>) &#123;</span><br><span class="line">            cntl-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;Fail to accept stream&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response-&gt;<span class="built_in">set_message</span>(<span class="string">&quot;Accepted stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StreamReceiver _receiver;</span><br><span class="line">    brpc::StreamId _sd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parse gflags. We recommend you to use gflags as well.</span></span><br><span class="line">    GFLAGS_NS::<span class="built_in">ParseCommandLineFlags</span>(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generally you only need one Server.</span></span><br><span class="line">    brpc::Server server;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance of your service.</span></span><br><span class="line">    StreamingEchoService echo_service_impl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the service into server. Notice the second parameter, because the</span></span><br><span class="line">    <span class="comment">// service is put on stack, we don&#x27;t want server to delete it, otherwise</span></span><br><span class="line">    <span class="comment">// use brpc::SERVER_OWNS_SERVICE.</span></span><br><span class="line">    <span class="keyword">if</span> (server.<span class="built_in">AddService</span>(&amp;echo_service_impl,</span><br><span class="line">                          brpc::SERVER_DOESNT_OWN_SERVICE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to add service&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the server.</span></span><br><span class="line">    brpc::ServerOptions options;</span><br><span class="line">    options.idle_timeout_sec = FLAGS_idle_timeout_s;</span><br><span class="line">    <span class="keyword">if</span> (server.<span class="built_in">Start</span>(FLAGS_port, &amp;options) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to start EchoServer&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until Ctrl-C is pressed, then Stop() and Join() the server.</span></span><br><span class="line">    server.<span class="built_in">RunUntilAskedToQuit</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的是在<strong>在建立（StreamCreate方法）或者接受（brpc::StreamAccept(&amp;_sd, *cntl, &amp;stream_options)）一个Stream的时候</strong>， 把<strong>继承StreamInputHandler的具体实现的handler填入StreamOptions中</strong>，然后放入到<strong>StreamCreate方法和StreamAccept方法</strong>。<br>修改后运行streaming_echo_server端打印信息：</p>
<p><img src="https://github.com/ahnselina/temp/blob/main/client.png?raw=true" alt=""></p>
<p><a href="https://github.com/ahnselina/temp/blob/main/client.png">如看不见图片，请直接点击</a></p>
<p>修改后运行streaming_echo_client端打印信息：<br><img src="https://github.com/ahnselina/temp/blob/main/server.png?raw=true" alt=""></p>
<p><a href="https://github.com/ahnselina/temp/blob/main/server.png">如看不见图片，请直接点击</a></p>
<p>通过如上的修改，就达到了client和server端通过stream双向通信的目的 ：)</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://brpc.incubator.apache.org/docs/overview/">brpc简介</a><br><a href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/streaming_rpc.md">brpc stream 官方资料</a></p>
]]></content>
      <categories>
        <category>知识积累</category>
      </categories>
      <tags>
        <tag>brpc</tag>
        <tag>RPC</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>《高效能人士的七个习惯》读书笔记</title>
    <url>/2022/07/12/%E3%80%8A%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E3%80%8B--%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2022/07/12/j2WJET.jpg" alt=""></p>
<span id="more"></span>
<p>本文为《高效能人士的七个习惯》的读书笔记，概要介绍积极主动、以始为终、要事第一、双赢思维、知彼解己、统合综效、不断更新七个习惯，详细的内容请阅读全书。</p>
<h2 id="七个习惯的架构图"><a href="#七个习惯的架构图" class="headerlink" title="七个习惯的架构图"></a>七个习惯的架构图</h2><p><img src="https://s1.ax1x.com/2022/07/12/j2fhYF.md.jpg" alt=""></p>
<h2 id="思维方式与原则"><a href="#思维方式与原则" class="headerlink" title="思维方式与原则"></a>思维方式与原则</h2><p>以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。由内而外的观点认为个人领域的成功必须先于公众领域的成功；只有先信守对自己的承诺，才能信守对他人的承诺。</p>
<p>个人领域的成功依赖如下三个习惯：</p>
<ul>
<li>积极主动</li>
<li>以终为始</li>
<li>要事第一</li>
</ul>
<p>公众领域的成功依赖如下三个习惯：</p>
<ul>
<li>双赢思维</li>
<li>知彼解己</li>
<li>统合综效</li>
</ul>
<p>自我提升和完善依赖习惯七：</p>
<ul>
<li>不断更新</li>
</ul>
<h2 id="个人领域的成功：从依赖到独立"><a href="#个人领域的成功：从依赖到独立" class="headerlink" title="个人领域的成功：从依赖到独立"></a>个人领域的成功：从依赖到独立</h2><h3 id="积极主动"><a href="#积极主动" class="headerlink" title="积极主动"></a>积极主动</h3><p>积极主动即采取主动，为自己过去、现在及未来的行为负责，并依据原则及价值观，而非情绪或外在环境来做决定，积极主动的人是改变的催生者，他们摒弃被动的受伤害者角色，不怨天尤人，发挥了人类的四项独特的禀赋—-自我意识、良知、想象力和意志力，同时以由内而外的方式来创造改变，积极面对一起。积极主动的人选择创造自己的人士，这也是每个人最基本的决定。<br>积极主动不仅仅是指行事的态度，还意味着人要对自己的人生负责。消极被动的人容易受到自然天气的影响，比如风和日丽的时候就兴高采烈，阴云密布的时候就无精打采。而积极主动的人则心中有一片天地，无论阴雨绵绵还是晴空万里都不会对他们产生影响，只有自己的价值观才是关键因素。<br>消极被动的人还会受到“社会天气”的影响，别人以礼相待，他们就笑脸相迎，反之则摆出一副自卫的姿态。</p>
<h3 id="以终为始"><a href="#以终为始" class="headerlink" title="以终为始"></a>以终为始</h3><p>书中这段文字应该令我印象深刻，摘抄于下：</p>
<blockquote>
<p>阅读下面的内容时，请找一个僻静的角落，抛开一切杂念，敞开心扉，跟我走过这段心灵之旅。<br>   假设你正前往殡仪馆的路上，要去参加一位至亲的丧礼。抵达之后，居然发现亲朋好友齐聚一堂，是为了向你告别。亲族代表、友人、同事或社团伙伴，即将上台追述你的生平。<br>现在请认真想一想你希望人们对你以及你的生活有怎样的评价？你是一个称职的丈夫、妻子、父母、子女或亲友吗？你是一个令人怀念的同事或伙伴吗？你希望他们回忆起你的哪些成就和贡献？你希望对周围人的生活施加过什么样的影响？<br>在继续阅读前，请大致记下你的回答和感受，这有助于你理解“以终为始”</p>
</blockquote>
<p>如果你认真走过来上述心灵之旅，那你已经短暂触及了内心深处的某些基本价值观，也和位于影响圈核心的内心指导体系建立了联系。</p>
<ul>
<li><p>以终为始要求我们以人生目标作为衡量一切的标准，你的一言一行、一举一动，无论发生在何时，都必须遵循这一原则，即由个人最重视的期许或价值观来决定一切。牢记自己的目标或者使命，就能确信日常的所作所为是否与之南辕北辙，并且每天都朝着这个目标努力，不敢懈怠。</p>
</li>
<li><p>以终为始说明在做任何事情之前都要先认清方向。</p>
</li>
<li><p>以终为始的另一个原则基础是自我领导，但领导不同于管理。管理是正确地做事，领导则是做正确的事。管理是有效地顺着成功的梯子向上爬，领导则判断这个梯子是否靠在了正确的墙上。</p>
</li>
</ul>
<h3 id="要事第一"><a href="#要事第一" class="headerlink" title="要事第一"></a>要事第一</h3><ul>
<li>要事第一是积极主动和以终为始的具体实践</li>
<li>别让琐事牵着鼻子走</li>
<li>授权—-高效能的秘诀</li>
</ul>
<p>这个习惯中讲述了如何做到要事第一，也就是我们常见的对事情进行分类，比如事情有重要的，不重要的，紧急的，不紧急的，这样可以分为四个象限，比如有紧急不重要的事情，也有重要但不紧急的事情。不要忽视那些重要但不紧急的事情，比如提升自己，这个就是非一日之功，但是这确实是一个非常非常重要的事情。</p>
<h2 id="公众领域的成功：从独立到互赖"><a href="#公众领域的成功：从独立到互赖" class="headerlink" title="公众领域的成功：从独立到互赖"></a>公众领域的成功：从独立到互赖</h2><p>这一部分的习惯集中在阐述如何处理人际关系，下边会分别简要介绍涉及到的三个习惯。</p>
<h3 id="双赢思维"><a href="#双赢思维" class="headerlink" title="双赢思维"></a>双赢思维</h3><p>双赢的原则是所有人际交往的基础。双赢可以使双方互相学习、互相影响及共谋其利。<br>如果实在无法达成共识，实现双赢，就不如好聚好散。</p>
<h3 id="知彼解己"><a href="#知彼解己" class="headerlink" title="知彼解己"></a>知彼解己</h3><p>人际交往方面的另一个原则是知彼解己，也就是首先去寻求了解对方，然后再争取让对方了解自己。这一原则是进行有效人际沟通的关键。</p>
<ul>
<li>移情聆听<br>“知彼”是交往模式的一大转变，因为我们通常把让别人理解自己放在首位。大部分人在聆听时并不是想理解对方，而是为了做出回应。这样的人要么说话，要么准备说话，不断用自己的模式过滤一切，用自己的经历理解别人的生活。如果同儿女、配偶之间的沟通出现了问题，他们的反应通常是：“他就是不理解我。”<br>移情聆听作为聆听的最高层次，是指以理解为目的的聆听，要求听者站在说话者的角度理解他们的思维模式和感受。移情聆听的本质不是要你赞同对方，而是要在情感和理智上充分而深入地理解对方。</li>
</ul>
<h3 id="统合综效"><a href="#统合综效" class="headerlink" title="统合综效"></a>统合综效</h3><p>统合综效是创造性合作的原则。与人合作最重要的是，重视不同个体的不同心理、情绪和智能，以及个人眼中所见到的不同的世界。</p>
<p>统合综效的精髓是尊重差异，当有人不同意你的观点的时候，你应该试着寻找统合综效的第三条路，一般情况下它总是存在的。如果你坚持双赢模式，确实愿意努力理解对方，你大概率就会找到一种让每一个人都受益更多的解决方案。</p>
<p>总体上来说，我们可以以双赢为目标，知彼解己为技巧，统合综效为交往方式来应对阻力，我们大概率会营造出一个让人畅所欲言的环境。</p>
<h2 id="自我提升与完善"><a href="#自我提升与完善" class="headerlink" title="自我提升与完善"></a>自我提升与完善</h2><h3 id="不断更新"><a href="#不断更新" class="headerlink" title="不断更新"></a>不断更新</h3><p>不断更新就是个人产能，它保护并优化你所拥有的最重要的资产—-你自己。<br>自我提升与需要从四个方面来更新：身体、精神、智力、社会/情感。<br><img src="https://s1.ax1x.com/2022/07/14/jfOMCj.jpg" alt=""></p>
<h4 id="身体层面"><a href="#身体层面" class="headerlink" title="身体层面"></a>身体层面</h4><p>锻炼属于第二象限事务，但是由于不具有紧迫性，因此很少人能坚持不懈，结果终有一天我们发现自己陷入了第一象限事务，不得不面对健康问题和危机，而原因正是之前对锻炼的忽视。<br>锻炼不一定要有专门的器材，好的锻炼项目可以在自己家里进行，可以提升的你的耐力、韧性和力量。</p>
<ul>
<li>耐力 源于有氧运动，靠的心血管功能，即心脏向全身供血的能力，快走、跑步、骑车、游泳、越野、滑雪和慢跑等都是可以增强耐力的运动。</li>
<li>韧性 源于伸展运动。很多专家建议在有氧运动前后要分别注意“预热”和“伸展”。预先热身有助于放松肌肉并提高肌肉温度，为强度较大的锻炼做好准备；伸展运动有助于分解乳酸，缓解肌肉酸痛和僵硬感。</li>
<li>力量 源于持久的肌肉运动–比如简单的柔软体操、俯卧撑、引体向上、仰卧起坐和举重。</li>
</ul>
<h4 id="精神层面"><a href="#精神层面" class="headerlink" title="精神层面"></a>精神层面</h4><p>精神层面的更新为你指引人生方向，与“以终为始”习惯密切相关。<br>精神层面是人的本质、核心和对价值体系的坚持，是生活中非常私人而又至关重要的领域。<br>有的人是通过欣赏优秀的文学或音乐作品来实现精神层面的更新，还有些人是通过与自然交流达到同样的目的。大自然会赐福给那些沉浸在自然中的人。当你远离城市的喧嚣与混乱，尽情享受过大自然的和谐和韵律，再回到城市时会感到耳目一新。</p>
<h4 id="智力层面"><a href="#智力层面" class="headerlink" title="智力层面"></a>智力层面</h4><p>我们大多数人的智力发育和学习习惯都源自正规教育。但是一旦脱离了学校的训导，许多人的头脑就会退化：不再认真读书，不再探索身外的新世界，不再用心思考，相反都把时间花在了玩手机（游戏、短视频）上。</p>
<ul>
<li>养成定期阅读优秀文学作品的习惯是拓展思维的最佳方式，人们可以借此接触到当前或者历史上最伟大的思想。</li>
<li>磨砺心智的另一种有效方式是写作。通过不断记录自己的想法、经历、深刻见解和学习心得，我们的思路就会更加明晰、准确和连贯。</li>
</ul>
<h4 id="社会-情感层面"><a href="#社会-情感层面" class="headerlink" title="社会/情感层面"></a>社会/情感层面</h4><p>身体、精神和智力层面与“积极主动、以终为始、要事第一”密切相关，围绕着个人愿景、自我领导和自我管理的原则。而社会/情感层面的重点原则是“双赢思维、知彼解己、统合综效”，围绕着人际交往、移情交流和创造性合作的原则。<br>实践“知彼解己”要求我们先理解别人，我们要做到移情聆听，当我能够像你一样解释你的观点之后，就集中精力阐明我自己的观点，让你也能理解我的观点。<br>习惯“双赢思维、知彼解己、统合综效”的成功关键不是智力问题，而是情感问题，与我们个人的安全感密切相关。至于增强内在安全感的方式，包括：坚持原则，肯定自我；与人为善，相信人生不止输赢两种抉择，还有双方都是赢家的第三种可能。</p>
<p>总而言之，修身励志没有捷径。收获法则始终在发挥着支配作用：种瓜得瓜，种豆得豆，不多也不少。因此，要不断去实践上述七个习惯，使之成为不需要经过刻意注意的习惯。此外还需要注意到自我提升成长是螺旋上升的过程，要实现这个螺旋上升的过程要求我们必须学习、坚持、实践，并沿着螺旋上升的路线不断提高实践的层次。<br>为了不断进步，我们必须学习、坚持、实践—-再学习、再坚持、再实践……</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://book.douban.com/subject/5325618/">高效能人士的七个习惯</a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>高效能</tag>
        <tag>习惯</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统中top与systemctl内存统计差异问题总结</title>
    <url>/2025/02/16/Linux%E7%B3%BB%E7%BB%9F%E4%B8%ADtop%E4%B8%8Esystemctl%E5%86%85%E5%AD%98%E7%BB%9F%E8%AE%A1%E5%B7%AE%E5%BC%82%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h2><p>近日在查看线上业务进程内存达到告警阈值时，发现使用<code>top</code>命令和<code>systemctl status</code>查看服务内存占用时，常出现显著差异。例如：</p>
<ul>
<li><code>systemctl status</code>显示某服务占用12GB内存</li>
<li><code>top</code>显示同一服务RSS仅2GB</li>
</ul>
<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>两者统计维度不同（参考）：</p>
<table>
<thead>
<tr>
<th>工具</th>
<th>统计内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>systemctl status</strong></td>
<td>通过CGroup统计：总内存 = RSS + Page Cache + Swap + 子进程内存 + 共享内存</td>
</tr>
<tr>
<td><strong>top</strong></td>
<td>仅统计进程RSS（Resident Set Size）：实际物理内存占用</td>
</tr>
</tbody>
</table>
<h2 id="二、问题解决过程"><a href="#二、问题解决过程" class="headerlink" title="二、问题解决过程"></a>二、问题解决过程</h2><h3 id="1-关键排查步骤"><a href="#1-关键排查步骤" class="headerlink" title="1. 关键排查步骤"></a>1. 关键排查步骤</h3><h4 id="1-确认内存分布"><a href="#1-确认内存分布" class="headerlink" title="(1) 确认内存分布"></a>(1) 确认内存分布</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看CGroup内存组成</span></span><br><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/memory/&lt;service&gt;/memory.stat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例输出</span></span><br><span class="line">cache 9763553280  <span class="comment"># 9.7GB文件缓存</span></span><br><span class="line">rss 3163029504    <span class="comment"># 3.1GB实际物理内存</span></span><br></pre></td></tr></table></figure>
<p>有的系统如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/fs/cgroup/memory/system.slice/&lt;service&gt;/memory.stat | grep cache</span><br><span class="line"># 示例输出</span><br><span class="line">cache 8624308224</span><br><span class="line">swapcached 0</span><br><span class="line">total_cache 8624308224</span><br><span class="line">total_swapcached 0</span><br><span class="line"></span><br><span class="line"># 示例输出</span><br><span class="line"> cat /sys/fs/cgroup/memory/system.slice/kvmaster.service/memory.stat | grep cache</span><br></pre></td></tr></table></figure></p>
<h4 id="2-分析进程内存映射"><a href="#2-分析进程内存映射" class="headerlink" title="(2) 分析进程内存映射"></a>(2) 分析进程内存映射</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看进程详细内存分配</span></span><br><span class="line">pmap -x &lt;PID&gt; | grep -i <span class="string">&quot;shmem\|anon&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 典型问题场景</span></span><br><span class="line">- 频繁日志滚动（如200MB切分）导致旧文件缓存堆积</span><br><span class="line">- 共享内存未及时释放</span><br></pre></td></tr></table></figure>
<h4 id="3-定位文件缓存来源"><a href="#3-定位文件缓存来源" class="headerlink" title="(3) 定位文件缓存来源"></a>(3) 定位文件缓存来源</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看进程打开的文件</span></span><br><span class="line">lsof -p &lt;PID&gt; | grep REG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析文件缓存热度</span></span><br><span class="line">vmtouch -v /path/to/logs/*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><h4 id="1-日志优化策略"><a href="#1-日志优化策略" class="headerlink" title="(1) 日志优化策略"></a>(1) 日志优化策略</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动日志时释放旧文件缓存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate_log</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* old_path)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(old_path, O_RDONLY);</span><br><span class="line">    <span class="built_in">posix_fadvise</span>(fd, <span class="number">0</span>, <span class="number">0</span>, POSIX_FADV_DONTNEED);  <span class="comment">// 关键代码[1](@ref)</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>合并日志写入：批量代替单条写入</li>
<li>异步日志库：使用spdlog等异步日志组件</li>
</ul>
<h4 id="2-手动释放缓存（临时方案）"><a href="#2-手动释放缓存（临时方案）" class="headerlink" title="(2) 手动释放缓存（临时方案）"></a>(2) 手动释放缓存（临时方案）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安全释放干净页缓存</span></span><br><span class="line"><span class="built_in">sync</span> &amp;&amp; <span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以只用如下命令：</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
<h4 id="3-内核参数调优"><a href="#3-内核参数调优" class="headerlink" title="(3) 内核参数调优"></a>(3) 内核参数调优</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限制脏页驻留（默认30秒→10秒）</span></span><br><span class="line"><span class="built_in">echo</span> 1000 &gt; /proc/sys/vm/dirty_expire_centisecs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制脏页内存占比（默认20%→10%）</span></span><br><span class="line"><span class="built_in">echo</span> 10 &gt; /proc/sys/vm/dirty_ratio</span><br></pre></td></tr></table></figure>
<h4 id="4-CGroup限制（长期方案）"><a href="#4-CGroup限制（长期方案）" class="headerlink" title="(4) CGroup限制（长期方案）"></a>(4) CGroup限制（长期方案）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限制服务内存总量（含Cache）</span></span><br><span class="line"><span class="built_in">echo</span> $((<span class="number">8</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>)) &gt; /sys/fs/cgroup/memory/&lt;service&gt;/memory.limit_in_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有的系统是这样</span></span><br><span class="line"><span class="built_in">echo</span> $((<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>)) &gt; /sys/fs/cgroup/memory/system.slice/&lt;service&gt;/memory.limit_in_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="built_in">echo</span> $((<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>)) &gt; /sys/fs/cgroup/memory/system.slice/kvmaster.service/memory.limit_in_bytes</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="5-验证-Cache-释放效果"><a href="#5-验证-Cache-释放效果" class="headerlink" title="(5) 验证 Cache 释放效果"></a>(5) 验证 Cache 释放效果</h4><h5 id="监控-Cache-变化"><a href="#监控-Cache-变化" class="headerlink" title="监控 Cache 变化"></a>监控 Cache 变化</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 释放前</span></span><br><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/memory/system.slice/kvmaster.service/memory.stat | grep cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放后（等待 10 秒）</span></span><br><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/memory/system.slice/kvmaster.service/memory.stat | grep cache</span><br></pre></td></tr></table></figure>
<h5 id="检查服务性能"><a href="#检查服务性能" class="headerlink" title="检查服务性能"></a>检查服务性能</h5><p>观察服务的 I/O 延迟变化（使用 iostat -x 1）。<br>监控服务的 QPS 和响应时间。</p>
<h2 id="三、问题总结"><a href="#三、问题总结" class="headerlink" title="三、问题总结"></a>三、问题总结</h2><ol>
<li><p><strong>差异合理性</strong><br>当服务涉及文件操作时，<code>systemctl status</code>数值必然大于<code>top</code>显示值，这是Linux内存管理机制的正常现象。</p>
</li>
<li><p><strong>工具选择建议</strong><br>| 场景                  | 推荐工具               |<br>|———————–|————————|<br>| 物理内存压力分析      | <code>top</code>/<code>htop</code>          |<br>| 资源配额监控          | <code>systemd-cgtop</code>       |<br>| 容器/CGroup内存分析   | <code>cat memory.stat</code>     |</p>
</li>
<li><p><strong>优化方向优先级</strong>  </p>
<ul>
<li>程序级优化（日志策略、内存管理）→ <strong>首选</strong></li>
<li>CGroup资源限制 → 防OOM</li>
<li>内核参数调整 → 针对性调优</li>
</ul>
</li>
</ol>
<hr>
<h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><ol>
<li><a href="https://blog.csdn.net/wylfengyujiancheng/article/details/107529412">systemctl与top内存统计差异分析</a>   </li>
<li><a href="https://developer.aliyun.com/article/1152169">Linux内存使用率不一致问题</a>   </li>
<li><a href="https://blog.csdn.net/u013200380/article/details/115082405">free与top内存统计差异解析</a>   </li>
<li><a href="https://www.cnblogs.com/beatle-go/p/17930267.html">内存缓存优化实践</a>   </li>
<li><a href="https://blog.csdn.net/imliuqun123/article/details/126120360">kdump与内存预留机制</a> </li>
</ol>
]]></content>
      <tags>
        <tag>问题定位 内存</tag>
      </tags>
  </entry>
  <entry>
    <title>《Cassandra - A Decentralized Structured Storage System》论文阅读</title>
    <url>/2022/07/16/%20Cassandra%20-%20A%20Decentralized%20Structured%20Storage%20System--%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2022/07/17/jIaF0O.jpg" alt=""></p>
<span id="more"></span>
<p>《Cassandra - A Decentralized Structured Storage System》（Cassandra — 一个去中心的结构化的存储系统）是facebook 2009年左右的论文，facebook参考了AWS dynamo、Google的GFS以及其他更早的分布式系统，借鉴了相关的技术，整合实现了Cassandra（在论文的第二节有描述）。本文主要记录论文《Cassandra - A Decentralized Structured Storage System》的要点。想阅读论文全文的读者可以下载论文，论文下载地址：<a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf">Cassandra - A Decentralized Structured Storage System</a>。如果只是想了解一些Cassandra的基本原理，阅读本文足以，本文基本上就是论文的全文翻译并添加了一些自己的注解。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Cassandra是一个管理分布在很多商业服务器节点上的非常大量的结构化数据的分布式存储系统，同时提供无单点故障的高可用服务。Cassandra目标是在几百个节点上的基础设施上运行（可能分布在不同的数据中心）。达到这样的集群规模后，经常Cassandra是一个管理分布在很多商业服务器节点上的非常大量的结构化数据的分布式存储系统，同时提供无单点故障的高可用服务。Cassandra目标是在几百个节点上的基础设施上运行（可能分布在不同的数据中心）。达到这样的集群规模后，经常会有大大小小的组件出现故障。Cassandra管理持久化的状态会经常面临这些故障，正是这样驱使Facebook的软件系统的可靠性和可伸缩性依赖于该服务。虽然在许多方面Cassandra有点像一个数据库，并且与之共享了许多设计和实现的策略，但是Cassandra并不支持完整的关系数据模型；相反，它为client提供了一个支持动态控制数据布局并且格式简单数据模型。Cassandra系统设计目标是：运行在廉价商业硬件上，高写入吞吐量处理，同时又不用以牺牲读取效率为代价。</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>Facebook运营着最大的社交网络平台，在峰值时候用分布在全球的多个数据中心的成千上万服务器服务了几亿用户。Facebook的平台在性能、可靠性、效率以及平台所需要的支持持续增长（高扩展性）等方面有着严格的运营要求。在包含成千上万个组件的基础设施中处理异常是Facebook运营的标准操作，任何时候都总有一些少量但非常重要的服务器或网络组件会发生故障。因此，软件系统需要一种构建方式，即把故障当做常态来处理而非异常。为了满足上述的可用性和可扩展性，Facebook开发了Cassandra。</p>
<h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2.相关工作"></a>2.相关工作</h2><p>见论文原文，提到了AWS dynamo以及Google的GFS等。</p>
<h2 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3.数据模型"></a>3.数据模型</h2><p>Cassandra中的表是一个分布式的多维的map，由一个key索引。value是一个高度结构化的对象。表中的行键（row key）是一个没有大小限制的字符串，尽管通常情况下是16~36的字节长度。每个副本的单行键（single row key）下的操作都是一个原子操作，不管读或写入了多少列。列被统一放在一个叫做列簇的集合中，这和Bigtable[4]系统的的工作机制很相似。Cassandra 有两种列簇——简单和超级列簇。超级列簇可以用一个列簇内又有一个列簇来形象化表示。</p>
<h2 id="4-API"><a href="#4-API" class="headerlink" title="4.API"></a>4.API</h2><p>Cassandra的API包括以下三个简单的方法.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert(table, key, rowMutation)</span><br><span class="line"></span><br><span class="line">get(table, key, columnName)</span><br><span class="line"></span><br><span class="line">delete(table, key, columnName)</span><br></pre></td></tr></table></figure>
<p>columnName可以是含有列族的一个特殊列, 一个列族，超列族，或者带有超列的一个特定列.</p>
<h2 id="5-系统架构"><a href="#5-系统架构" class="headerlink" title="5.系统架构"></a>5.系统架构</h2><p>需要运行在产品环境中的存储系统的体系架构是复杂的。除了实际的数据持久化组件之外，系统还需要有以下特性：可扩展的且健壮的解决方案，包括负载平衡、成员管理和故障检测、故障恢复、副本同步、过载处理、状态转移、并发和作业调度、请求编组、请求路由、系统监视和报警、以及配置管理。描述上述的每一个解决方案的细节超出了本论文的范围，所以我们只聚焦在Cassandra使用的核心的分布式系统技术上：分区、复制、成员管理、故障处理以及扩展。所有的这些模块都需要共同处理读/写请求。通常一个键的读/写请求需要被发送到Cassandra集群中的任何一个节点上，然后节点判断是否为这个特定键的副本。对于写操作，系统将请求路由到副本并等待法定的副本数目的响应，以确认写操作的完成。对于读取，需要依据用户的一致性需求而定，系统要么将请求路由到最近的副本上或者路由到所有副本并等待法定的副本数目的响应。</p>
<h3 id="5-1-Partition-分区"><a href="#5-1-Partition-分区" class="headerlink" title="5.1 Partition(分区)"></a>5.1 Partition(分区)</h3><p>Cassandra 一个关键的设计特性就是持续扩展的能力。这要求动态将数据分区到集群中各个节点（即存储主机）的能力。Cassandra 整个集群上的数据分区用的是一致性哈希[11]，但是使用了保序哈希函数来达到这一点。在一致性哈希算法中，一个散列函数输出范围被当作一个固定的圆形空间或‘环’来对待（即最大散列值之后为最小散列值）（有点类似Dynamo系统）。系统中的每一个节点被赋予一个在这一空间内表示其圆环的位置的随机值。每一个数据项通过键（key）来标识，通过hash数据项的键来确定环上的位置，在环上顺时针找到大于这个位置的第一个节点，这样通过key标识的数据项就分配给这个节点管理。这个节点被认为是这个key的协调者。应用指定key，Cassandra用这个key来路由请求。因此，每个节点就负责环上的它的前驱节点到它自身之间的这段区域。</p>
<ul>
<li>一致性哈希的最大好处是有节点加入或者离开都只影响相邻的节点，其他节点不受影响。<br>当然最基础的一致性哈希也有问题，比如：</li>
</ul>
<ol>
<li>每个节点被hash的随机位置，这会导致数据和负载的分布不均匀</li>
<li>基本的一致性哈希忽略了每个节点性能的异构性（意思是不同的节点可能性能是不一样的，比如配置都不一样）<br>通常有两种办法解决上述的问题：</li>
<li>像Dynamo一样，增加虚拟节点，即一个物理节点对应多个虚拟节点，然后把虚拟节点映射到环上</li>
<li>分析环上节点的负载信息，移动环上轻负载的节点去减轻重负载节点的负载（如论文中参考文献[17]中讲述的）<br>Cassandra选了第二个方法，因为第二个方法使得设计和实现都比较简单并且有助于对负载平衡做出非常确定性的选择。</li>
</ol>
<h3 id="5-2-Replication-复制"><a href="#5-2-Replication-复制" class="headerlink" title="5.2 Replication(复制)"></a>5.2 Replication(复制)</h3><p>Cassandra使用复本来达到高可用和持久性。每一个数据项都会被复制到N个机器上，N是“每个实例”配置的复本因子（译者注：就是说每个实例都可以配置参数指定每项数据存多少个复本，比如我们常见的三复本）。每个key(k)被分配到协调节点（前面的章节有描述）。协调节点管理它负责范围内的数据项的复制。协调节点除了把它负责的数据存在本地外，还负责把数据到复制到环上的其他N-1个节点。Cassandra提供了许多复制策略，比如“Rack Unaware”, “Rack Aware” (在一个数据中心内) 以及 “Datacenter Aware”。选择哪些复本是由应用的选择的复本策略决定的。如果某个应用选择了 “Rack Unaware”复本策略，那么非协调节点的复本选择的是环上协调节点的N-1个后继节点（译者注：简单地说，比如三复本，通过本论文的一致性哈希确定了协调节点，协调节点上存一个复本，另外两个复本就选协调节点顺时针方向后面两个节点来存）。选 “Rack<br>Aware” 和 “Datacenter Aware”策略，算法会稍微复杂一些。Cassandra使用Zookeeper来选出一个leader节点。加入集群的所有节点都需要连接leader节点，leader节点告诉这些节点他们负责哪些范围的复本，并且致力于保持环上没有节点会负责超出N-1的范围。节点负责的范围的元数据被缓存在每个节点本地，并且为了容错，在Zookeeper内也保存了这个元数据（译者注：其实可以理解为元数据在本地有缓存，为了防止元数据丢失，也持久化到了Zookeeper）— 这样当一个节点挂掉重启后就知道它负责哪个范围。借用Dynamo的说法，我们认为负责给定范围的节点是这个范围的“优先列表”（译者注：这个优先列表就是指比如三复本，是哪三个server来负责这个范围的数据的server列表）。</p>
<p>正如在5.1章节中所阐述的那样， 每一个节点都能感知到系统内其它任意一个节点的存在，因此也知道它们这个系统所负责的范围。Cassandra通过放松第5.2节中所述的仲裁需求，在存在节点故障和网络分区时提供了耐久性保证。数据中心故障通常是由于电力中断、冷却系统失效、网络中断以及自然灾害等。Cassandra可以被配置成每一条数据都进行跨数据中心的复制。其本质是构建一个数据的“优先列表”，这“优先列表”的存储节点是跨数据中心的。这些数据中心通过高速网络连接起来。这种跨多个数据中心复制的方案允许我们在面临某个数据中心故障的时候做到业务不中断。</p>
<h3 id="5-3-Membership-成员管理"><a href="#5-3-Membership-成员管理" class="headerlink" title="5.3 Membership(成员管理)"></a>5.3 Membership(成员管理)</h3><p>Cassandra中的集群成员基于Scuttlebutt[19]，一种非常有效的反熵Gossip（anti-entropy Gossip，一种Gossip算法）机制。Scuttlebutt最显著的特性是它对CPU利用非常高效以及非常高效地使用Gossip channel。在Cassandra系统中，Gossip不仅用于成员管理，还用与传播其他的系统相关状态。</p>
<h4 id="5-3-1-故障检测"><a href="#5-3-1-故障检测" class="headerlink" title="5.3.1 故障检测"></a>5.3.1 故障检测</h4><p>故障检测是一种节点可以在本地确定系统中其他节点是死是活的机制。在Cassandra中，故障检测也被用于避免在各种操作中尝试与无法到达的节点进行通信。Cassandra使用了Φ Accrual故障检测器[8]的一个改良版本。Accrual故障检测器的目标是故障检测模块不用布尔值来代表节点的存活状态。相反，故障检测模块为每一个被监控的节点生成一个代表其被怀疑故障水平的值。这个值被定义为Φ。其基本思想是这个反应节点被怀疑故障水平的值的范围是动态变化的，以反应被监控节点的网络与负载情况。<br>Φ有以下含义：给定某个阈值Φ，假设我们决定在Φ=1时怀疑节点a（故障），那么我们犯错误的可能性（即，该决定将在未来与接收到延迟的心跳相矛盾）的可能性约为10%。Φ=2时，犯错的可能性约为1%，Φ=3时的可能性约为0.1%，以此类推。系统中每个节点都维护了一个其他节点发出的gossip消息的内部到达时间的滑动窗口。根据内部到达时间间隔的分布，计算Φ值。尽管初稿中说分布近似为高斯分布(Gaussian distribution)，但是我们发现其实它更接近于指数分布(Exponential Distribution)，因为gossip channel本身的特性和它对延迟的影响，所以它更符合指数分布。据我们所知，我们的基于Gossip的环境的Accrual故障检测的实现是首创。Accrual故障检测器的准确性和速度都非常好并且它们可以很好的适应不同的网络状况和服务器负载状况。</p>
<h3 id="5-4-Bootstrapping-启动"><a href="#5-4-Bootstrapping-启动" class="headerlink" title="5.4 Bootstrapping(启动)"></a>5.4 Bootstrapping(启动)</h3><p>当一个节点第一次启动时，它为它所在环上的位置随机生成一个token（译者注：猜测是一个伪随机值，通过某种hash算法得到的）。出于容错，节点与环上位置(token)的映射关系被持久化到本地硬盘和Zookeeper中。然后这个token信息在集群中通过gossip协议传播开来。这样我们就能知道集群中所有的节点以及他们在环上相对的位置。这样使得任意一个节点都可以把某一个key的请求路由到集群中正确的节点。在节点启动的场景，当一个节点需要加入集群时，它需要读取自己的配置文件，文件中包含集群中几个联系的节点信息。我们把这些初始联系的节点称为集群的种子。种子也可以来自于像Zookeeper之类的配置服务。<br><strong>译者注：这段内容的简单地说，就是一个节点启动的时候会通过某种hash算法，把节点hash到环的某个位置，然后这个位置信息会通过gossip协议发送给集群中其他节点。然后节点刚开始启动的时候，需要去读配置文件连接集群的初始节点，这些初始节点估计就是Zookeeper节点，其实就是需要加入集群的节点都要去连Zookeeper，把相关信息写入到Zookeeper。</strong><br>在Facebook的环境中（由于故障或者维护引起的）节点中断经常都是暂时的，但也有可能会持续长一些时间（译者注：这意思就是其实遇到的节点故障大多是暂时的，过一会就恢复了，少量长时间都无法恢复的，当然这样对待这些节点也就可以分别对待，根据不同的情况进行不同的处理）。引发故障的形式也多种多样，比如磁盘故障、CPU损坏等。一个节点的断开很少意味着它会永久断开，因此不应该导致重新平衡分区指派或修复不可到达的副本。类似地，人为失误可能导致新的Cassandra节点意外启动。为此，每条信息都包含了每个Cassandra实例的集群名称。如果配置中的人为失误导致一个节点尝试去加入一个错误的Cassandra实例，那么它可以由集群名称不正确而被阻止。<br>由于这些原因，我们认为使用显示机制来从Cassandra实例上初始化添加和删除节点是合适的。管理员使用命令行工具或浏览器连接到一个Cassandra 节点，并发起一次成员变更来加入或离开集群。</p>
<h3 id="5-5-Scaling-the-Cluster-集群扩展"><a href="#5-5-Scaling-the-Cluster-集群扩展" class="headerlink" title="5.5 Scaling the Cluster(集群扩展)"></a>5.5 Scaling the Cluster(集群扩展)</h3><p>当一个新的节点被添加到系统中时，它将被分配一个token（挨着高负荷节点的token），以便它可以缓解高负荷节点(的压力)。这会导致新节点分拆了一部分某一个节点先前负责的范围。Cassandra启动是操作员用命令行工具或Cassandra网页界面操作启动的。节点放弃使用stream传播数据到新节点的方式，而使用的是内核拷贝技术。运行经验表明数据可以在单个节点中以40MB/秒的速率进行传输。我们正在努力通过让多个复制副本参与启动传输来改进这一点，从而并行化工作，类似于Bit torrent。</p>
<h3 id="5-6-Local-Persistence-本地持久化"><a href="#5-6-Local-Persistence-本地持久化" class="headerlink" title="5.6 Local Persistence(本地持久化)"></a>5.6 Local Persistence(本地持久化)</h3><p>Cassandra依赖于本地文件系统来做数据持久化。数据用一种高效读取格式存放在硬盘上。出于持久性和可恢复性考虑，通常写操作将会涉及到两个操作：</p>
<ol>
<li>往磁盘上写入一条提交日志（Commit Log）</li>
<li>在内存的数据结构上去更新数据<br>这个往内存的数据结构里面的数据更新，只有在提交日志写成功之后才会进行。我们每台机器上都有个专门的盘用来写提交日志（Commit Log），因为所有写入提交日志是顺序的（译者注：即Cassandra的写Commit Log的操作是顺序写而不是随机写，顺序写比随机写性能高很多），所以可以最大限度的利用磁盘吞吐量。当内存数据结构大小（根据数据大小和数量计算得出）超过一定阈值，就会把数据dump到磁盘上。这个写操作是在每台机器配备的许多商业硬盘中的一个上进行的。所有写入到磁盘都是顺序写，并且生成了一个基于行键（row key）可进行高效检索的索引。这些索引也会同数据文件一起持久化。随着时间的推移，在磁盘上可能会存在很多这样的文件，后台会有一个合并进程将这些文件合并成一个文件。这个进程和Bigtable系统中的压缩(Compaction)进程非常相似。<br>一个典型的读取操作首先查询内存中的数据结构，然后查看磁盘上的文件。文件是以从新到旧的顺序进行查找的。当发生磁盘查找时，我们可能需要在磁盘上的多个文件中去查找某个key。为了避免查找不包含该key的文件，汇总了文件中所有key的布隆过滤器（译者：关于布隆过滤器可以自行搜索了解）被存到每一个文件中并将该布隆过滤器保存在内存中。查找一个key的时候，首先去通过布隆过滤器来检查key是否在给定的文件中。一个列簇中的key可能会包含很多列。当列离key比较远时，还需要特殊的索引来获取这些列。为了防止扫描磁盘上的每一列，我们维护的特殊的列索引，可以允许我们直接跳到磁盘上正确的块来获取列。当给定key的列被系列化并被写入到磁盘后，我们会以每256K大小为范围生成一个索引。这个大小是可以配置的，但是我们发现在实际产品负载环境下中，256K大小工作良好。</li>
</ol>
<h3 id="5-7-Implementtation-Details-实现细节"><a href="#5-7-Implementtation-Details-实现细节" class="headerlink" title="5.7 Implementtation Details(实现细节)"></a>5.7 Implementtation Details(实现细节)</h3><p>一台机器上的Cassandra进程主要包含如下抽象：分区模块，集群成员管理，故障检测模块以及存储引擎模块。所有这些模块都依赖于一个事件驱动的底层模块,它按照SEDA[20]架构设计,将消息处理管道与任务管道切分成了多个阶段。所有这些模块完全用Java实现。集群成员管理和故障检测模块建立在使用非堵塞IO的网络层之上。所有系统控制消息依赖于基于UDP协议的消息传输，而复制与请求路由等应用相关的消息则依赖于TCP协议。请求路由模块使用一个固定状态机来实现。当一个读/写请求到达任何集群中的节点时状态机将会在以下几个状态切换：<br>（i）识别节点是否拥有给定key的数据<br>（ii）将请求路由到节点并等待响应返回<br>（iii）如果复本在配置超时时间内没有到达，将请求设置为失败并返回客户端<br>（iv）根据时间戳分辨出最后到达的响应<br>（v）如果数据并不是最新的，则调度安排数据修复。<br>为了便于说明，这里不讨论故障场景。系统可以把写操作配置为配置为同步写或者异步写。对于某些需要高吞吐量的系统，我们依赖异步复制策略（异步写）。这种情况下,系统的写操作远远超过系统读操作。在同步的情况下，我们需要等待指定仲裁数目的响应返回后才能将结果返回到客户端。</p>
<p>在任何日志系统中都需要有一个清除提交日志条目的机制。在Cassandra中，我们使用滚动提交日志，在旧的提交日志超过特定的、可配置的大小后，就会推出新的提交日志（译者注：个人理解是新的日志覆盖旧的的日志）。我们发现每128MB滚动提交日志在生产环境中负载良好。每个提交日志都有一个头，它基本上是一个位向量，它的大小是固定的，通常超过一个特定系统将处理的列族的数量。在我们的实现中，我们有一个内存中的数据结构和一个由每个列族生成的数据文件。每次将特定列族的内存中数据结构dump到磁盘时，我们都会在提交日志中设置它的位，以表明该列族已成功持久化到磁盘。这就表明这条信息已经被提交。每份提交日志都有一份这些位向量同时也在内存中维护一份。每当发生提交日志滚动的时候,它的位向量,以及它之前滚动的提交日志的位向量都会进行检查。如果认为所有数据已经被成功持久化到磁盘之后这些日志才会被删除。对提交日志的写入操作可以是正常模式也可以是快速同步模式。在快速同步模式下，写到提交日志会被写到buffer中，这就意味着当机器crash时存在数据丢失的潜在风险（译者注：这跟RocksDB很像，读写机制都是，采用LSM tree）。在这种模式下，将内存中的数据结构dump到磁盘也采用了buffer的方式。传统数据库的设计并不是用来处理特别高的写吞吐量的。Cassandra将所有的写入操作都转换成顺序写以最大限度地利用磁盘的写入吞吐量。由于dump到磁盘的文件不再会被修改,所以在读取它们的时候也不需要加锁。Cassandra 服务器读/写操作实际上并没有加锁，因此我们不需要处理在以B-Tree实现的数据库中存在的并发问题。</p>
<p>Cassandra系统根据主键(primary key)来索引所有数据。磁盘上的数据文件被分成一系列的块。每个块最多包含128个key，并由一个块索引来划分。块索引捕获块内的一个键的相对偏移量及其数据的大小。当内存数据结构dump到磁盘上时，（系统）将会产生一个块索引,并把它们的偏移量作为索引写入磁盘。为了快速访问，内存中同样维护一份索引。一个典型的读取操作会先在内存的数据结构进行查找。如果找到数据，将会把数据返回应用，因为内存数据结构包括了key的最新数据。如果没有找到（对应的数据），我们则会使用磁盘I/O按照时间逆序对所有磁盘上的数据文件进行查找。由于我们总是查找最新的数据，所以我们首先在最新文件进行查找一旦找到数据就返回。随着时间的推移，磁盘上的数据文件的数量越来越多。我们将进行压缩处理，非常类似于Bigtable系统中所做的一样——将多个文件合并成一个，本质上对一堆排序的数据文件进行合并排序（merge sort或者叫归并排序）。系统始终总是压缩和大小彼此相近的文件，例如,永远不会出现一个100GB的文件与另一个小于50GB的文件进行合并的情形。周期性地就会运行一个主压缩线程来将所有相关数据文件压缩成一个大文件。这个压缩进程是一个磁盘I/O密集型操作，因此需要对此做大量的优化以做到不影响后续的读请求。</p>
<h2 id="6-实践经验"><a href="#6-实践经验" class="headerlink" title="6. 实践经验"></a>6. 实践经验</h2><p>在Cassandra的设计、实现以及维护过程中我们积累了很多有用的经验也学到了许多教训。其中一个非常基本的教训就是在没有搞清楚应用想要的使用效果之前不要急着添加新功能。大多数有问题的场景并不仅仅源于节点崩溃和网络分区。我们在这里只分享一些有趣的场景。</p>
<ul>
<li><p>在启动 Inbox Search应用之前，我们必须对超过1亿用户大约7TB的收件箱数据进行索引，将他们保存在我们的MySQL[1]基础设施上，然后将其加载到Cassandra系统中。整个过程涉及到对MySQL数据文件进行Map/Reduce[7]调度；建立索引，然后将反向索引保存到Cassandra中。实际上,M/R进程是作为Cassandra的客户端运行的。我们为M/R进程公开了一些后台通道，以聚合每个用户的反向索引，并将序列化的数据发送到Cassandra实例，以避免序列化/反序列化开销。这样Cassandra实例的瓶颈就只剩下网络带宽了</p>
</li>
<li><p>大多数应用只需要每个key的每个副本的原子操作。然而，也有一些应用程序要求事务性的特性，主要是为了维护辅助索引(secondary indices)。大多数拥有多年RDBMS开发经验的开发人员都发现这是一个非常有用的特性。我们正在研究一种机制来实现此类原子操作。</p>
</li>
<li><p>我们实验了故障检测器的各种实现，如在[15]和[5]中描述的那些。我们的经验是，随着集群大小的增加，检测故障的时间增加，最终会超过可接受的范围。在一个特定的包含100个节点的实验中,检测一个故障节点竟然耗费大约2分钟的时间。这在我们实际的运行环境中是行不通的。采用accrual故障检测器并设置一个稍显保守的PHI(Φ)值(设置为5),在上面的实验中检测到故障的平均时间大约为15秒。</p>
</li>
<li><p>监控不能被认为是理所当然的。Cassandra系统很好的集成了Ganglia[12]——一个分布式性能监测工具。我们向Ganglia开放了各种系统级别的指标，这在我们将Cassandra部署到生产环境时，帮助我们对这个系统的行为有了更深的理解。磁盘可能会无缘无故的发生故障。当磁盘出现故障，启动算法中有hooks可以修复节点，然而这实际上是一个管理操作。</p>
</li>
<li><p>虽然Cassandra是一个完全的去中心化的系统，但是我们已经了解到，有一定程度的协调对于使一些分布式特性的实现易于处理是必不可少的。比如Cassandra集成了可以用于大规模分布式系统中的各种协调任务的Zookeeper。我们打算用Zookeeper来抽象一些关键特性，而这些关键特性并不出现在使用Cassandra作为存储引擎的应用中。</p>
</li>
</ul>
<h3 id="6-1-Facebook-Inbox-Search"><a href="#6-1-Facebook-Inbox-Search" class="headerlink" title="6.1 Facebook Inbox Search"></a>6.1 Facebook Inbox Search</h3><p>对于收件箱搜索(Inbox Search)，我们维护邮件发件人和收件人之间交换的所有邮件的每个用户索引。目前已经启用了两种搜索功能：<br>(a)短语搜索<br>(b)交互——给定一个人的名字，它将返回用户可能从该人那里发送或收到的所有消息。该模式由两个列族组成。<br>对于查询(a)，用户id是key，组成消息的单词成为超级列。包含该词的消息的单个消息标识符将成为超级列中的列。对于查询(b)，用户id是key，收件人id是超级列。对于每个超级列，单独的消息标识符都是列。为了使搜索快速，Cassandra为数据的智能缓存提供了某些hooks。比如,当用户点击搜索工具栏的时候就会异步地发生消息到Cassandra集群，以便事先准备用户索引的cache。这样，当执行实际的搜索查询时，搜索结果很可能已经在内存中了。该系统目前在一个150个节点的集群上存储了约50+TB的数据，该集群分布在东海岸和西海岸的数据中心之间。我们展示了一些关于读取性能的生产测量数字。</p>
<table>
<thead>
<tr>
<th>时延统计</th>
<th>交互搜索</th>
<th>短语搜索</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小</td>
<td>7.69ms</td>
<td>7.78ms</td>
</tr>
<tr>
<td>平均</td>
<td>15.69ms</td>
<td>18.27ms</td>
</tr>
<tr>
<td>最大</td>
<td>26.13ms</td>
<td>44.41ms</td>
</tr>
</tbody>
</table>
<h2 id="7-总结展望"><a href="#7-总结展望" class="headerlink" title="7.总结展望"></a>7.总结展望</h2><p>我们已经构建、实现和运营了一个提供可扩展性、高性能和广泛适用性的存储系统。我们已经通过经验证明，Cassandra可以支持非常高的更新吞吐量（写吞吐），同时提供低延迟。未来的工作包括添加压缩、跨键支持原子性的能力和辅助索引支持。</p>
<h2 id="8-致谢"><a href="#8-致谢" class="headerlink" title="8.致谢"></a>8.致谢</h2><p>略</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cs.cornell.edu/projects/ladis2009/papers/lakshman-ladis2009.pdf">Cassandra - A Decentralized Structured Storage System</a></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>分布式存储</tag>
        <tag>经典论文</tag>
        <tag>Cassandra</tag>
        <tag>一致性哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你了解虚拟化、虚拟机、Docker及裸金属服务器</title>
    <url>/2022/07/23/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E5%8C%96%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81Docker%E5%8F%8A%E8%A3%B8%E9%87%91%E5%B1%9E%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2022/07/31/vktHDs.jpg" alt=""></p>
<span id="more"></span>
<p>本文主要介绍虚拟化、虚拟机、Docker与常见的虚拟化技术的区别，以及什么是裸金属。</p>
<h2 id="什么是虚拟化？"><a href="#什么是虚拟化？" class="headerlink" title="什么是虚拟化？"></a>什么是虚拟化？</h2><p>借助虚拟化技术，用户能以单个物理硬件系统为基础创建多个模拟环境或专用资源。称为<a href="https://www.redhat.com/zh/topics/virtualization/what-is-a-hypervisor">“Hypervisor”</a> （虚拟机监控程序）的软件可直接连接到硬件，从而将一个系统划分为不同的、单独安全环境，即<a href="https://www.redhat.com/zh/topics/virtualization/what-is-a-virtual-machine">虚拟机（VM）</a>。虚拟机监控程序能够将计算机资源与硬件分离并适当分配资源，这一功能对虚拟机十分重要。虚拟化可以帮助您充分利用先前所做的投资。</p>
<p>配备了虚拟机监控程序的物理硬件叫做”主机”，而使用其资源的虚拟机则被称为虚拟客户机。这些虚拟客户机将计算资源（如 CPU、内存和<a href="https://www.redhat.com/zh/topics/data-storage">存储器</a>）视为一组可进行重新分配的资源。操作员可以控制 CPU、内存、存储器和其他资源的虚拟实例，以便虚拟客户机能在需要时收到所需资源。</p>
<h2 id="通过虚拟化可以实现什么目标？"><a href="#通过虚拟化可以实现什么目标？" class="headerlink" title="通过虚拟化可以实现什么目标？"></a>通过虚拟化可以实现什么目标？</h2><h3 id="网络功能虚拟化"><a href="#网络功能虚拟化" class="headerlink" title="网络功能虚拟化"></a>网络功能虚拟化</h3><p>可以从一个原始网络创建多个隔离的虚拟网络。</p>
<h3 id="服务器虚拟化"><a href="#服务器虚拟化" class="headerlink" title="服务器虚拟化"></a>服务器虚拟化</h3><p>一台服务器可以充当几台甚至几百台服务器的角色。</p>
<h3 id="操作系统虚拟化"><a href="#操作系统虚拟化" class="headerlink" title="操作系统虚拟化"></a>操作系统虚拟化</h3><p>一台电脑可以运行多个不同的操作系统。</p>
<h2 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h2><p><strong>虚拟机技术是虚拟化技术的一种</strong></p>
<p><strong>虚拟机</strong>（Virtual Machine）技术，其实就是指在现有硬件的操作系统上，能够<strong>模拟</strong>一个计算机系统的技术。而模拟一个计算机系统，最简单的办法，其实不能算是虚拟机技术，而是一个模拟器（Emulator）。</p>
<h3 id="解释型虚拟机"><a href="#解释型虚拟机" class="headerlink" title="解释型虚拟机"></a>解释型虚拟机</h3><p>要模拟一个计算机系统，最简单的办法，就是兼容这个计算机系统的指令集。我们可以开发一个应用程序，跑在我们的操作系统上。这个应用程序呢，可以识别我们想要模拟的、计算机系统的程序格式和指令，然后一条条去解释执行。</p>
<p>在这个过程中，我们把原先的操作系统叫作<strong>宿主机</strong>（Host），把能够有能力去模拟指令执行的软件，叫作<strong>模拟器</strong>（Emulator），而实际运行在模拟器上被“虚拟”出来的系统呢，我们叫<strong>客户机</strong>（Guest VM）。</p>
<p>这个方式，其实和运行 Java 程序的 Java 虚拟机很像。只不过，Java 虚拟机运行的是 Java 自己定义发明的中间代码，而不是一个特定的计算机系统的指令。</p>
<p>这种解释执行另一个系统的方式，有没有真实的应用案例呢？当然是有的，如果你是一个 Android 开发人员，你在开发机上跑的 Android 模拟器，其实就是这种方式。如果你喜欢玩一些老游戏，可以注意研究一下，很多能在 Windows 下运行的游戏机模拟器，用的也是类似的方式。</p>
<p><strong>这种解释执行方式的最大的优势就是，模拟的系统可以跨硬件。</strong>比如，Android 手机用的 CPU 是 ARM 的，而我们的开发机用的是 Intel X86 的，两边的 CPU 指令集都不一样，但是一样可以正常运行。如果你想玩的街机游戏，里面的硬件早就已经停产了，那你自然只能选择 MAME 这样的模拟器。</p>
<h3 id="Type-1-和-Type-2：虚拟机的性能提升"><a href="#Type-1-和-Type-2：虚拟机的性能提升" class="headerlink" title="Type-1 和 Type-2：虚拟机的性能提升"></a>Type-1 和 Type-2：虚拟机的性能提升</h3><p>为了在现有的物理服务器的硬件和操作系统上，去跑一个完整的、不需要做任何修改的客户机操作系统（Guest OS），加入了一个中间层。在虚拟机技术里面，这个中间层就叫作<strong>虚拟机监视器</strong>，英文叫 VMM（Virtual Machine Manager）或者 Hypervisor。</p>
<p><img src="https://s1.ax1x.com/2022/07/31/vktmBn.jpg" alt=""><br>我们先来看 Type-2 类型的虚拟机。在 Type-2 虚拟机里，我们上面说的虚拟机监视器好像一个运行在操作系统上的软件。你的客户机的操作系统呢，把最终到硬件的所有指令，都发送给虚拟机监视器。而虚拟机监视器，又会把这些指令再交给宿主机的操作系统去执行。Type-2 型的虚拟机，更多是用在我们日常的个人电脑里，而不是用在数据中心里。</p>
<p><img src="https://s1.ax1x.com/2022/07/31/vktaAx.jpg" alt=""></p>
<p>在数据中心里面用的虚拟机，我们通常叫作 Type-1 型的虚拟机。这个时候，客户机的指令交给虚拟机监视器之后呢，不再需要通过宿主机的操作系统，才能调用硬件，而是可以直接由虚拟机监视器去调用硬件。</p>
<p>另外，在数据中心里面，我们并不需要在 Intel x86 上面去跑一个 ARM 的程序，而是直接在 x86 上虚拟一个 x86 硬件的计算机和操作系统。所以，我们的指令不需要做什么翻译工作，可以直接往下传递执行就好了，所以指令的执行效率也会很高。</p>
<p>所以，在 Type-1 型的虚拟机里，我们的虚拟机监视器其实并不是一个操作系统之上的应用层程序，而是一个嵌入在操作系统内核里面的一部分。无论是 KVM、XEN 还是微软自家的 Hyper-V，其实都是系统级的程序。</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>虽然，Type-1 型的虚拟机看起来已经没有什么硬件损耗。但是，这里面还是有一个浪费的资源。在我们实际的物理机上，我们可能同时运行了多个的虚拟机，而这每一个虚拟机，都运行了一个属于自己的单独的操作系统。</p>
<p>多运行一个操作系统，意味着我们要多消耗一些资源在 CPU、内存乃至磁盘空间上。那我们能不能不要多运行的这个操作系统呢？</p>
<p>其实是可以的。因为我们想要的未必是一个完整的、独立的、全虚拟化的虚拟机。我们很多时候想要租用的不是“独立服务器”，而是独立的计算资源。在服务器领域，我们开发的程序都是跑在 Linux 上的。其实我们并不需要一个独立的操作系统，只要一个能够进行资源和环境隔离的“独立空间”就好了。那么，能够满足这个需求的解决方案，就是过去几年特别火热的 Docker 技术。使用 Docker 来搭建微服务，可以说是过去两年大型互联网公司的必经之路了。</p>
<p><img src="https://s1.ax1x.com/2022/07/31/vktB9O.jpg" alt="图片"></p>
<p>不过严格来说，Docker 并不能算是一种虚拟机技术，而只能算是一种资源隔离的技术而已。</p>
<h2 id="裸金属服务器"><a href="#裸金属服务器" class="headerlink" title="裸金属服务器"></a>裸金属服务器</h2><p>裸金属全称为裸金属服务器（Bare Metal Server）之所以有这么个奇怪的名字，主要是为了和虚拟化服务器划清界限。云计算的一大特点，就是从买到租，用户向云服务提供商租用计算资源。而这些租用的计算资源，<strong>大部分</strong>都不是物理资源，而是借助虚拟化技术产生的虚拟资源。</p>
<p>没错，这个“大部分”，就是意味着有特例。而裸金属服务器，就是其中一个典型特例。</p>
<p>那为什么在全面云化的时代背景下，还需要提供物理服务器呢？</p>
<p>虚拟化并不是完美无缺的。它有两个无法回避的缺陷。</p>
<p>首先第一点，是性能损失。这一点可以参考上文的虚拟化技术，就可以知道不管是Type1型还是Type2型虚拟化，都会有一定的性能损耗。对于一些性能要求高的业务（例如高性能运算），虚拟化会带来性能延迟。如果发生密集的I/O（输入/输出）操作，也会存在性能损失。</p>
<p>第二点，就是嘈杂邻居效应。</p>
<p>传统计算是买房子，独栋别墅，自己住很嗨皮，但是价格贵，而且不灵活，不好换房。</p>
<p>云计算（虚拟化）是租房子，一栋大楼，住了很多人（多租户）。虽然每个人是独立的房间，但是，隔壁如果开party，你还是会听到噪音。晚高峰，大家都用水洗澡，你的水肯定还是会变小。</p>
<p>也就是说，虚拟化虽然承诺了资源配额，但当其它租户突发高负荷的时候，你的使用体验还是会受到影响。对于一些对性能和稳定性要求很高的应用，这一点是无法容忍的。</p>
<p>除此之外，虚拟化还有其它一些缺点，例如：有一些硬件设备不支持虚拟化，还有一些硬件新功能（例如CPU的新特性）在虚拟化下面用不了，这些可能都是让用户很不爽的事情。</p>
<p>综上所述，对于“VIP用户”来说，虚拟化并不完美，无法满足其需求。于是，就有了裸金属服务器。</p>
<p>裸金属服务器，又不仅限于物理服务器，它是物理服务器和云服务的结合。</p>
<p>“裸金属”，意味它不包括相应的操作系统和软件，这个是客户后期自选配置的。大部分云服务提供商的裸金属服务器产品，不提供本地硬盘（可以支持），主要提供CPU和内存。</p>
<p>裸金属服务器依然是租。云服务提供商租给你一个专属的物理服务器，你是唯一的租户。</p>
<p><img src="https://s1.ax1x.com/2022/07/31/vktcDA.jpg" alt="图片"></p>
<p>裸金属服务器本身也不是和虚拟化完全水火不容。现在部分云服务提供商的裸金属服务器产品，都兼容各种Hypervisor平台（管理物理资源，构建虚拟化的底层平台。例如VMware、KVM、Xen、Virtual Box，都属于Hypervisor。详情可以看这里：链接），也就是说，也支持虚拟化。</p>
<p>某云服务提供商还搞出了“弹性”裸金属服务器，自研的虚拟化技术，可以解决前面所说的虚拟化性能开销问题，可以具备物理机级别的完整处理器特性，感觉还是蛮厉害的。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.redhat.com/zh/topics/virtualization">了解虚拟化</a></p>
<p><a href="https://blog.csdn.net/qq_38987057/article/details/107852971">什么是裸金属服务器</a></p>
<p><a href="">深入浅出计算机组成原理–理解虚拟机：你在云上拿到的计算机是什么样的？</a></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
        <tag>虚拟机</tag>
        <tag>Docker</tag>
        <tag>裸金属服务器</tag>
      </tags>
  </entry>
</search>
